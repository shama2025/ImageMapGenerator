import "./chunk-VUNV25KB.js";

// node_modules/@annotorious/annotorious/dist/annotorious.es.js
var go = Object.defineProperty;
var mo = (e, t, n) => t in e ? go(e, t, { enumerable: true, configurable: true, writable: true, value: n }) : e[t] = n;
var Et = (e, t, n) => mo(e, typeof t != "symbol" ? t + "" : t, n);
function ee() {
}
function Ut(e, t) {
  for (const n in t) e[n] = t[n];
  return (
    /** @type {T & S} */
    e
  );
}
function Hn(e) {
  return e();
}
function Zt() {
  return /* @__PURE__ */ Object.create(null);
}
function Se(e) {
  e.forEach(Hn);
}
function ie(e) {
  return typeof e == "function";
}
function se(e, t) {
  return e != e ? t == t : e !== t || e && typeof e == "object" || typeof e == "function";
}
function po(e) {
  return Object.keys(e).length === 0;
}
function Gn(e, ...t) {
  if (e == null) {
    for (const o of t)
      o(void 0);
    return ee;
  }
  const n = e.subscribe(...t);
  return n.unsubscribe ? () => n.unsubscribe() : n;
}
function vt(e, t, n) {
  e.$$.on_destroy.push(Gn(t, n));
}
function _o(e, t, n, o) {
  if (e) {
    const i = jn(e, t, n, o);
    return e[0](i);
  }
}
function jn(e, t, n, o) {
  return e[1] && o ? Ut(n.ctx.slice(), e[1](o(t))) : n.ctx;
}
function yo(e, t, n, o) {
  if (e[2] && o) {
    const i = e[2](o(n));
    if (t.dirty === void 0)
      return i;
    if (typeof i == "object") {
      const s = [], r = Math.max(t.dirty.length, i.length);
      for (let l = 0; l < r; l += 1)
        s[l] = t.dirty[l] | i[l];
      return s;
    }
    return t.dirty | i;
  }
  return t.dirty;
}
function wo(e, t, n, o, i, s) {
  if (i) {
    const r = jn(t, n, o, s);
    e.p(r, i);
  }
}
function bo(e) {
  if (e.ctx.length > 32) {
    const t = [], n = e.ctx.length / 32;
    for (let o = 0; o < n; o++)
      t[o] = -1;
    return t;
  }
  return -1;
}
function Jt(e) {
  const t = {};
  for (const n in e) n[0] !== "$" && (t[n] = e[n]);
  return t;
}
function ze(e) {
  return e ?? "";
}
function j(e, t) {
  e.appendChild(t);
}
function N(e, t, n) {
  e.insertBefore(t, n || null);
}
function D(e) {
  e.parentNode && e.parentNode.removeChild(e);
}
function Ne(e, t) {
  for (let n = 0; n < e.length; n += 1)
    e[n] && e[n].d(t);
}
function P(e) {
  return document.createElementNS("http://www.w3.org/2000/svg", e);
}
function zn(e) {
  return document.createTextNode(e);
}
function ye() {
  return zn(" ");
}
function Ae() {
  return zn("");
}
function W(e, t, n, o) {
  return e.addEventListener(t, n, o), () => e.removeEventListener(t, n, o);
}
function c(e, t, n) {
  n == null ? e.removeAttribute(t) : e.getAttribute(t) !== n && e.setAttribute(t, n);
}
function Eo(e) {
  return Array.from(e.childNodes);
}
function Me(e, t, n) {
  e.classList.toggle(t, !!n);
}
function vo(e, t, { bubbles: n = false, cancelable: o = false } = {}) {
  return new CustomEvent(e, { detail: t, bubbles: n, cancelable: o });
}
var xe;
function Qe(e) {
  xe = e;
}
function Fn() {
  if (!xe) throw new Error("Function called outside component initialization");
  return xe;
}
function Re(e) {
  Fn().$$.on_mount.push(e);
}
function Oe() {
  const e = Fn();
  return (t, n, { cancelable: o = false } = {}) => {
    const i = e.$$.callbacks[t];
    if (i) {
      const s = vo(
        /** @type {string} */
        t,
        n,
        { cancelable: o }
      );
      return i.slice().forEach((r) => {
        r.call(e, s);
      }), !s.defaultPrevented;
    }
    return true;
  };
}
function ue(e, t) {
  const n = e.$$.callbacks[t.type];
  n && n.slice().forEach((o) => o.call(this, t));
}
var Ge = [];
var ht = [];
var qe = [];
var Qt = [];
var qn = Promise.resolve();
var Vt = false;
function Kn() {
  Vt || (Vt = true, qn.then(Zn));
}
function Wn() {
  return Kn(), qn;
}
function Xt(e) {
  qe.push(e);
}
var St = /* @__PURE__ */ new Set();
var Ue = 0;
function Zn() {
  if (Ue !== 0)
    return;
  const e = xe;
  do {
    try {
      for (; Ue < Ge.length; ) {
        const t = Ge[Ue];
        Ue++, Qe(t), So(t.$$);
      }
    } catch (t) {
      throw Ge.length = 0, Ue = 0, t;
    }
    for (Qe(null), Ge.length = 0, Ue = 0; ht.length; ) ht.pop()();
    for (let t = 0; t < qe.length; t += 1) {
      const n = qe[t];
      St.has(n) || (St.add(n), n());
    }
    qe.length = 0;
  } while (Ge.length);
  for (; Qt.length; )
    Qt.pop()();
  Vt = false, St.clear(), Qe(e);
}
function So(e) {
  if (e.fragment !== null) {
    e.update(), Se(e.before_update);
    const t = e.dirty;
    e.dirty = [-1], e.fragment && e.fragment.p(e.ctx, t), e.after_update.forEach(Xt);
  }
}
function Ao(e) {
  const t = [], n = [];
  qe.forEach((o) => e.indexOf(o) === -1 ? t.push(o) : n.push(o)), n.forEach((o) => o()), qe = t;
}
var ct = /* @__PURE__ */ new Set();
var De;
function we() {
  De = {
    r: 0,
    c: [],
    p: De
    // parent group
  };
}
function be() {
  De.r || Se(De.c), De = De.p;
}
function B(e, t) {
  e && e.i && (ct.delete(e), e.i(t));
}
function H(e, t, n, o) {
  if (e && e.o) {
    if (ct.has(e)) return;
    ct.add(e), De.c.push(() => {
      ct.delete(e), o && (n && e.d(1), o());
    }), e.o(t);
  } else o && o();
}
function ve(e) {
  return (e == null ? void 0 : e.length) !== void 0 ? e : Array.from(e);
}
function ae(e) {
  e && e.c();
}
function re(e, t, n) {
  const { fragment: o, after_update: i } = e.$$;
  o && o.m(t, n), Xt(() => {
    const s = e.$$.on_mount.map(Hn).filter(ie);
    e.$$.on_destroy ? e.$$.on_destroy.push(...s) : Se(s), e.$$.on_mount = [];
  }), i.forEach(Xt);
}
function le(e, t) {
  const n = e.$$;
  n.fragment !== null && (Ao(n.after_update), Se(n.on_destroy), n.fragment && n.fragment.d(t), n.on_destroy = n.fragment = null, n.ctx = []);
}
function ko(e, t) {
  e.$$.dirty[0] === -1 && (Ge.push(e), Kn(), e.$$.dirty.fill(0)), e.$$.dirty[t / 31 | 0] |= 1 << t % 31;
}
function me(e, t, n, o, i, s, r = null, l = [-1]) {
  const a = xe;
  Qe(e);
  const u = e.$$ = {
    fragment: null,
    ctx: [],
    // state
    props: s,
    update: ee,
    not_equal: i,
    bound: Zt(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(t.context || (a ? a.$$.context : [])),
    // everything else
    callbacks: Zt(),
    dirty: l,
    skip_bound: false,
    root: t.target || a.$$.root
  };
  r && r(u.root);
  let d = false;
  if (u.ctx = n ? n(e, t.props || {}, (f, h, ...p) => {
    const m = p.length ? p[0] : h;
    return u.ctx && i(u.ctx[f], u.ctx[f] = m) && (!u.skip_bound && u.bound[f] && u.bound[f](m), d && ko(e, f)), h;
  }) : [], u.update(), d = true, Se(u.before_update), u.fragment = o ? o(u.ctx) : false, t.target) {
    if (t.hydrate) {
      const f = Eo(t.target);
      u.fragment && u.fragment.l(f), f.forEach(D);
    } else
      u.fragment && u.fragment.c();
    t.intro && B(e.$$.fragment), re(e, t.target, t.anchor), Zn();
  }
  Qe(a);
}
var pe = class {
  constructor() {
    Et(this, "$$");
    Et(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    le(this, 1), this.$destroy = ee;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(t, n) {
    if (!ie(n))
      return ee;
    const o = this.$$.callbacks[t] || (this.$$.callbacks[t] = []);
    return o.push(n), () => {
      const i = o.indexOf(n);
      i !== -1 && o.splice(i, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(t) {
    this.$$set && !po(t) && (this.$$.skip_bound = true, this.$$set(t), this.$$.skip_bound = false);
  }
};
var Mo = "4";
typeof window < "u" && (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(Mo);
var x = ((e) => (e.ELLIPSE = "ELLIPSE", e.MULTIPOLYGON = "MULTIPOLYGON", e.POLYGON = "POLYGON", e.POLYLINE = "POLYLINE", e.RECTANGLE = "RECTANGLE", e.LINE = "LINE", e))(x || {});
function To(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Jn = { exports: {} };
(function(e) {
  (function() {
    function t(l, a) {
      var u = l.x - a.x, d = l.y - a.y;
      return u * u + d * d;
    }
    function n(l, a, u) {
      var d = a.x, f = a.y, h = u.x - d, p = u.y - f;
      if (h !== 0 || p !== 0) {
        var m = ((l.x - d) * h + (l.y - f) * p) / (h * h + p * p);
        m > 1 ? (d = u.x, f = u.y) : m > 0 && (d += h * m, f += p * m);
      }
      return h = l.x - d, p = l.y - f, h * h + p * p;
    }
    function o(l, a) {
      for (var u = l[0], d = [u], f, h = 1, p = l.length; h < p; h++)
        f = l[h], t(f, u) > a && (d.push(f), u = f);
      return u !== f && d.push(f), d;
    }
    function i(l, a, u, d, f) {
      for (var h = d, p, m = a + 1; m < u; m++) {
        var g = n(l[m], l[a], l[u]);
        g > h && (p = m, h = g);
      }
      h > d && (p - a > 1 && i(l, a, p, d, f), f.push(l[p]), u - p > 1 && i(l, p, u, d, f));
    }
    function s(l, a) {
      var u = l.length - 1, d = [l[0]];
      return i(l, 0, u, a, d), d.push(l[u]), d;
    }
    function r(l, a, u) {
      if (l.length <= 2) return l;
      var d = a !== void 0 ? a * a : 1;
      return l = u ? l : o(l, d), l = s(l, d), l;
    }
    e.exports = r, e.exports.default = r;
  })();
})(Jn);
var Lo = Jn.exports;
var Po = To(Lo);
var zt = {};
var Ke = (e, t) => zt[e] = t;
var Ht = (e) => zt[e.type].area(e);
var Io = (e, t, n, o) => zt[e.type].intersects(e, t, n, o);
var ge = (e) => {
  let t = 1 / 0, n = 1 / 0, o = -1 / 0, i = -1 / 0;
  return e.forEach(([s, r]) => {
    t = Math.min(t, s), n = Math.min(n, r), o = Math.max(o, s), i = Math.max(i, r);
  }), { minX: t, minY: n, maxX: o, maxY: i };
};
var gt = (e) => {
  let t = 0, n = e.length - 1;
  for (let o = 0; o < e.length; o++)
    t += (e[n][0] + e[o][0]) * (e[n][1] - e[o][1]), n = o;
  return Math.abs(0.5 * t);
};
var mt = (e, t, n) => {
  let o = false;
  for (let i = 0, s = e.length - 1; i < e.length; s = i++) {
    const r = e[i][0], l = e[i][1], a = e[s][0], u = e[s][1];
    l > n != u > n && t < (a - r) * (n - l) / (u - l) + r && (o = !o);
  }
  return o;
};
var Co = (e, t = true) => {
  let n = "M ";
  return e.forEach(([o, i], s) => {
    s === 0 ? n += `${o},${i}` : n += ` L ${o},${i}`;
  }), t && (n += " Z"), n;
};
var Qn = (e, t = 1) => {
  const n = e.map(([o, i]) => ({ x: o, y: i }));
  return Po(n, t, true).map((o) => [o.x, o.y]);
};
var ut = (e, t) => {
  const n = Math.abs(t[0] - e[0]), o = Math.abs(t[1] - e[1]);
  return Math.sqrt(Math.pow(n, 2) + Math.pow(o, 2));
};
var Oo = {
  area: (e) => Math.PI * e.geometry.rx * e.geometry.ry,
  intersects: (e, t, n) => {
    const { cx: o, cy: i, rx: s, ry: r } = e.geometry, l = 0, a = Math.cos(l), u = Math.sin(l), d = t - o, f = n - i, h = a * d + u * f, p = u * d - a * f;
    return h * h / (s * s) + p * p / (r * r) <= 1;
  }
};
Ke(x.ELLIPSE, Oo);
var Do = {
  area: (e) => 0,
  intersects: (e, t, n, o = 2) => {
    const [[i, s], [r, l]] = e.geometry.points, a = Math.abs((l - s) * t - (r - i) * n + r * s - l * i), u = ut([i, s], [r, l]);
    return a / u <= o;
  }
};
Ke(x.LINE, Do);
var No = {
  area: (e) => {
    const { polygons: t } = e.geometry;
    return t.reduce((n, o) => {
      const [i, ...s] = o.rings, r = gt(i.points), l = s.reduce((a, u) => a + gt(u.points), 0);
      return n + r - l;
    }, 0);
  },
  intersects: (e, t, n) => {
    const { polygons: o } = e.geometry;
    for (const i of o) {
      const [s, ...r] = i.rings;
      if (mt(s.points, t, n)) {
        let l = false;
        for (const a of r)
          if (mt(a.points, t, n)) {
            l = true;
            break;
          }
        if (!l) return true;
      }
    }
    return false;
  }
};
var ft = (e) => {
  const t = e.reduce((n, o) => [...n, ...o.rings[0].points], []);
  return ge(t);
};
var Te = (e) => e.rings.map((n) => Co(n.points)).join(" ");
var Ro = (e) => e.polygons.reduce((t, n) => [
  ...t,
  ...n.rings.reduce((o, i) => [...o, ...i.points], [])
], []);
var Cr = (e, t = 1) => {
  const n = e.geometry.polygons.map((i) => {
    const s = i.rings.map((l) => {
      const a = Qn(l.points, t);
      return {
        ...l,
        points: a
      };
    }), r = ge(s[0].points);
    return {
      ...i,
      rings: s,
      bounds: r
    };
  }), o = ft(n);
  return {
    ...e,
    geometry: {
      ...e.geometry,
      polygons: n,
      bounds: o
    }
  };
};
Ke(x.MULTIPOLYGON, No);
var Yo = {
  area: (e) => {
    const t = e.geometry.points;
    return gt(t);
  },
  intersects: (e, t, n) => {
    const o = e.geometry.points;
    return mt(o, t, n);
  }
};
var Or = (e, t = 1) => {
  const n = Qn(e.geometry.points, t), o = ge(n);
  return {
    ...e,
    geometry: {
      ...e.geometry,
      bounds: o,
      points: n
    }
  };
};
Ke(x.POLYGON, Yo);
var Bo = {
  area: (e) => {
    const t = e.geometry;
    if (!t.closed || t.points.length < 3)
      return 0;
    const n = Gt(t.points, t.closed);
    return gt(n);
  },
  intersects: (e, t, n, o = 2) => {
    const i = e.geometry;
    if (i.closed) {
      const s = Gt(i.points, i.closed);
      return mt(s, t, n);
    } else
      return Uo(i, [t, n], o);
  }
};
var Gt = (e, t = false) => {
  const n = [];
  for (let o = 0; o < e.length; o++) {
    const i = e[o], s = e[(o + 1) % e.length];
    if (n.push(i.point), (o < e.length - 1 || t) && (i.type === "CURVE" || s.type == "CURVE")) {
      const l = xn(
        i.point,
        i.type === "CURVE" && i.outHandle || i.point,
        s.type === "CURVE" && s.inHandle || s.point,
        s.point,
        10
        // number of approximation segments
      );
      n.push(...l.slice(1));
    }
  }
  return n;
};
var xn = (e, t, n, o, i = 10) => {
  const s = [];
  for (let r = 0; r <= i; r++) {
    const l = r / i, a = Math.pow(1 - l, 3) * e[0] + 3 * Math.pow(1 - l, 2) * l * t[0] + 3 * (1 - l) * Math.pow(l, 2) * n[0] + Math.pow(l, 3) * o[0], u = Math.pow(1 - l, 3) * e[1] + 3 * Math.pow(1 - l, 2) * l * t[1] + 3 * (1 - l) * Math.pow(l, 2) * n[1] + Math.pow(l, 3) * o[1];
    s.push([a, u]);
  }
  return s;
};
var Uo = (e, t, n) => {
  for (let o = 0; o < e.points.length - 1; o++) {
    const i = e.points[o], s = e.points[o + 1];
    if (i.type === "CURVE" || s.type === "CURVE") {
      const l = xn(
        i.point,
        i.type === "CURVE" && i.outHandle || i.point,
        s.type === "CURVE" && s.inHandle || s.point,
        s.point,
        20
        // TODO make configurable? Based on scale factor? Length?
      );
      for (let a = 0; a < l.length - 1; a++)
        if (xt(t, l[a], l[a + 1]) <= n) return true;
    } else if (xt(t, i.point, s.point) <= n) return true;
  }
  return false;
};
var xt = (e, t, n) => {
  const [o, i] = e, [s, r] = t, [l, a] = n, u = l - s, d = a - r, f = Math.sqrt(u * u + d * d);
  if (f === 0)
    return Math.sqrt((o - s) * (o - s) + (i - r) * (i - r));
  const h = ((o - s) * u + (i - r) * d) / (f * f);
  return h <= 0 ? Math.sqrt((o - s) * (o - s) + (i - r) * (i - r)) : h >= 1 ? Math.sqrt((o - l) * (o - l) + (i - a) * (i - a)) : Math.abs((a - r) * o - (l - s) * i + l * r - a * s) / f;
};
var $n = (e) => {
  if (!e.points || e.points.length === 0)
    return "";
  const t = [], n = e.points[0];
  t.push(`M ${n.point[0]} ${n.point[1]}`);
  for (let o = 1; o < e.points.length; o++) {
    const i = e.points[o], s = e.points[o - 1];
    if (i.type === "CURVE" || s.type === "CURVE") {
      const r = s.type === "CURVE" && s.outHandle || s.point, l = i.type === "CURVE" && i.inHandle || i.point, a = i.point;
      t.push(`C ${r[0]} ${r[1]} ${l[0]} ${l[1]} ${a[0]} ${a[1]}`);
    } else
      t.push(`L ${i.point[0]} ${i.point[1]}`);
  }
  if (e.closed) {
    const o = e.points[e.points.length - 1], i = e.points[0];
    if (o.type === "CURVE" || i.type === "CURVE") {
      const r = o.outHandle || o.point, l = i.inHandle || i.point, a = i.point;
      t.push(`C ${r[0]} ${r[1]} ${l[0]} ${l[1]} ${a[0]} ${a[1]}`);
    }
    t.push("Z");
  }
  return t.join(" ");
};
Ke(x.POLYLINE, Bo);
var Vo = {
  area: (e) => e.geometry.w * e.geometry.h,
  intersects: (e, t, n) => t >= e.geometry.x && t <= e.geometry.x + e.geometry.w && n >= e.geometry.y && n <= e.geometry.y + e.geometry.h
};
Ke(x.RECTANGLE, Vo);
var pt = (e) => dt(e.target);
var dt = (e) => {
  var t, n;
  return (e == null ? void 0 : e.annotation) !== void 0 && ((n = (t = e == null ? void 0 : e.selector) == null ? void 0 : t.geometry) == null ? void 0 : n.bounds) !== void 0;
};
var Xo = (e, t = false) => {
  const n = typeof e == "string" ? e : e.value, o = /(xywh)=(pixel|percent)?:?(.+?),(.+?),(.+?),(.+)*/g, i = [...n.matchAll(o)][0], [s, r, l, a, u, d, f] = i;
  if (r !== "xywh") throw new Error("Unsupported MediaFragment: " + n);
  if (l && l !== "pixel") throw new Error(`Unsupported MediaFragment unit: ${l}`);
  const [h, p, m, g] = [a, u, d, f].map(parseFloat);
  return {
    type: x.RECTANGLE,
    geometry: {
      x: h,
      y: p,
      w: m,
      h: g,
      bounds: {
        minX: h,
        minY: t ? p - g : p,
        maxX: h + m,
        maxY: t ? p : p + g
      }
    }
  };
};
var Ho = (e) => {
  const { x: t, y: n, w: o, h: i } = e;
  return {
    type: "FragmentSelector",
    conformsTo: "http://www.w3.org/TR/media-frags/",
    value: `xywh=pixel:${t},${n},${o},${i}`
  };
};
var eo = "http://www.w3.org/2000/svg";
var $t = (e) => {
  const t = (o) => {
    Array.from(o.attributes).forEach((i) => {
      i.name.startsWith("on") && o.removeAttribute(i.name);
    });
  }, n = e.getElementsByTagName("script");
  return Array.from(n).reverse().forEach((o) => o.parentNode.removeChild(o)), Array.from(e.querySelectorAll("*")).forEach(t), e;
};
var Go = (e) => {
  const o = new XMLSerializer().serializeToString(e.documentElement).replace("<svg>", `<svg xmlns="${eo}">`);
  return new DOMParser().parseFromString(o, "image/svg+xml").documentElement;
};
var _t = (e) => {
  const n = new DOMParser().parseFromString(e, "image/svg+xml"), o = n.lookupPrefix(eo), i = n.lookupNamespaceURI(null);
  return o || i ? $t(n).firstChild : $t(Go(n)).firstChild;
};
var jo = (e) => {
  const t = to(e), n = [];
  let o = [], i = [0, 0];
  for (const s of t)
    switch (s.type.toUpperCase()) {
      case "M":
        o.length > 0 && (n.push({ points: o }), o = []), i = [s.args[0], s.args[1]], o.push([...i]);
        break;
      case "L":
        i = [s.args[0], s.args[1]], o.push([...i]);
        break;
      case "H":
        i = [s.args[0], i[1]], o.push([...i]);
        break;
      case "V":
        i = [i[0], s.args[0]], o.push([...i]);
        break;
      case "C":
        i = [s.args[4], s.args[5]], o.push([...i]);
        break;
      case "Z":
        break;
      default:
        console.warn(`Unsupported SVG path command: ${s.type}`);
        break;
    }
  if (o.length > 2 && n.push({ points: o }), n.length > 0) {
    const s = ge(n[0].points);
    return { rings: n, bounds: s };
  }
};
var zo = (e) => {
  const { point: t, inHandle: n, outHandle: o } = e;
  if (!n || !o) return false;
  const i = n[0] - t[0], s = n[1] - t[1], r = o[0] - t[0], l = o[1] - t[1], a = i * l - s * r;
  return Math.abs(a) < 0.01;
};
var Fo = (e) => {
  const t = to(e);
  let n = [], o = [0, 0], i = false;
  for (let r = 0; r < t.length; r++) {
    const l = t[r];
    switch (l.type.toUpperCase()) {
      case "M":
        o = [l.args[0], l.args[1]], n.push({
          type: "CORNER",
          point: [...o]
        });
        break;
      case "L":
        o = [l.args[0], l.args[1]], n.push({
          type: "CORNER",
          point: [...o]
        });
        break;
      case "C":
        const a = [l.args[0], l.args[1]], u = [l.args[2], l.args[3]], d = [l.args[4], l.args[5]];
        if (n.length > 0) {
          const h = n[n.length - 1];
          (a[0] !== h.point[0] || a[1] !== h.point[1]) && (h.type = "CURVE", h.outHandle = a);
        }
        const f = {
          type: u[0] !== d[0] || u[1] !== d[1] ? "CURVE" : "CORNER",
          point: d
        };
        f.type === "CURVE" && (f.inHandle = u), n.push(f), o = d;
        break;
      case "Z":
        i = true;
        break;
      default:
        console.warn(`Unsupported SVG path command: ${l.type}`);
        break;
    }
  }
  n = n.map((r) => zo(r) ? { ...r, locked: true } : r);
  const s = ge(Gt(n, i));
  return {
    points: n,
    closed: i,
    bounds: s
  };
};
var to = (e) => {
  const t = [], n = e.replace(/,/g, " ").trim(), o = /([MmLlHhVvCcZz])\s*([^MmLlHhVvCcZz]*)/g;
  let i;
  for (; (i = o.exec(n)) !== null; ) {
    const [, s, r] = i, l = r.trim() === "" ? [] : r.trim().split(/\s+/).map(Number).filter((a) => !isNaN(a));
    t.push({
      type: s,
      args: l
    });
  }
  return t;
};
var qo = (e) => {
  const [t, n, o] = e.match(/(<polygon points=["|'])([^("|')]*)/) || [], i = o.split(" ").map((s) => s.split(",").map(parseFloat));
  return {
    type: x.POLYGON,
    geometry: {
      points: i,
      bounds: ge(i)
    }
  };
};
var Ko = (e) => {
  const t = _t(e), n = parseFloat(t.getAttribute("cx")), o = parseFloat(t.getAttribute("cy")), i = parseFloat(t.getAttribute("rx")), s = parseFloat(t.getAttribute("ry")), r = {
    minX: n - i,
    minY: o - s,
    maxX: n + i,
    maxY: o + s
  };
  return {
    type: x.ELLIPSE,
    geometry: {
      cx: n,
      cy: o,
      rx: i,
      ry: s,
      bounds: r
    }
  };
};
var Wo = (e) => {
  const t = _t(e), n = parseFloat(t.getAttribute("x1")), o = parseFloat(t.getAttribute("x2")), i = parseFloat(t.getAttribute("y1")), s = parseFloat(t.getAttribute("y2")), r = {
    minX: Math.min(n, o),
    minY: Math.min(i, s),
    maxX: Math.max(n, o),
    maxY: Math.max(i, s)
  };
  return {
    type: x.LINE,
    geometry: {
      points: [[n, i], [o, s]],
      bounds: r
    }
  };
};
var Zo = (e) => {
  const t = _t(e), n = t.nodeName === "path" ? t : Array.from(t.querySelectorAll("path"))[0], o = n == null ? void 0 : n.getAttribute("d");
  if (!o)
    throw new Error("Could not parse SVG path");
  const i = Fo(o);
  if (!i)
    throw new Error("Could not parse SVG path");
  return {
    type: x.POLYLINE,
    geometry: i
  };
};
var Jo = (e) => {
  const t = _t(e), i = (t.nodeName === "path" ? [t] : Array.from(t.querySelectorAll("path"))).map((a) => a.getAttribute("d") || "").map((a) => jo(a)).filter(Boolean), s = i.reduce((a, u) => [...a, ...u.rings[0].points], []), r = ge(s);
  return i.length === 1 && i[0].rings.length === 1 ? {
    type: x.POLYGON,
    geometry: {
      points: s,
      bounds: r
    }
  } : {
    type: x.MULTIPOLYGON,
    geometry: {
      polygons: i,
      bounds: r
    }
  };
};
var Qo = (e) => {
  const t = typeof e == "string" ? e : e.value;
  if (t.includes("<polygon points="))
    return qo(t);
  if (t.includes("<path ") && (t.includes(" C ") || !t.includes("Z")))
    return Zo(t);
  if (t.includes("<path "))
    return Jo(t);
  if (t.includes("<ellipse "))
    return Ko(t);
  if (t.includes("<line "))
    return Wo(t);
  throw "Unsupported SVG shape: " + t;
};
var xo = (e) => `<g>${e.polygons.map((n) => `<path fill-rule="evenodd" d="${Te(n)}" />`).join("")}</g>`;
var $o = (e) => {
  let t;
  switch (e.type) {
    case x.POLYGON: {
      const n = e.geometry, { points: o } = n;
      t = `<svg><polygon points="${o.map((i) => i.join(",")).join(" ")}" /></svg>`;
      break;
    }
    case x.ELLIPSE: {
      const n = e.geometry;
      t = `<svg><ellipse cx="${n.cx}" cy="${n.cy}" rx="${n.rx}" ry="${n.ry}" /></svg>`;
      break;
    }
    case x.MULTIPOLYGON: {
      const n = e.geometry;
      t = `<svg>${xo(n)}</svg>`;
      break;
    }
    case x.LINE: {
      const n = e.geometry, [[o, i], [s, r]] = n.points;
      t = `<svg><line x1="${o}" y1="${i}" x2="${s}" y2="${r}" /></svg>`;
      break;
    }
    case x.POLYLINE:
      t = `<svg><path d="${$n(e.geometry)}" /></svg>`;
  }
  if (t)
    return { type: "SvgSelector", value: t };
  throw `Unsupported shape type: ${e.type}`;
};
var de = [];
for (let e = 0; e < 256; ++e)
  de.push((e + 256).toString(16).slice(1));
function ei(e, t = 0) {
  return (de[e[t + 0]] + de[e[t + 1]] + de[e[t + 2]] + de[e[t + 3]] + "-" + de[e[t + 4]] + de[e[t + 5]] + "-" + de[e[t + 6]] + de[e[t + 7]] + "-" + de[e[t + 8]] + de[e[t + 9]] + "-" + de[e[t + 10]] + de[e[t + 11]] + de[e[t + 12]] + de[e[t + 13]] + de[e[t + 14]] + de[e[t + 15]]).toLowerCase();
}
var At;
var ti = new Uint8Array(16);
function ni() {
  if (!At) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    At = crypto.getRandomValues.bind(crypto);
  }
  return At(ti);
}
var oi = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var en = { randomUUID: oi };
function ii(e, t, n) {
  var i;
  e = e || {};
  const o = e.random ?? ((i = e.rng) == null ? void 0 : i.call(e)) ?? ni();
  if (o.length < 16)
    throw new Error("Random bytes length must be >= 16");
  return o[6] = o[6] & 15 | 64, o[8] = o[8] & 63 | 128, ei(o);
}
function no(e, t, n) {
  return en.randomUUID && !e ? en.randomUUID() : ii(e);
}
var tn = Object.prototype.hasOwnProperty;
function Ce(e, t) {
  var n, o;
  if (e === t) return true;
  if (e && t && (n = e.constructor) === t.constructor) {
    if (n === Date) return e.getTime() === t.getTime();
    if (n === RegExp) return e.toString() === t.toString();
    if (n === Array) {
      if ((o = e.length) === t.length)
        for (; o-- && Ce(e[o], t[o]); ) ;
      return o === -1;
    }
    if (!n || typeof e == "object") {
      o = 0;
      for (n in e)
        if (tn.call(e, n) && ++o && !tn.call(t, n) || !(n in t) || !Ce(e[n], t[n])) return false;
      return Object.keys(t).length === o;
    }
  }
  return e !== e && t !== t;
}
function kt() {
}
function si(e, t) {
  return e != e ? t == t : e !== t || e && typeof e == "object" || typeof e == "function";
}
var Ve = [];
function Ft(e, t = kt) {
  let n;
  const o = /* @__PURE__ */ new Set();
  function i(l) {
    if (si(e, l) && (e = l, n)) {
      const a = !Ve.length;
      for (const u of o)
        u[1](), Ve.push(u, e);
      if (a) {
        for (let u = 0; u < Ve.length; u += 2)
          Ve[u][0](Ve[u + 1]);
        Ve.length = 0;
      }
    }
  }
  function s(l) {
    i(l(e));
  }
  function r(l, a = kt) {
    const u = [l, a];
    return o.add(u), o.size === 1 && (n = t(i, s) || kt), l(e), () => {
      o.delete(u), o.size === 0 && n && (n(), n = null);
    };
  }
  return { set: i, update: s, subscribe: r };
}
var ri = (e) => {
  const { subscribe: t, set: n } = Ft();
  let o;
  return t((i) => o = i), e.observe(({ changes: i }) => {
    if (o) {
      (i.deleted || []).some((r) => r.id === o) && n(void 0);
      const s = (i.updated || []).find(({ oldValue: r }) => r.id === o);
      s && n(s.newValue.id);
    }
  }), {
    get current() {
      return o;
    },
    subscribe: t,
    set: n
  };
};
var oo = ((e) => (e.EDIT = "EDIT", e.SELECT = "SELECT", e.NONE = "NONE", e))(oo || {});
var st = { selected: [] };
var li = (e, t, n) => {
  const { subscribe: o, set: i } = Ft(st);
  let s = t, r = st;
  o((g) => r = g);
  const l = () => {
    Ce(r, st) || i(st);
  }, a = () => {
    var g;
    return ((g = r.selected) == null ? void 0 : g.length) === 0;
  }, u = (g) => {
    if (a())
      return false;
    const k = typeof g == "string" ? g : g.id;
    return r.selected.some((E) => E.id === k);
  }, d = (g, k) => {
    let E;
    if (Array.isArray(g)) {
      if (E = g.map((y) => e.getAnnotation(y)).filter(Boolean), E.length < g.length) {
        console.warn("Invalid selection: " + g.filter((y) => !E.some((A) => A.id === y)));
        return;
      }
    } else {
      const y = e.getAnnotation(g);
      if (!y) {
        console.warn("Invalid selection: " + g);
        return;
      }
      E = [y];
    }
    const S = E.reduce((y, A) => {
      const M = m(A);
      return M === "EDIT" ? [...y, { id: A.id, editable: true }] : M === "SELECT" ? [...y, { id: A.id }] : y;
    }, []);
    i({ selected: S, event: k });
  }, f = (g, k) => {
    const E = Array.isArray(g) ? g : [g], S = E.map((y) => e.getAnnotation(y)).filter((y) => !!y);
    i({
      selected: S.map((y) => {
        const A = k === void 0 ? m(y) === "EDIT" : k;
        return { id: y.id, editable: A };
      })
    }), S.length !== E.length && console.warn("Invalid selection", g);
  }, h = (g) => {
    if (a())
      return false;
    const { selected: k } = r;
    k.some(({ id: E }) => g.includes(E)) && i({ selected: k.filter(({ id: E }) => !g.includes(E)) });
  }, p = (g) => {
    s = g, f(r.selected.map(({ id: k }) => k));
  }, m = (g) => ai(g, s, n);
  return e.observe(
    ({ changes: g }) => h((g.deleted || []).map((k) => k.id))
  ), {
    get event() {
      return r ? r.event : null;
    },
    get selected() {
      return r ? [...r.selected] : null;
    },
    get userSelectAction() {
      return s;
    },
    clear: l,
    evalSelectAction: m,
    isEmpty: a,
    isSelected: u,
    setSelected: f,
    setUserSelectAction: p,
    subscribe: o,
    userSelect: d
  };
};
var ai = (e, t, n) => {
  const o = n ? n.serialize(e) : e;
  return typeof t == "function" ? t(o) : t || "EDIT";
};
var he = [];
for (let e = 0; e < 256; ++e)
  he.push((e + 256).toString(16).slice(1));
function ci(e, t = 0) {
  return (he[e[t + 0]] + he[e[t + 1]] + he[e[t + 2]] + he[e[t + 3]] + "-" + he[e[t + 4]] + he[e[t + 5]] + "-" + he[e[t + 6]] + he[e[t + 7]] + "-" + he[e[t + 8]] + he[e[t + 9]] + "-" + he[e[t + 10]] + he[e[t + 11]] + he[e[t + 12]] + he[e[t + 13]] + he[e[t + 14]] + he[e[t + 15]]).toLowerCase();
}
var Mt;
var ui = new Uint8Array(16);
function fi() {
  if (!Mt) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    Mt = crypto.getRandomValues.bind(crypto);
  }
  return Mt(ui);
}
var di = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var nn = { randomUUID: di };
function hi(e, t, n) {
  var o;
  e = e || {};
  const i = e.random ?? ((o = e.rng) == null ? void 0 : o.call(e)) ?? fi();
  if (i.length < 16)
    throw new Error("Random bytes length must be >= 16");
  return i[6] = i[6] & 15 | 64, i[8] = i[8] & 63 | 128, ci(i);
}
function io(e, t, n) {
  return nn.randomUUID && !e ? nn.randomUUID() : hi(e);
}
var Tt = (e) => {
  const t = (n) => {
    const o = { ...n };
    return n.created && typeof n.created == "string" && (o.created = new Date(n.created)), n.updated && typeof n.updated == "string" && (o.updated = new Date(n.updated)), o;
  };
  return {
    ...e,
    bodies: (e.bodies || []).map(t),
    target: t(e.target)
  };
};
var Dr = (e, t, n, o) => ({
  id: io(),
  annotation: typeof e == "string" ? e : e.id,
  created: n || /* @__PURE__ */ new Date(),
  creator: o,
  ...t
});
var gi = (e, t) => {
  const n = new Set(e.bodies.map((o) => o.id));
  return t.bodies.filter((o) => !n.has(o.id));
};
var mi = (e, t) => {
  const n = new Set(t.bodies.map((o) => o.id));
  return e.bodies.filter((o) => !n.has(o.id));
};
var pi = (e, t) => t.bodies.map((n) => {
  const o = e.bodies.find((i) => i.id === n.id);
  return { newBody: n, oldBody: o && !Ce(o, n) ? o : void 0 };
}).filter(({ oldBody: n }) => n).map(({ oldBody: n, newBody: o }) => ({ oldBody: n, newBody: o }));
var _i = (e, t) => !Ce(e.target, t.target);
var so = (e, t) => {
  const n = gi(e, t), o = mi(e, t), i = pi(e, t);
  return {
    oldValue: e,
    newValue: t,
    bodiesCreated: n.length > 0 ? n : void 0,
    bodiesDeleted: o.length > 0 ? o : void 0,
    bodiesUpdated: i.length > 0 ? i : void 0,
    targetUpdated: _i(e, t) ? { oldTarget: e.target, newTarget: t.target } : void 0
  };
};
var ne = ((e) => (e.LOCAL = "LOCAL", e.REMOTE = "REMOTE", e.SILENT = "SILENT", e))(ne || {});
var yi = (e, t) => {
  var n, o;
  const { changes: i, origin: s } = t;
  if (!(e.options.origin ? e.options.origin === s : s !== "SILENT"))
    return false;
  if (e.options.ignore) {
    const { ignore: r } = e.options, l = (a) => a && a.length > 0;
    if (!(l(i.created) || l(i.deleted))) {
      const a = (n = i.updated) == null ? void 0 : n.some((d) => l(d.bodiesCreated) || l(d.bodiesDeleted) || l(d.bodiesUpdated)), u = (o = i.updated) == null ? void 0 : o.some((d) => d.targetUpdated);
      if (r === "BODY_ONLY" && a && !u || r === "TARGET_ONLY" && u && !a)
        return false;
    }
  }
  if (e.options.annotations) {
    const r = /* @__PURE__ */ new Set([
      ...(i.created || []).map((l) => l.id),
      ...(i.deleted || []).map((l) => l.id),
      ...(i.updated || []).map(({ oldValue: l }) => l.id)
    ]);
    return !!(Array.isArray(e.options.annotations) ? e.options.annotations : [e.options.annotations]).find((l) => r.has(l));
  } else
    return true;
};
var wi = (e, t) => {
  const n = new Set((e.created || []).map((f) => f.id)), o = new Set((e.updated || []).map(({ newValue: f }) => f.id)), i = new Set((t.created || []).map((f) => f.id)), s = new Set((t.deleted || []).map((f) => f.id)), r = new Set((t.updated || []).map(({ oldValue: f }) => f.id)), l = new Set((t.updated || []).filter(({ oldValue: f }) => n.has(f.id) || o.has(f.id)).map(({ oldValue: f }) => f.id)), a = [
    ...(e.created || []).filter((f) => !s.has(f.id)).map((f) => r.has(f.id) ? t.updated.find(({ oldValue: h }) => h.id === f.id).newValue : f),
    ...t.created || []
  ], u = [
    ...(e.deleted || []).filter((f) => !i.has(f.id)),
    ...(t.deleted || []).filter((f) => !n.has(f.id))
  ], d = [
    ...(e.updated || []).filter(({ newValue: f }) => !s.has(f.id)).map((f) => {
      const { oldValue: h, newValue: p } = f;
      if (r.has(p.id)) {
        const m = t.updated.find((g) => g.oldValue.id === p.id).newValue;
        return so(h, m);
      } else
        return f;
    }),
    ...(t.updated || []).filter(({ oldValue: f }) => !l.has(f.id))
  ];
  return { created: a, deleted: u, updated: d };
};
var rt = (e) => {
  const t = e.id === void 0 ? io() : e.id;
  return {
    ...e,
    id: t,
    bodies: e.bodies === void 0 ? [] : e.bodies.map((n) => ({
      ...n,
      annotation: t
    })),
    target: {
      ...e.target,
      annotation: t
    }
  };
};
var bi = (e) => e.id !== void 0;
var Ei = () => {
  const e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Map(), n = [], o = (w, v = {}) => {
    n.push({ onChange: w, options: v });
  }, i = (w) => {
    const v = n.findIndex((_) => _.onChange == w);
    v > -1 && n.splice(v, 1);
  }, s = (w, v) => {
    const _ = {
      origin: w,
      changes: {
        created: v.created || [],
        updated: v.updated || [],
        deleted: v.deleted || []
      },
      state: [...e.values()]
    };
    n.forEach((b) => {
      yi(b, _) && b.onChange(_);
    });
  }, r = (w, v = ne.LOCAL) => {
    if (w.id && e.get(w.id))
      throw Error(`Cannot add annotation ${w.id} - exists already`);
    {
      const _ = rt(w);
      e.set(_.id, _), _.bodies.forEach((b) => t.set(b.id, _.id)), s(v, { created: [_] });
    }
  }, l = (w, v) => {
    const _ = rt(typeof w == "string" ? v : w), b = typeof w == "string" ? w : w.id, I = b && e.get(b);
    if (I) {
      const L = so(I, _);
      return b === _.id ? e.set(b, _) : (e.delete(b), e.set(_.id, _)), I.bodies.forEach((O) => t.delete(O.id)), _.bodies.forEach((O) => t.set(O.id, _.id)), L;
    } else
      console.warn(`Cannot update annotation ${b} - does not exist`);
  }, a = (w, v = ne.LOCAL, _ = ne.LOCAL) => {
    const b = bi(v) ? _ : v, I = l(w, v);
    I && s(b, { updated: [I] });
  }, u = (w, v = ne.LOCAL) => {
    e.get(w.id) ? a(w, v) : r(w, v);
  }, d = (w, v = ne.LOCAL) => {
    const _ = w.reduce((b, I) => {
      const L = l(I);
      return L ? [...b, L] : b;
    }, []);
    _.length > 0 && s(v, { updated: _ });
  }, f = (w, v = ne.LOCAL) => {
    const _ = w.map(rt), { toAdd: b, toUpdate: I } = _.reduce((O, G) => e.get(G.id) ? { ...O, toUpdate: [...O.toUpdate, G] } : { ...O, toAdd: [...O.toAdd, G] }, { toAdd: [], toUpdate: [] }), L = I.map((O) => l(O, v)).filter(Boolean);
    b.forEach((O) => {
      e.set(O.id, O), O.bodies.forEach((G) => t.set(G.id, O.id));
    }), s(v, { created: b, updated: L });
  }, h = (w, v = ne.LOCAL) => {
    const _ = e.get(w.annotation);
    if (_) {
      const b = {
        ..._,
        bodies: [..._.bodies, w]
      };
      e.set(_.id, b), t.set(w.id, b.id), s(v, { updated: [{
        oldValue: _,
        newValue: b,
        bodiesCreated: [w]
      }] });
    } else
      console.warn(`Attempt to add body to missing annotation: ${w.annotation}`);
  }, p = () => [...e.values()], m = (w = ne.LOCAL) => {
    const v = [...e.values()];
    e.clear(), t.clear(), s(w, { deleted: v });
  }, g = (w, v = true, _ = ne.LOCAL) => {
    const b = w.map(rt);
    if (v) {
      const I = [...e.values()];
      e.clear(), t.clear(), b.forEach((L) => {
        e.set(L.id, L), L.bodies.forEach((O) => t.set(O.id, L.id));
      }), s(_, { created: b, deleted: I });
    } else {
      const I = w.reduce((L, O) => {
        const G = O.id && e.get(O.id);
        return G ? [...L, G] : L;
      }, []);
      if (I.length > 0)
        throw Error(`Bulk insert would overwrite the following annotations: ${I.map((L) => L.id).join(", ")}`);
      b.forEach((L) => {
        e.set(L.id, L), L.bodies.forEach((O) => t.set(O.id, L.id));
      }), s(_, { created: b });
    }
  }, k = (w) => {
    const v = typeof w == "string" ? w : w.id, _ = e.get(v);
    if (_)
      return e.delete(v), _.bodies.forEach((b) => t.delete(b.id)), _;
    console.warn(`Attempt to delete missing annotation: ${v}`);
  }, E = (w, v = ne.LOCAL) => {
    const _ = k(w);
    _ && s(v, { deleted: [_] });
  }, S = (w, v = ne.LOCAL) => {
    const _ = w.reduce((b, I) => {
      const L = k(I);
      return L ? [...b, L] : b;
    }, []);
    _.length > 0 && s(v, { deleted: _ });
  }, y = (w) => {
    const v = e.get(w.annotation);
    if (v) {
      const _ = v.bodies.find((b) => b.id === w.id);
      if (_) {
        t.delete(_.id);
        const b = {
          ...v,
          bodies: v.bodies.filter((I) => I.id !== w.id)
        };
        return e.set(v.id, b), {
          oldValue: v,
          newValue: b,
          bodiesDeleted: [_]
        };
      } else
        console.warn(`Attempt to delete missing body ${w.id} from annotation ${w.annotation}`);
    } else
      console.warn(`Attempt to delete body from missing annotation ${w.annotation}`);
  }, A = (w, v = ne.LOCAL) => {
    const _ = y(w);
    _ && s(v, { updated: [_] });
  }, M = (w, v = ne.LOCAL) => {
    const _ = w.map((b) => y(b)).filter(Boolean);
    _.length > 0 && s(v, { updated: _ });
  }, C = (w) => {
    const v = e.get(w);
    return v ? { ...v } : void 0;
  }, T = (w) => {
    const v = t.get(w);
    if (v) {
      const _ = C(v).bodies.find((b) => b.id === w);
      if (_)
        return _;
      console.error(`Store integrity error: body ${w} in index, but not in annotation`);
    } else
      console.warn(`Attempt to retrieve missing body: ${w}`);
  }, U = (w, v) => {
    if (w.annotation !== v.annotation)
      throw "Annotation integrity violation: annotation ID must be the same when updating bodies";
    const _ = e.get(w.annotation);
    if (_) {
      const b = _.bodies.find((L) => L.id === w.id), I = {
        ..._,
        bodies: _.bodies.map((L) => L.id === b.id ? v : L)
      };
      return e.set(_.id, I), b.id !== v.id && (t.delete(b.id), t.set(v.id, I.id)), {
        oldValue: _,
        newValue: I,
        bodiesUpdated: [{ oldBody: b, newBody: v }]
      };
    } else
      console.warn(`Attempt to add body to missing annotation ${w.annotation}`);
  }, R = (w, v, _ = ne.LOCAL) => {
    const b = U(w, v);
    b && s(_, { updated: [b] });
  }, q = (w, v = ne.LOCAL) => {
    const _ = w.map((b) => U({ id: b.id, annotation: b.annotation }, b)).filter(Boolean);
    s(v, { updated: _ });
  }, z = (w) => {
    const v = e.get(w.annotation);
    if (v) {
      const _ = {
        ...v,
        target: {
          ...v.target,
          ...w
        }
      };
      return e.set(v.id, _), {
        oldValue: v,
        newValue: _,
        targetUpdated: {
          oldTarget: v.target,
          newTarget: w
        }
      };
    } else
      console.warn(`Attempt to update target on missing annotation: ${w.annotation}`);
  };
  return {
    addAnnotation: r,
    addBody: h,
    all: p,
    bulkAddAnnotations: g,
    bulkDeleteAnnotations: S,
    bulkDeleteBodies: M,
    bulkUpdateAnnotations: d,
    bulkUpdateBodies: q,
    bulkUpdateTargets: (w, v = ne.LOCAL) => {
      const _ = w.map((b) => z(b)).filter(Boolean);
      _.length > 0 && s(v, { updated: _ });
    },
    bulkUpsertAnnotations: f,
    clear: m,
    deleteAnnotation: E,
    deleteBody: A,
    getAnnotation: C,
    getBody: T,
    observe: o,
    unobserve: i,
    updateAnnotation: a,
    updateBody: R,
    updateTarget: (w, v = ne.LOCAL) => {
      const _ = z(w);
      _ && s(v, { updated: [_] });
    },
    upsertAnnotation: u
  };
};
var vi = (e) => ({
  ...e,
  subscribe: (t) => {
    const n = (o) => t(o.state);
    return e.observe(n), t(e.all()), () => e.unobserve(n);
  }
});
var Si = () => ({
  emit(e, ...t) {
    for (let n = this.events[e] || [], o = 0, i = n.length; o < i; o++)
      n[o](...t);
  },
  events: {},
  on(e, t) {
    var n;
    return ((n = this.events)[e] || (n[e] = [])).push(t), () => {
      var o;
      this.events[e] = (o = this.events[e]) == null ? void 0 : o.filter((i) => t !== i);
    };
  }
});
var Ai = 250;
var ki = (e, t) => {
  const n = Si(), o = (t == null ? void 0 : t.changes) || [];
  let i = t ? t.pointer : -1, s = false, r = 0;
  const l = (m) => {
    if (!s) {
      const { changes: g } = m, k = performance.now();
      if (k - r > Ai)
        o.splice(i + 1), o.push(g), i = o.length - 1;
      else {
        const E = o.length - 1;
        o[E] = wi(o[E], g);
      }
      r = k;
    }
    s = false;
  };
  e.observe(l, { origin: ne.LOCAL });
  const a = (m) => m && m.length > 0 && e.bulkDeleteAnnotations(m), u = (m) => m && m.length > 0 && e.bulkAddAnnotations(m, false), d = (m) => m && m.length > 0 && e.bulkUpdateAnnotations(m.map(({ oldValue: g }) => g)), f = (m) => m && m.length > 0 && e.bulkUpdateAnnotations(m.map(({ newValue: g }) => g)), h = (m) => m && m.length > 0 && e.bulkAddAnnotations(m, false), p = (m) => m && m.length > 0 && e.bulkDeleteAnnotations(m);
  return {
    canRedo: () => o.length - 1 > i,
    canUndo: () => i > -1,
    destroy: () => e.unobserve(l),
    getHistory: () => ({ changes: [...o], pointer: i }),
    on: (m, g) => n.on(m, g),
    redo: () => {
      if (o.length - 1 > i) {
        s = true;
        const { created: m, updated: g, deleted: k } = o[i + 1];
        u(m), f(g), p(k), n.emit("redo", o[i + 1]), i += 1;
      }
    },
    undo: () => {
      if (i > -1) {
        s = true;
        const { created: m, updated: g, deleted: k } = o[i];
        a(m), d(g), h(k), n.emit("undo", o[i]), i -= 1;
      }
    }
  };
};
var Mi = () => {
  const { subscribe: e, set: t } = Ft([]);
  return {
    subscribe: e,
    set: t
  };
};
var Ti = (e, t, n, o) => {
  const { hover: i, selection: s, store: r, viewport: l } = e, a = /* @__PURE__ */ new Map();
  let u = [], d, f;
  const h = (E, S) => {
    a.has(E) ? a.get(E).push(S) : a.set(E, [S]);
  }, p = (E, S) => {
    const y = a.get(E);
    if (y) {
      const A = y.indexOf(S);
      A !== -1 && y.splice(A, 1);
    }
  }, m = (E, S, y) => {
    a.has(E) && setTimeout(() => {
      a.get(E).forEach((A) => {
        if (n) {
          const M = Array.isArray(S) ? S.map((T) => n.serialize(T)) : n.serialize(S), C = y ? y instanceof PointerEvent ? y : n.serialize(y) : void 0;
          A(M, C);
        } else
          A(S, y);
      });
    }, 1);
  }, g = () => {
    const { selected: E } = s, S = (E || []).map(({ id: y }) => r.getAnnotation(y));
    S.forEach((y) => {
      const A = u.find((M) => M.id === y.id);
      (!A || !Ce(A, y)) && m("updateAnnotation", y, A);
    }), u = u.map((y) => S.find(({ id: M }) => M === y.id) || y);
  };
  s.subscribe(({ selected: E }) => {
    if (!(u.length === 0 && E.length === 0)) {
      if (u.length === 0 && E.length > 0)
        u = E.map(({ id: S }) => r.getAnnotation(S));
      else if (u.length > 0 && E.length === 0)
        u.forEach((S) => {
          const y = r.getAnnotation(S.id);
          y && !Ce(y, S) && m("updateAnnotation", y, S);
        }), u = [];
      else {
        const S = new Set(u.map((A) => A.id)), y = new Set(E.map(({ id: A }) => A));
        u.filter((A) => !y.has(A.id)).forEach((A) => {
          const M = r.getAnnotation(A.id);
          M && !Ce(M, A) && m("updateAnnotation", M, A);
        }), u = [
          // Remove annotations that were deselected
          ...u.filter((A) => y.has(A.id)),
          // Add editable annotations that were selected
          ...E.filter(({ id: A }) => !S.has(A)).map(({ id: A }) => r.getAnnotation(A))
        ];
      }
      m("selectionChanged", u);
    }
  }), i.subscribe((E) => {
    !d && E ? m("mouseEnterAnnotation", r.getAnnotation(E)) : d && !E ? m("mouseLeaveAnnotation", r.getAnnotation(d)) : d && E && (m("mouseLeaveAnnotation", r.getAnnotation(d)), m("mouseEnterAnnotation", r.getAnnotation(E))), d = E;
  }), l == null || l.subscribe((E) => m("viewportIntersect", E.map((S) => r.getAnnotation(S)))), r.observe((E) => {
    o && (f && clearTimeout(f), f = setTimeout(g, 1e3));
    const { created: S, deleted: y } = E.changes;
    (S || []).forEach((A) => m("createAnnotation", A)), (y || []).forEach((A) => m("deleteAnnotation", A)), (E.changes.updated || []).filter((A) => [
      ...A.bodiesCreated || [],
      ...A.bodiesDeleted || [],
      ...A.bodiesUpdated || []
    ].length > 0).forEach(({ oldValue: A, newValue: M }) => {
      const C = u.find((T) => T.id === A.id) || A;
      u = u.map((T) => T.id === A.id ? M : T), m("updateAnnotation", M, C);
    });
  }, { origin: ne.LOCAL }), r.observe((E) => {
    if (u) {
      const S = new Set(u.map((A) => A.id)), y = (E.changes.updated || []).filter(({ newValue: A }) => S.has(A.id)).map(({ newValue: A }) => A);
      y.length > 0 && (u = u.map((A) => y.find((C) => C.id === A.id) || A));
    }
  }, { origin: ne.REMOTE });
  const k = (E) => (S) => {
    const { updated: y } = S;
    E ? (y || []).forEach((A) => m("updateAnnotation", A.oldValue, A.newValue)) : (y || []).forEach((A) => m("updateAnnotation", A.newValue, A.oldValue));
  };
  return t.on("undo", k(true)), t.on("redo", k(false)), { on: h, off: p, emit: m };
};
var Li = (e) => (t) => t.reduce((n, o) => {
  const { parsed: i, error: s } = e.parse(o);
  return s ? {
    parsed: n.parsed,
    failed: [...n.failed, o]
  } : i ? {
    parsed: [...n.parsed, i],
    failed: n.failed
  } : {
    ...n
  };
}, { parsed: [], failed: [] });
var Pi = (e, t, n) => {
  const { store: o, selection: i } = e, s = (E) => {
    if (n) {
      const { parsed: S, error: y } = n.parse(E);
      S ? o.addAnnotation(S, ne.REMOTE) : console.error(y);
    } else
      o.addAnnotation(Tt(E), ne.REMOTE);
  }, r = () => i.clear(), l = () => o.clear(), a = (E) => {
    const S = o.getAnnotation(E);
    return n && S ? n.serialize(S) : S;
  }, u = () => n ? o.all().map(n.serialize) : o.all(), d = () => {
    var E;
    const S = (((E = i.selected) == null ? void 0 : E.map((y) => y.id)) || []).map((y) => o.getAnnotation(y)).filter(Boolean);
    return n ? S.map(n.serialize) : S;
  }, f = (E, S = true) => fetch(E).then((y) => y.json()).then((y) => (p(y, S), y)), h = (E) => {
    if (typeof E == "string") {
      const S = o.getAnnotation(E);
      if (o.deleteAnnotation(E), S)
        return n ? n.serialize(S) : S;
    } else {
      const S = n ? n.parse(E).parsed : E;
      if (S)
        return o.deleteAnnotation(S), E;
    }
  }, p = (E, S = true) => {
    if (n) {
      const y = n.parseAll || Li(n), { parsed: A, failed: M } = y(E);
      M.length > 0 && console.warn(`Discarded ${M.length} invalid annotations`, M), o.bulkAddAnnotations(A, S, ne.REMOTE);
    } else
      o.bulkAddAnnotations(E.map(Tt), S, ne.REMOTE);
  }, m = (E, S) => {
    E ? i.setSelected(E, S) : i.clear();
  }, g = (E) => {
    i.setUserSelectAction(E);
  }, k = (E) => {
    if (n) {
      const S = n.parse(E).parsed, y = n.serialize(o.getAnnotation(S.id));
      return o.updateAnnotation(S), y;
    } else {
      const S = o.getAnnotation(E.id);
      return o.updateAnnotation(Tt(E)), S;
    }
  };
  return {
    addAnnotation: s,
    cancelSelected: r,
    canRedo: t.canRedo,
    canUndo: t.canUndo,
    clearAnnotations: l,
    getAnnotationById: a,
    getAnnotations: u,
    getHistory: t.getHistory,
    getSelected: d,
    loadAnnotations: f,
    redo: t.redo,
    removeAnnotation: h,
    setAnnotations: p,
    setSelected: m,
    setUserSelectAction: g,
    undo: t.undo,
    updateAnnotation: k
  };
};
var Nr = (e, t, n) => typeof t == "function" ? t(e, n) : t;
var Rr = (e, t) => typeof e != "function" && typeof t != "function" ? {
  ...e || {},
  ...t || {}
} : (n, o) => {
  const i = typeof e == "function" ? e(n, o) : e, s = typeof t == "function" ? t(n, o) : t;
  return {
    ...i || {},
    ...s || {}
  };
};
var Ii = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
var Ci = (e) => crypto.getRandomValues(new Uint8Array(e));
var Oi = (e, t, n) => {
  let o = (2 << Math.log2(e.length - 1)) - 1, i = -~(1.6 * o * t / e.length);
  return (s = t) => {
    let r = "";
    for (; ; ) {
      let l = n(i), a = i | 0;
      for (; a--; )
        if (r += e[l[a] & o] || "", r.length >= s) return r;
    }
  };
};
var Di = (e, t = 21) => Oi(e, t | 0, Ci);
var Ni = (e = 21) => {
  let t = "", n = crypto.getRandomValues(new Uint8Array(e |= 0));
  for (; e--; )
    t += Ii[n[e] & 63];
  return t;
};
var Ri = () => ({ isGuest: true, id: Di("1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_", 20)() });
var Yi = (e) => {
  const t = JSON.stringify(e);
  let n = 0;
  for (let o = 0, i = t.length; o < i; o++) {
    let s = t.charCodeAt(o);
    n = (n << 5) - n + s, n |= 0;
  }
  return `${n}`;
};
var ro = (e) => e ? typeof e == "object" ? { ...e } : e : void 0;
var Bi = (e, t) => (Array.isArray(e) ? e : [e]).map((n) => {
  const { id: o, type: i, purpose: s, value: r, created: l, modified: a, creator: u, ...d } = n;
  return {
    id: o || `temp-${Yi(n)}`,
    annotation: t,
    type: i,
    purpose: s,
    value: r,
    creator: ro(u),
    created: l ? new Date(l) : void 0,
    updated: a ? new Date(a) : void 0,
    ...d
  };
});
var Ui = (e) => e.map((t) => {
  var n;
  const { annotation: o, created: i, updated: s, ...r } = t, l = {
    ...r,
    created: i == null ? void 0 : i.toISOString(),
    modified: s == null ? void 0 : s.toISOString()
  };
  return (n = l.id) != null && n.startsWith("temp-") && delete l.id, l;
});
var Vi = [
  "#ff7c00",
  // orange
  "#1ac938",
  // green
  "#e8000b",
  // red
  "#8b2be2",
  // purple
  "#9f4800",
  // brown
  "#f14cc1",
  // pink
  "#ffc400",
  // khaki
  "#00d7ff",
  // cyan
  "#023eff"
  // blue
];
var Yr = () => {
  const e = [...Vi];
  return { assignRandomColor: () => {
    const t = Math.floor(Math.random() * e.length), n = e[t];
    return e.splice(t, 1), n;
  }, releaseColor: (t) => e.push(t) };
};
Ni();
var Br = (e, t = { strict: true, invertY: false }) => ({ parse: (i) => Xi(i, t), serialize: (i) => Hi(i, e, t) });
var Xi = (e, t = { strict: true, invertY: false }) => {
  const n = e.id || no(), {
    creator: o,
    created: i,
    modified: s,
    body: r,
    ...l
  } = e, a = Bi(r || [], n), u = Array.isArray(e.target) ? e.target[0] : e.target, d = typeof u == "string" ? u : Array.isArray(u.selector) ? u.selector[0] : u.selector, f = typeof d == "string" || (d == null ? void 0 : d.type) === "FragmentSelector" ? Xo(d, t.invertY) : (d == null ? void 0 : d.type) === "SvgSelector" ? Qo(d) : void 0, h = Array.isArray(l.target) ? l.target[0] : l.targret;
  return f || !t.strict ? {
    parsed: {
      ...l,
      id: n,
      bodies: a,
      target: {
        created: i ? new Date(i) : void 0,
        creator: ro(o),
        updated: s ? new Date(s) : void 0,
        // Note the target can be a string and we don't want to spread the characters...
        ...typeof h == "string" ? {} : h,
        annotation: n,
        selector: f || d
      }
    }
  } : {
    error: Error(`Invalid selector: ${JSON.stringify(d)}`)
  };
};
var Hi = (e, t, n = { strict: true, invertY: false }) => {
  const {
    selector: o,
    creator: i,
    created: s,
    updated: r,
    updatedBy: l,
    // Excluded from serialization
    ...a
  } = e.target;
  let u;
  try {
    u = o.type == x.RECTANGLE ? Ho(o.geometry) : $o(o);
  } catch (f) {
    if (n.strict)
      throw f;
    u = o;
  }
  const d = {
    ...e,
    "@context": "http://www.w3.org/ns/anno.jsonld",
    id: e.id,
    type: "Annotation",
    body: Ui(e.bodies),
    created: s == null ? void 0 : s.toISOString(),
    creator: i,
    modified: r == null ? void 0 : r.toISOString(),
    target: {
      ...a,
      source: t,
      type: "SpecificResource",
      selector: u
    }
  };
  return delete d.bodies, "annotation" in d.target && delete d.target.annotation, d;
};
var Xe = [];
function Gi(e, t = ee) {
  let n;
  const o = /* @__PURE__ */ new Set();
  function i(l) {
    if (se(e, l) && (e = l, n)) {
      const a = !Xe.length;
      for (const u of o)
        u[1](), Xe.push(u, e);
      if (a) {
        for (let u = 0; u < Xe.length; u += 2)
          Xe[u][0](Xe[u + 1]);
        Xe.length = 0;
      }
    }
  }
  function s(l) {
    i(l(e));
  }
  function r(l, a = ee) {
    const u = [l, a];
    return o.add(u), o.size === 1 && (n = t(i, s) || ee), l(e), () => {
      o.delete(u), o.size === 0 && n && (n(), n = null);
    };
  }
  return { set: i, update: s, subscribe: r };
}
var ji = (e, t) => {
  const { naturalWidth: n, naturalHeight: o } = e;
  if (!n && !o) {
    const { width: i, height: s } = e;
    t.setAttribute("viewBox", `0 0 ${i} ${s}`), e.addEventListener("load", (r) => {
      const l = r.target;
      t.setAttribute("viewBox", `0 0 ${l.naturalWidth} ${l.naturalHeight}`);
    });
  } else
    t.setAttribute("viewBox", `0 0 ${n} ${o}`);
};
var zi = (e, t) => {
  ji(e, t);
  const { subscribe: n, set: o } = Gi(1);
  let i;
  return window.ResizeObserver && (i = new ResizeObserver(() => {
    const r = t.getBoundingClientRect(), { width: l, height: a } = t.viewBox.baseVal, u = Math.max(
      r.width / l,
      r.height / a
    );
    o(u);
  }), i.observe(t.parentElement)), { destroy: () => {
    i && i.disconnect();
  }, subscribe: n };
};
var Ye = (e, t) => {
  const n = typeof t == "function" ? t(e) : t;
  if (n) {
    const { fill: o, fillOpacity: i, stroke: s, strokeWidth: r, strokeOpacity: l } = n;
    let a = "";
    return o && (a += `fill:${o};`), i || i === 0 ? a += `fill-opacity:${i};` : o && (a += "fill-opacity:0.25;"), s && (a += `stroke:${s};`, a += `stroke-width:${r || "1"};`, a += `stroke-opacity:${l || "1"};`), a;
  }
};
var yt = (e, t = 0) => {
  const { minX: n, minY: o, maxX: i, maxY: s } = e;
  return {
    x: n - t,
    y: o - t,
    w: i - n + 2 * t,
    h: s - o + 2 * t
  };
};
var Le = typeof window > "u" || typeof navigator > "u" ? false : "ontouchstart" in window || navigator.maxTouchPoints > 0 || // @ts-ignore
navigator.msMaxTouchPoints > 0;
var Fi = (e) => ({});
var on = (e) => ({ grab: (
  /*onGrab*/
  e[0]
) });
function qi(e) {
  let t, n, o, i;
  const s = (
    /*#slots*/
    e[8].default
  ), r = _o(
    s,
    e,
    /*$$scope*/
    e[7],
    on
  );
  return {
    c() {
      t = P("g"), r && r.c(), c(t, "class", "a9s-annotation selected");
    },
    m(l, a) {
      N(l, t, a), r && r.m(t, null), n = true, o || (i = [
        W(
          t,
          "pointerup",
          /*onRelease*/
          e[2]
        ),
        W(
          t,
          "pointermove",
          /*onPointerMove*/
          e[1]
        )
      ], o = true);
    },
    p(l, [a]) {
      r && r.p && (!n || a & /*$$scope*/
      128) && wo(
        r,
        s,
        l,
        /*$$scope*/
        l[7],
        n ? yo(
          s,
          /*$$scope*/
          l[7],
          a,
          Fi
        ) : bo(
          /*$$scope*/
          l[7]
        ),
        on
      );
    },
    i(l) {
      n || (B(r, l), n = true);
    },
    o(l) {
      H(r, l), n = false;
    },
    d(l) {
      l && D(t), r && r.d(l), o = false, Se(i);
    }
  };
}
function Ki(e, t, n) {
  let { $$slots: o = {}, $$scope: i } = t;
  const s = Oe();
  let { shape: r } = t, { editor: l } = t, { transform: a } = t, { svgEl: u } = t, d, f, h;
  const p = (k) => (E) => {
    if (d = k, u) {
      const { left: y, top: A } = u.getBoundingClientRect(), M = E.clientX - y, C = E.clientY - A;
      f = a.elementToImage(M, C);
    } else {
      const { offsetX: y, offsetY: A } = E;
      f = a.elementToImage(y, A);
    }
    h = r, E.target.setPointerCapture(E.pointerId), s("grab", E);
  }, m = (k) => {
    if (d) {
      const [E, S] = a.elementToImage(k.offsetX, k.offsetY), y = [E - f[0], S - f[1]];
      n(3, r = l(h, d, y)), s("change", r);
    }
  }, g = (k) => {
    k.target.releasePointerCapture(k.pointerId), d = void 0, h = r, s("release", k);
  };
  return e.$$set = (k) => {
    "shape" in k && n(3, r = k.shape), "editor" in k && n(4, l = k.editor), "transform" in k && n(5, a = k.transform), "svgEl" in k && n(6, u = k.svgEl), "$$scope" in k && n(7, i = k.$$scope);
  }, [
    p,
    m,
    g,
    r,
    l,
    a,
    u,
    i,
    o
  ];
}
var qt = class extends pe {
  constructor(t) {
    super(), me(this, t, Ki, qi, se, {
      shape: 3,
      editor: 4,
      transform: 5,
      svgEl: 6
    });
  }
};
function Wi(e) {
  let t, n, o, i, s, r, l, a, u = (
    /*selected*/
    e[3] && sn(e)
  );
  return {
    c() {
      t = P("g"), n = P("circle"), u && u.c(), i = P("circle"), c(n, "class", "a9s-handle-buffer svelte-qtyc7s"), c(
        n,
        "cx",
        /*x*/
        e[0]
      ), c(
        n,
        "cy",
        /*y*/
        e[1]
      ), c(n, "r", o = /*handleRadius*/
      e[5] + 6 / /*scale*/
      e[2]), c(n, "role", "button"), c(n, "tabindex", "0"), c(i, "class", s = ze(`a9s-handle-dot${/*selected*/
      e[3] ? " selected" : ""}`) + " svelte-qtyc7s"), c(
        i,
        "cx",
        /*x*/
        e[0]
      ), c(
        i,
        "cy",
        /*y*/
        e[1]
      ), c(
        i,
        "r",
        /*handleRadius*/
        e[5]
      ), c(t, "class", r = `a9s-handle ${/*$$props*/
      e[8].class || ""}`.trim());
    },
    m(d, f) {
      N(d, t, f), j(t, n), u && u.m(t, null), j(t, i), l || (a = [
        W(
          n,
          "dblclick",
          /*dblclick_handler_1*/
          e[12]
        ),
        W(
          n,
          "pointerenter",
          /*pointerenter_handler*/
          e[13]
        ),
        W(
          n,
          "pointerleave",
          /*pointerleave_handler*/
          e[14]
        ),
        W(
          n,
          "pointerdown",
          /*pointerdown_handler_1*/
          e[15]
        ),
        W(
          n,
          "pointerdown",
          /*onPointerDown*/
          e[6]
        ),
        W(
          n,
          "pointerup",
          /*pointerup_handler_1*/
          e[16]
        ),
        W(
          n,
          "pointerup",
          /*onPointerUp*/
          e[7]
        )
      ], l = true);
    },
    p(d, f) {
      f & /*x*/
      1 && c(
        n,
        "cx",
        /*x*/
        d[0]
      ), f & /*y*/
      2 && c(
        n,
        "cy",
        /*y*/
        d[1]
      ), f & /*handleRadius, scale*/
      36 && o !== (o = /*handleRadius*/
      d[5] + 6 / /*scale*/
      d[2]) && c(n, "r", o), /*selected*/
      d[3] ? u ? u.p(d, f) : (u = sn(d), u.c(), u.m(t, i)) : u && (u.d(1), u = null), f & /*selected*/
      8 && s !== (s = ze(`a9s-handle-dot${/*selected*/
      d[3] ? " selected" : ""}`) + " svelte-qtyc7s") && c(i, "class", s), f & /*x*/
      1 && c(
        i,
        "cx",
        /*x*/
        d[0]
      ), f & /*y*/
      2 && c(
        i,
        "cy",
        /*y*/
        d[1]
      ), f & /*handleRadius*/
      32 && c(
        i,
        "r",
        /*handleRadius*/
        d[5]
      ), f & /*$$props*/
      256 && r !== (r = `a9s-handle ${/*$$props*/
      d[8].class || ""}`.trim()) && c(t, "class", r);
    },
    d(d) {
      d && D(t), u && u.d(), l = false, Se(a);
    }
  };
}
function Zi(e) {
  let t, n, o, i, s, r, l, a, u;
  return {
    c() {
      t = P("g"), n = P("circle"), i = P("circle"), r = P("circle"), c(
        n,
        "cx",
        /*x*/
        e[0]
      ), c(
        n,
        "cy",
        /*y*/
        e[1]
      ), c(n, "r", o = /*handleRadius*/
      e[5] * 10), c(n, "class", "a9s-touch-halo"), Me(
        n,
        "touched",
        /*touched*/
        e[4]
      ), c(
        i,
        "cx",
        /*x*/
        e[0]
      ), c(
        i,
        "cy",
        /*y*/
        e[1]
      ), c(i, "r", s = /*handleRadius*/
      e[5] + 10 / /*scale*/
      e[2]), c(i, "class", "a9s-handle-buffer svelte-qtyc7s"), c(i, "role", "button"), c(i, "tabindex", "0"), c(r, "class", "a9s-handle-dot"), c(
        r,
        "cx",
        /*x*/
        e[0]
      ), c(
        r,
        "cy",
        /*y*/
        e[1]
      ), c(r, "r", l = /*handleRadius*/
      e[5] + 2 / /*scale*/
      e[2]), c(t, "class", "a9s-touch-handle");
    },
    m(d, f) {
      N(d, t, f), j(t, n), j(t, i), j(t, r), a || (u = [
        W(
          i,
          "dblclick",
          /*dblclick_handler*/
          e[9]
        ),
        W(
          i,
          "pointerdown",
          /*pointerdown_handler*/
          e[10]
        ),
        W(
          i,
          "pointerdown",
          /*onPointerDown*/
          e[6]
        ),
        W(
          i,
          "pointerup",
          /*pointerup_handler*/
          e[11]
        ),
        W(
          i,
          "pointerup",
          /*onPointerUp*/
          e[7]
        )
      ], a = true);
    },
    p(d, f) {
      f & /*x*/
      1 && c(
        n,
        "cx",
        /*x*/
        d[0]
      ), f & /*y*/
      2 && c(
        n,
        "cy",
        /*y*/
        d[1]
      ), f & /*handleRadius*/
      32 && o !== (o = /*handleRadius*/
      d[5] * 10) && c(n, "r", o), f & /*touched*/
      16 && Me(
        n,
        "touched",
        /*touched*/
        d[4]
      ), f & /*x*/
      1 && c(
        i,
        "cx",
        /*x*/
        d[0]
      ), f & /*y*/
      2 && c(
        i,
        "cy",
        /*y*/
        d[1]
      ), f & /*handleRadius, scale*/
      36 && s !== (s = /*handleRadius*/
      d[5] + 10 / /*scale*/
      d[2]) && c(i, "r", s), f & /*x*/
      1 && c(
        r,
        "cx",
        /*x*/
        d[0]
      ), f & /*y*/
      2 && c(
        r,
        "cy",
        /*y*/
        d[1]
      ), f & /*handleRadius, scale*/
      36 && l !== (l = /*handleRadius*/
      d[5] + 2 / /*scale*/
      d[2]) && c(r, "r", l);
    },
    d(d) {
      d && D(t), a = false, Se(u);
    }
  };
}
function sn(e) {
  let t, n;
  return {
    c() {
      t = P("circle"), c(t, "class", "a9s-handle-selected"), c(
        t,
        "cx",
        /*x*/
        e[0]
      ), c(
        t,
        "cy",
        /*y*/
        e[1]
      ), c(t, "r", n = /*handleRadius*/
      e[5] + 8 / /*scale*/
      e[2]);
    },
    m(o, i) {
      N(o, t, i);
    },
    p(o, i) {
      i & /*x*/
      1 && c(
        t,
        "cx",
        /*x*/
        o[0]
      ), i & /*y*/
      2 && c(
        t,
        "cy",
        /*y*/
        o[1]
      ), i & /*handleRadius, scale*/
      36 && n !== (n = /*handleRadius*/
      o[5] + 8 / /*scale*/
      o[2]) && c(t, "r", n);
    },
    d(o) {
      o && D(t);
    }
  };
}
function Ji(e) {
  let t;
  function n(s, r) {
    return Le ? Zi : Wi;
  }
  let i = n()(e);
  return {
    c() {
      i.c(), t = Ae();
    },
    m(s, r) {
      i.m(s, r), N(s, t, r);
    },
    p(s, [r]) {
      i.p(s, r);
    },
    i: ee,
    o: ee,
    d(s) {
      s && D(t), i.d(s);
    }
  };
}
function Qi(e, t, n) {
  let o, { x: i } = t, { y: s } = t, { scale: r } = t, { selected: l = void 0 } = t, a = false;
  const u = (y) => {
    y.pointerType === "touch" && n(4, a = true);
  }, d = () => n(4, a = false);
  function f(y) {
    ue.call(this, e, y);
  }
  function h(y) {
    ue.call(this, e, y);
  }
  function p(y) {
    ue.call(this, e, y);
  }
  function m(y) {
    ue.call(this, e, y);
  }
  function g(y) {
    ue.call(this, e, y);
  }
  function k(y) {
    ue.call(this, e, y);
  }
  function E(y) {
    ue.call(this, e, y);
  }
  function S(y) {
    ue.call(this, e, y);
  }
  return e.$$set = (y) => {
    n(8, t = Ut(Ut({}, t), Jt(y))), "x" in y && n(0, i = y.x), "y" in y && n(1, s = y.y), "scale" in y && n(2, r = y.scale), "selected" in y && n(3, l = y.selected);
  }, e.$$.update = () => {
    e.$$.dirty & /*scale*/
    4 && n(5, o = 4 / r);
  }, t = Jt(t), [
    i,
    s,
    r,
    l,
    a,
    o,
    u,
    d,
    t,
    f,
    h,
    p,
    m,
    g,
    k,
    E,
    S
  ];
}
var Fe = class extends pe {
  constructor(t) {
    super(), me(this, t, Qi, Ji, se, { x: 0, y: 1, scale: 2, selected: 3 });
  }
};
function xi(e) {
  let t, n, o, i, s, r, l;
  return {
    c() {
      t = P("g"), n = P("circle"), i = P("circle"), s = P("circle"), c(n, "class", "a9s-polygon-midpoint-buffer svelte-12ykj76"), c(
        n,
        "cx",
        /*x*/
        e[0]
      ), c(
        n,
        "cy",
        /*y*/
        e[1]
      ), c(n, "r", o = 1.75 * /*handleRadius*/
      e[2]), c(i, "class", "a9s-polygon-midpoint-outer svelte-12ykj76"), c(
        i,
        "cx",
        /*x*/
        e[0]
      ), c(
        i,
        "cy",
        /*y*/
        e[1]
      ), c(
        i,
        "r",
        /*handleRadius*/
        e[2]
      ), c(s, "class", "a9s-polygon-midpoint-inner svelte-12ykj76"), c(
        s,
        "cx",
        /*x*/
        e[0]
      ), c(
        s,
        "cy",
        /*y*/
        e[1]
      ), c(
        s,
        "r",
        /*handleRadius*/
        e[2]
      ), c(t, "class", "a9s-polygon-midpoint svelte-12ykj76");
    },
    m(a, u) {
      N(a, t, u), j(t, n), j(t, i), j(t, s), r || (l = [
        W(
          n,
          "pointerdown",
          /*pointerdown_handler*/
          e[5]
        ),
        W(
          n,
          "pointerdown",
          /*onPointerDown*/
          e[3]
        )
      ], r = true);
    },
    p(a, u) {
      u & /*x*/
      1 && c(
        n,
        "cx",
        /*x*/
        a[0]
      ), u & /*y*/
      2 && c(
        n,
        "cy",
        /*y*/
        a[1]
      ), u & /*handleRadius*/
      4 && o !== (o = 1.75 * /*handleRadius*/
      a[2]) && c(n, "r", o), u & /*x*/
      1 && c(
        i,
        "cx",
        /*x*/
        a[0]
      ), u & /*y*/
      2 && c(
        i,
        "cy",
        /*y*/
        a[1]
      ), u & /*handleRadius*/
      4 && c(
        i,
        "r",
        /*handleRadius*/
        a[2]
      ), u & /*x*/
      1 && c(
        s,
        "cx",
        /*x*/
        a[0]
      ), u & /*y*/
      2 && c(
        s,
        "cy",
        /*y*/
        a[1]
      ), u & /*handleRadius*/
      4 && c(
        s,
        "r",
        /*handleRadius*/
        a[2]
      );
    },
    d(a) {
      a && D(t), r = false, Se(l);
    }
  };
}
function $i(e) {
  let t;
  return {
    c() {
      t = P("circle"), c(
        t,
        "cx",
        /*x*/
        e[0]
      ), c(
        t,
        "cy",
        /*y*/
        e[1]
      ), c(
        t,
        "r",
        /*handleRadius*/
        e[2]
      );
    },
    m(n, o) {
      N(n, t, o);
    },
    p(n, o) {
      o & /*x*/
      1 && c(
        t,
        "cx",
        /*x*/
        n[0]
      ), o & /*y*/
      2 && c(
        t,
        "cy",
        /*y*/
        n[1]
      ), o & /*handleRadius*/
      4 && c(
        t,
        "r",
        /*handleRadius*/
        n[2]
      );
    },
    d(n) {
      n && D(t);
    }
  };
}
function es(e) {
  let t;
  function n(s, r) {
    return Le ? $i : xi;
  }
  let i = n()(e);
  return {
    c() {
      i.c(), t = Ae();
    },
    m(s, r) {
      i.m(s, r), N(s, t, r);
    },
    p(s, [r]) {
      i.p(s, r);
    },
    i: ee,
    o: ee,
    d(s) {
      s && D(t), i.d(s);
    }
  };
}
function ts(e, t, n) {
  let o, { x: i } = t, { y: s } = t, { scale: r } = t;
  const l = (u) => {
    u.pointerType;
  };
  function a(u) {
    ue.call(this, e, u);
  }
  return e.$$set = (u) => {
    "x" in u && n(0, i = u.x), "y" in u && n(1, s = u.y), "scale" in u && n(4, r = u.scale);
  }, e.$$.update = () => {
    e.$$.dirty & /*scale*/
    16 && n(2, o = 4 / r);
  }, [i, s, o, l, r, a];
}
var lo = class extends pe {
  constructor(t) {
    super(), me(this, t, ts, es, se, { x: 0, y: 1, scale: 4 });
  }
};
function Lt(e) {
  const t = e.slice(), n = (
    /*midpoints*/
    t[10][
      /*visibleMidpoint*/
      t[6]
    ]
  );
  return t[28] = n.point, t;
}
function rn(e, t, n) {
  const o = e.slice();
  return o[28] = t[n], o[30] = n, o;
}
function Pt(e) {
  const t = e.slice(), n = (
    /*midpoints*/
    t[10][
      /*visibleMidpoint*/
      t[6]
    ]
  );
  return t[28] = n.point, t;
}
function It(e) {
  const t = e.slice(), n = (
    /*midpoints*/
    t[10][
      /*visibleMidpoint*/
      t[6]
    ]
  );
  return t[28] = n.point, t;
}
function ln(e) {
  let t, n, o, i;
  return {
    c() {
      t = P("circle"), c(t, "cx", n = /*point*/
      e[28][0]), c(t, "cy", o = /*point*/
      e[28][1]), c(t, "r", i = $e / /*viewportScale*/
      e[3]), c(t, "class", "svelte-1h2slbm");
    },
    m(s, r) {
      N(s, t, r);
    },
    p(s, r) {
      r[0] & /*midpoints, visibleMidpoint*/
      1088 && n !== (n = /*point*/
      s[28][0]) && c(t, "cx", n), r[0] & /*midpoints, visibleMidpoint*/
      1088 && o !== (o = /*point*/
      s[28][1]) && c(t, "cy", o), r[0] & /*viewportScale*/
      8 && i !== (i = $e / /*viewportScale*/
      s[3]) && c(t, "r", i);
    },
    d(s) {
      s && D(t);
    }
  };
}
function an(e) {
  let t, n, o, i, s, r, l, a, u, d;
  return {
    c() {
      t = P("mask"), n = P("rect"), l = P("circle"), c(n, "x", o = /*mask*/
      e[9].x), c(n, "y", i = /*mask*/
      e[9].y), c(n, "width", s = /*mask*/
      e[9].w), c(n, "height", r = /*mask*/
      e[9].h), c(n, "class", "svelte-1h2slbm"), c(l, "cx", a = /*point*/
      e[28][0]), c(l, "cy", u = /*point*/
      e[28][1]), c(l, "r", d = $e / /*viewportScale*/
      e[3]), c(l, "class", "svelte-1h2slbm"), c(t, "id", `${/*maskId*/
      e[19]}-inner`), c(t, "class", "a9s-polygon-editor-mask svelte-1h2slbm");
    },
    m(f, h) {
      N(f, t, h), j(t, n), j(t, l);
    },
    p(f, h) {
      h[0] & /*mask*/
      512 && o !== (o = /*mask*/
      f[9].x) && c(n, "x", o), h[0] & /*mask*/
      512 && i !== (i = /*mask*/
      f[9].y) && c(n, "y", i), h[0] & /*mask*/
      512 && s !== (s = /*mask*/
      f[9].w) && c(n, "width", s), h[0] & /*mask*/
      512 && r !== (r = /*mask*/
      f[9].h) && c(n, "height", r), h[0] & /*midpoints, visibleMidpoint*/
      1088 && a !== (a = /*point*/
      f[28][0]) && c(l, "cx", a), h[0] & /*midpoints, visibleMidpoint*/
      1088 && u !== (u = /*point*/
      f[28][1]) && c(l, "cy", u), h[0] & /*viewportScale*/
      8 && d !== (d = $e / /*viewportScale*/
      f[3]) && c(l, "r", d);
    },
    d(f) {
      f && D(t);
    }
  };
}
function cn(e) {
  let t, n;
  return t = new Fe({
    props: {
      class: "a9s-corner-handle",
      x: (
        /*point*/
        e[28][0]
      ),
      y: (
        /*point*/
        e[28][1]
      ),
      scale: (
        /*viewportScale*/
        e[3]
      ),
      selected: (
        /*selectedCorners*/
        e[8].includes(
          /*idx*/
          e[30]
        )
      )
    }
  }), t.$on(
    "pointerenter",
    /*onEnterHandle*/
    e[11]
  ), t.$on(
    "pointerleave",
    /*onLeaveHandle*/
    e[12]
  ), t.$on(
    "pointerdown",
    /*onHandlePointerDown*/
    e[15]
  ), t.$on("pointerdown", function() {
    ie(
      /*grab*/
      e[27](`HANDLE-${/*idx*/
      e[30]}`)
    ) && e[27](`HANDLE-${/*idx*/
    e[30]}`).apply(this, arguments);
  }), t.$on(
    "pointerup",
    /*onHandlePointerUp*/
    e[16](
      /*idx*/
      e[30]
    )
  ), {
    c() {
      ae(t.$$.fragment);
    },
    m(o, i) {
      re(t, o, i), n = true;
    },
    p(o, i) {
      e = o;
      const s = {};
      i[0] & /*geom*/
      32 && (s.x = /*point*/
      e[28][0]), i[0] & /*geom*/
      32 && (s.y = /*point*/
      e[28][1]), i[0] & /*viewportScale*/
      8 && (s.scale = /*viewportScale*/
      e[3]), i[0] & /*selectedCorners*/
      256 && (s.selected = /*selectedCorners*/
      e[8].includes(
        /*idx*/
        e[30]
      )), t.$set(s);
    },
    i(o) {
      n || (B(t.$$.fragment, o), n = true);
    },
    o(o) {
      H(t.$$.fragment, o), n = false;
    },
    d(o) {
      le(t, o);
    }
  };
}
function un(e) {
  let t, n;
  return t = new lo({
    props: {
      x: (
        /*point*/
        e[28][0]
      ),
      y: (
        /*point*/
        e[28][1]
      ),
      scale: (
        /*viewportScale*/
        e[3]
      )
    }
  }), t.$on("pointerdown", function() {
    ie(
      /*onAddPoint*/
      e[18](
        /*visibleMidpoint*/
        e[6]
      )
    ) && e[18](
      /*visibleMidpoint*/
      e[6]
    ).apply(this, arguments);
  }), {
    c() {
      ae(t.$$.fragment);
    },
    m(o, i) {
      re(t, o, i), n = true;
    },
    p(o, i) {
      e = o;
      const s = {};
      i[0] & /*midpoints, visibleMidpoint*/
      1088 && (s.x = /*point*/
      e[28][0]), i[0] & /*midpoints, visibleMidpoint*/
      1088 && (s.y = /*point*/
      e[28][1]), i[0] & /*viewportScale*/
      8 && (s.scale = /*viewportScale*/
      e[3]), t.$set(s);
    },
    i(o) {
      n || (B(t.$$.fragment, o), n = true);
    },
    o(o) {
      H(t.$$.fragment, o), n = false;
    },
    d(o) {
      le(t, o);
    }
  };
}
function ns(e) {
  let t, n, o, i, s, r, l, a, u, d, f, h, p, m, g, k, E, S, y, A, M, C = (
    /*visibleMidpoint*/
    e[6] !== void 0 && !/*isHandleHovered*/
    e[7] && ln(It(e))
  ), T = (
    /*visibleMidpoint*/
    e[6] !== void 0 && !/*isHandleHovered*/
    e[7] && an(Pt(e))
  ), U = ve(
    /*geom*/
    e[5].points
  ), R = [];
  for (let w = 0; w < U.length; w += 1)
    R[w] = cn(rn(e, U, w));
  const q = (w) => H(R[w], 1, 1, () => {
    R[w] = null;
  });
  let z = (
    /*visibleMidpoint*/
    e[6] !== void 0 && !/*isHandleHovered*/
    e[7] && un(Lt(e))
  );
  return {
    c() {
      t = P("defs"), n = P("mask"), o = P("rect"), a = P("polygon"), C && C.c(), T && T.c(), d = ye(), f = P("polygon"), p = ye(), m = P("polygon"), k = ye();
      for (let w = 0; w < R.length; w += 1)
        R[w].c();
      E = ye(), z && z.c(), S = Ae(), c(o, "x", i = /*mask*/
      e[9].x), c(o, "y", s = /*mask*/
      e[9].y), c(o, "width", r = /*mask*/
      e[9].w), c(o, "height", l = /*mask*/
      e[9].h), c(o, "class", "svelte-1h2slbm"), c(a, "points", u = /*geom*/
      e[5].points.map(fn).join(" ")), c(a, "class", "svelte-1h2slbm"), c(n, "id", `${/*maskId*/
      e[19]}-outer`), c(n, "class", "a9s-polygon-editor-mask svelte-1h2slbm"), c(f, "class", "a9s-outer"), c(f, "mask", `url(#${/*maskId*/
      e[19]}-outer)`), c(f, "points", h = /*geom*/
      e[5].points.map(dn).join(" ")), c(m, "class", "a9s-inner a9s-shape-handle"), c(m, "mask", `url(#${/*maskId*/
      e[19]}-inner)`), c(
        m,
        "style",
        /*computedStyle*/
        e[1]
      ), c(m, "points", g = /*geom*/
      e[5].points.map(hn).join(" "));
    },
    m(w, v) {
      N(w, t, v), j(t, n), j(n, o), j(n, a), C && C.m(n, null), T && T.m(t, null), N(w, d, v), N(w, f, v), N(w, p, v), N(w, m, v), N(w, k, v);
      for (let _ = 0; _ < R.length; _ += 1)
        R[_] && R[_].m(w, v);
      N(w, E, v), z && z.m(w, v), N(w, S, v), y = true, A || (M = [
        W(
          f,
          "pointerup",
          /*onShapePointerUp*/
          e[14]
        ),
        W(f, "pointerdown", function() {
          ie(
            /*grab*/
            e[27]("SHAPE")
          ) && e[27]("SHAPE").apply(this, arguments);
        }),
        W(
          m,
          "pointermove",
          /*onPointerMove*/
          e[13]
        ),
        W(
          m,
          "pointerup",
          /*onShapePointerUp*/
          e[14]
        ),
        W(m, "pointerdown", function() {
          ie(
            /*grab*/
            e[27]("SHAPE")
          ) && e[27]("SHAPE").apply(this, arguments);
        })
      ], A = true);
    },
    p(w, v) {
      if (e = w, (!y || v[0] & /*mask*/
      512 && i !== (i = /*mask*/
      e[9].x)) && c(o, "x", i), (!y || v[0] & /*mask*/
      512 && s !== (s = /*mask*/
      e[9].y)) && c(o, "y", s), (!y || v[0] & /*mask*/
      512 && r !== (r = /*mask*/
      e[9].w)) && c(o, "width", r), (!y || v[0] & /*mask*/
      512 && l !== (l = /*mask*/
      e[9].h)) && c(o, "height", l), (!y || v[0] & /*geom*/
      32 && u !== (u = /*geom*/
      e[5].points.map(fn).join(" "))) && c(a, "points", u), /*visibleMidpoint*/
      e[6] !== void 0 && !/*isHandleHovered*/
      e[7] ? C ? C.p(It(e), v) : (C = ln(It(e)), C.c(), C.m(n, null)) : C && (C.d(1), C = null), /*visibleMidpoint*/
      e[6] !== void 0 && !/*isHandleHovered*/
      e[7] ? T ? T.p(Pt(e), v) : (T = an(Pt(e)), T.c(), T.m(t, null)) : T && (T.d(1), T = null), (!y || v[0] & /*geom*/
      32 && h !== (h = /*geom*/
      e[5].points.map(dn).join(" "))) && c(f, "points", h), (!y || v[0] & /*computedStyle*/
      2) && c(
        m,
        "style",
        /*computedStyle*/
        e[1]
      ), (!y || v[0] & /*geom*/
      32 && g !== (g = /*geom*/
      e[5].points.map(hn).join(" "))) && c(m, "points", g), v[0] & /*geom, viewportScale, selectedCorners, onEnterHandle, onLeaveHandle, onHandlePointerDown, grab, onHandlePointerUp*/
      134322472) {
        U = ve(
          /*geom*/
          e[5].points
        );
        let _;
        for (_ = 0; _ < U.length; _ += 1) {
          const b = rn(e, U, _);
          R[_] ? (R[_].p(b, v), B(R[_], 1)) : (R[_] = cn(b), R[_].c(), B(R[_], 1), R[_].m(E.parentNode, E));
        }
        for (we(), _ = U.length; _ < R.length; _ += 1)
          q(_);
        be();
      }
      e[6] !== void 0 && !/*isHandleHovered*/
      e[7] ? z ? (z.p(Lt(e), v), v[0] & /*visibleMidpoint, isHandleHovered*/
      192 && B(z, 1)) : (z = un(Lt(e)), z.c(), B(z, 1), z.m(S.parentNode, S)) : z && (we(), H(z, 1, 1, () => {
        z = null;
      }), be());
    },
    i(w) {
      if (!y) {
        for (let v = 0; v < U.length; v += 1)
          B(R[v]);
        B(z), y = true;
      }
    },
    o(w) {
      R = R.filter(Boolean);
      for (let v = 0; v < R.length; v += 1)
        H(R[v]);
      H(z), y = false;
    },
    d(w) {
      w && (D(t), D(d), D(f), D(p), D(m), D(k), D(E), D(S)), C && C.d(), T && T.d(), Ne(R, w), z && z.d(w), A = false, Se(M);
    }
  };
}
function os(e) {
  let t, n;
  return t = new qt({
    props: {
      shape: (
        /*shape*/
        e[0]
      ),
      transform: (
        /*transform*/
        e[2]
      ),
      editor: (
        /*editor*/
        e[17]
      ),
      svgEl: (
        /*svgEl*/
        e[4]
      ),
      $$slots: {
        default: [
          ns,
          ({ grab: o }) => ({ 27: o }),
          ({ grab: o }) => [o ? 134217728 : 0]
        ]
      },
      $$scope: { ctx: e }
    }
  }), t.$on(
    "change",
    /*change_handler*/
    e[20]
  ), t.$on(
    "grab",
    /*grab_handler*/
    e[21]
  ), t.$on(
    "release",
    /*release_handler*/
    e[22]
  ), {
    c() {
      ae(t.$$.fragment);
    },
    m(o, i) {
      re(t, o, i), n = true;
    },
    p(o, i) {
      const s = {};
      i[0] & /*shape*/
      1 && (s.shape = /*shape*/
      o[0]), i[0] & /*transform*/
      4 && (s.transform = /*transform*/
      o[2]), i[0] & /*svgEl*/
      16 && (s.svgEl = /*svgEl*/
      o[4]), i[0] & /*midpoints, visibleMidpoint, viewportScale, isHandleHovered, geom, selectedCorners, grab, computedStyle, mask*/
      134219754 | i[1] & /*$$scope*/
      1 && (s.$$scope = { dirty: i, ctx: o }), t.$set(s);
    },
    i(o) {
      n || (B(t.$$.fragment, o), n = true);
    },
    o(o) {
      H(t.$$.fragment, o), n = false;
    },
    d(o) {
      le(t, o);
    }
  };
}
var is = 250;
var ss = 1e3;
var rs = 12;
var $e = 4.5;
var fn = (e) => e.join(",");
var dn = (e) => e.join(",");
var hn = (e) => e.join(",");
function ls(e, t, n) {
  let o, i, s;
  const r = Oe();
  let { shape: l } = t, { computedStyle: a } = t, { transform: u } = t, { viewportScale: d = 1 } = t, { svgEl: f } = t, h, p = false, m, g = [];
  const k = () => n(7, p = true), E = () => n(7, p = false), S = (_) => {
    if (g.length > 0 || !i.some((K) => K.visible)) {
      n(6, h = void 0);
      return;
    }
    const [b, I] = u.elementToImage(_.offsetX, _.offsetY), L = (K) => Math.pow(K[0] - b, 2) + Math.pow(K[1] - I, 2), O = o.points.reduce((K, J) => L(J) < L(K) ? J : K), G = i.filter((K) => K.visible).reduce((K, J) => L(J.point) < L(K.point) ? J : K), X = Math.pow(ss / d, 2);
    L(O) < X || L(G.point) < X ? n(6, h = i.indexOf(G)) : n(6, h = void 0);
  }, y = () => {
    document.activeElement !== f && f.focus();
  }, A = () => {
    n(8, g = []), y();
  }, M = (_) => {
    n(7, p = true), _.preventDefault(), _.stopPropagation(), m = performance.now();
  }, C = (_) => (b) => {
    if (!m || Le || performance.now() - m > is) return;
    const I = g.includes(_);
    b.metaKey || b.ctrlKey || b.shiftKey ? I ? n(8, g = g.filter((L) => L !== _)) : n(8, g = [...g, _]) : I && g.length > 1 ? n(8, g = [_]) : I ? n(8, g = []) : n(8, g = [_]), y();
  }, T = (_, b, I) => {
    y();
    let L;
    const O = _.geometry;
    g.length > 1 ? L = O.points.map(([X, Z], K) => g.includes(K) ? [X + I[0], Z + I[1]] : [X, Z]) : b === "SHAPE" ? L = O.points.map(([X, Z]) => [X + I[0], Z + I[1]]) : L = O.points.map(([X, Z], K) => b === `HANDLE-${K}` ? [X + I[0], Z + I[1]] : [X, Z]);
    const G = ge(L);
    return { ..._, geometry: { points: L, bounds: G } };
  }, U = (_) => async (b) => {
    b.stopPropagation();
    const I = [
      ...o.points.slice(0, _ + 1),
      i[_].point,
      ...o.points.slice(_ + 1)
    ], L = ge(I);
    r("change", { ...l, geometry: { points: I, bounds: L } }), await Wn();
    const O = [...document.querySelectorAll(".a9s-handle")][_ + 1];
    if (O != null && O.firstChild) {
      const G = new PointerEvent(
        "pointerdown",
        {
          bubbles: true,
          cancelable: true,
          clientX: b.clientX,
          clientY: b.clientY,
          pointerId: b.pointerId,
          pointerType: b.pointerType,
          isPrimary: b.isPrimary,
          buttons: b.buttons
        }
      );
      O.firstChild.dispatchEvent(G);
    }
  }, R = () => {
    if (o.points.length - g.length < 3) return;
    const _ = o.points.filter((I, L) => !g.includes(L)), b = ge(_);
    r("change", { ...l, geometry: { points: _, bounds: b } }), n(8, g = []);
  };
  Re(() => {
    if (Le) return;
    const _ = (b) => {
      (b.key === "Delete" || b.key === "Backspace") && (b.preventDefault(), R());
    };
    return f.addEventListener("pointermove", S), f.addEventListener("keydown", _), () => {
      f.removeEventListener("pointermove", S), f.removeEventListener("keydown", _);
    };
  });
  const q = `polygon-mask-${Math.random().toString(36).substring(2, 12)}`;
  function z(_) {
    ue.call(this, e, _);
  }
  function w(_) {
    ue.call(this, e, _);
  }
  function v(_) {
    ue.call(this, e, _);
  }
  return e.$$set = (_) => {
    "shape" in _ && n(0, l = _.shape), "computedStyle" in _ && n(1, a = _.computedStyle), "transform" in _ && n(2, u = _.transform), "viewportScale" in _ && n(3, d = _.viewportScale), "svgEl" in _ && n(4, f = _.svgEl);
  }, e.$$.update = () => {
    e.$$.dirty[0] & /*shape*/
    1 && n(5, o = l.geometry), e.$$.dirty[0] & /*geom, viewportScale*/
    40 && n(10, i = Le ? [] : o.points.map((_, b) => {
      const I = b === o.points.length - 1 ? o.points[0] : o.points[b + 1], L = (_[0] + I[0]) / 2, O = (_[1] + I[1]) / 2, X = Math.sqrt(Math.pow(I[0] - L, 2) + Math.pow(I[1] - O, 2)) > rs / d;
      return { point: [L, O], visible: X };
    })), e.$$.dirty[0] & /*geom, viewportScale*/
    40 && n(9, s = yt(o.bounds, $e / d));
  }, [
    l,
    a,
    u,
    d,
    f,
    o,
    h,
    p,
    g,
    s,
    i,
    k,
    E,
    S,
    A,
    M,
    C,
    T,
    U,
    q,
    z,
    w,
    v
  ];
}
var as = class extends pe {
  constructor(t) {
    super(), me(
      this,
      t,
      ls,
      os,
      se,
      {
        shape: 0,
        computedStyle: 1,
        transform: 2,
        viewportScale: 3,
        svgEl: 4
      },
      null,
      [-1, -1]
    );
  }
};
function cs(e) {
  let t, n, o, i, s, r, l, a, u, d, f, h, p, m, g, k, E, S, y, A, M, C, T, U, R, q, z, w, v, _, b, I, L, O, G, X, Z, K, J, te, oe, Ee, ke, V, ce, $, fe, _e, Be, Pe, wt, Ie, Q, bt, Wt;
  return $ = new Fe({
    props: {
      class: "a9s-corner-handle-topleft",
      x: (
        /*geom*/
        e[5].x
      ),
      y: (
        /*geom*/
        e[5].y
      ),
      scale: (
        /*viewportScale*/
        e[3]
      )
    }
  }), $.$on("pointerdown", function() {
    ie(
      /*grab*/
      e[12]("TOP_LEFT")
    ) && e[12]("TOP_LEFT").apply(this, arguments);
  }), _e = new Fe({
    props: {
      class: "a9s-corner-handle-topright",
      x: (
        /*geom*/
        e[5].x + /*geom*/
        e[5].w
      ),
      y: (
        /*geom*/
        e[5].y
      ),
      scale: (
        /*viewportScale*/
        e[3]
      )
    }
  }), _e.$on("pointerdown", function() {
    ie(
      /*grab*/
      e[12]("TOP_RIGHT")
    ) && e[12]("TOP_RIGHT").apply(this, arguments);
  }), Pe = new Fe({
    props: {
      class: "a9s-corner-handle-bottomright",
      x: (
        /*geom*/
        e[5].x + /*geom*/
        e[5].w
      ),
      y: (
        /*geom*/
        e[5].y + /*geom*/
        e[5].h
      ),
      scale: (
        /*viewportScale*/
        e[3]
      )
    }
  }), Pe.$on("pointerdown", function() {
    ie(
      /*grab*/
      e[12]("BOTTOM_RIGHT")
    ) && e[12]("BOTTOM_RIGHT").apply(this, arguments);
  }), Ie = new Fe({
    props: {
      class: "a9s-corner-handle-bottomleft",
      x: (
        /*geom*/
        e[5].x
      ),
      y: (
        /*geom*/
        e[5].y + /*geom*/
        e[5].h
      ),
      scale: (
        /*viewportScale*/
        e[3]
      )
    }
  }), Ie.$on("pointerdown", function() {
    ie(
      /*grab*/
      e[12]("BOTTOM_LEFT")
    ) && e[12]("BOTTOM_LEFT").apply(this, arguments);
  }), {
    c() {
      t = P("defs"), n = P("mask"), o = P("rect"), a = P("rect"), p = ye(), m = P("rect"), y = ye(), A = P("rect"), R = ye(), q = P("rect"), _ = ye(), b = P("rect"), G = ye(), X = P("rect"), te = ye(), oe = P("rect"), ce = ye(), ae($.$$.fragment), fe = ye(), ae(_e.$$.fragment), Be = ye(), ae(Pe.$$.fragment), wt = ye(), ae(Ie.$$.fragment), c(o, "class", "rect-mask-bg svelte-1njczvj"), c(o, "x", i = /*mask*/
      e[6].x), c(o, "y", s = /*mask*/
      e[6].y), c(o, "width", r = /*mask*/
      e[6].w), c(o, "height", l = /*mask*/
      e[6].h), c(a, "class", "rect-mask-fg svelte-1njczvj"), c(a, "x", u = /*geom*/
      e[5].x), c(a, "y", d = /*geom*/
      e[5].y), c(a, "width", f = /*geom*/
      e[5].w), c(a, "height", h = /*geom*/
      e[5].h), c(
        n,
        "id",
        /*maskId*/
        e[8]
      ), c(n, "class", "a9s-rectangle-editor-mask svelte-1njczvj"), c(m, "class", "a9s-outer"), c(m, "mask", `url(#${/*maskId*/
      e[8]})`), c(m, "x", g = /*geom*/
      e[5].x), c(m, "y", k = /*geom*/
      e[5].y), c(m, "width", E = /*geom*/
      e[5].w), c(m, "height", S = /*geom*/
      e[5].h), c(A, "class", "a9s-inner a9s-shape-handle"), c(
        A,
        "style",
        /*computedStyle*/
        e[1]
      ), c(A, "x", M = /*geom*/
      e[5].x), c(A, "y", C = /*geom*/
      e[5].y), c(A, "width", T = /*geom*/
      e[5].w), c(A, "height", U = /*geom*/
      e[5].h), c(q, "class", "a9s-edge-handle a9s-edge-handle-top"), c(q, "x", z = /*geom*/
      e[5].x), c(q, "y", w = /*geom*/
      e[5].y), c(q, "height", 1), c(q, "width", v = /*geom*/
      e[5].w), c(b, "class", "a9s-edge-handle a9s-edge-handle-right"), c(b, "x", I = /*geom*/
      e[5].x + /*geom*/
      e[5].w), c(b, "y", L = /*geom*/
      e[5].y), c(b, "height", O = /*geom*/
      e[5].h), c(b, "width", 1), c(X, "class", "a9s-edge-handle a9s-edge-handle-bottom"), c(X, "x", Z = /*geom*/
      e[5].x), c(X, "y", K = /*geom*/
      e[5].y + /*geom*/
      e[5].h), c(X, "height", 1), c(X, "width", J = /*geom*/
      e[5].w), c(oe, "class", "a9s-edge-handle a9s-edge-handle-left"), c(oe, "x", Ee = /*geom*/
      e[5].x), c(oe, "y", ke = /*geom*/
      e[5].y), c(oe, "height", V = /*geom*/
      e[5].h), c(oe, "width", 1);
    },
    m(F, Y) {
      N(F, t, Y), j(t, n), j(n, o), j(n, a), N(F, p, Y), N(F, m, Y), N(F, y, Y), N(F, A, Y), N(F, R, Y), N(F, q, Y), N(F, _, Y), N(F, b, Y), N(F, G, Y), N(F, X, Y), N(F, te, Y), N(F, oe, Y), N(F, ce, Y), re($, F, Y), N(F, fe, Y), re(_e, F, Y), N(F, Be, Y), re(Pe, F, Y), N(F, wt, Y), re(Ie, F, Y), Q = true, bt || (Wt = [
        W(m, "pointerdown", function() {
          ie(
            /*grab*/
            e[12]("SHAPE")
          ) && e[12]("SHAPE").apply(this, arguments);
        }),
        W(A, "pointerdown", function() {
          ie(
            /*grab*/
            e[12]("SHAPE")
          ) && e[12]("SHAPE").apply(this, arguments);
        }),
        W(q, "pointerdown", function() {
          ie(
            /*grab*/
            e[12]("TOP")
          ) && e[12]("TOP").apply(this, arguments);
        }),
        W(b, "pointerdown", function() {
          ie(
            /*grab*/
            e[12]("RIGHT")
          ) && e[12]("RIGHT").apply(this, arguments);
        }),
        W(X, "pointerdown", function() {
          ie(
            /*grab*/
            e[12]("BOTTOM")
          ) && e[12]("BOTTOM").apply(this, arguments);
        }),
        W(oe, "pointerdown", function() {
          ie(
            /*grab*/
            e[12]("LEFT")
          ) && e[12]("LEFT").apply(this, arguments);
        })
      ], bt = true);
    },
    p(F, Y) {
      e = F, (!Q || Y & /*mask*/
      64 && i !== (i = /*mask*/
      e[6].x)) && c(o, "x", i), (!Q || Y & /*mask*/
      64 && s !== (s = /*mask*/
      e[6].y)) && c(o, "y", s), (!Q || Y & /*mask*/
      64 && r !== (r = /*mask*/
      e[6].w)) && c(o, "width", r), (!Q || Y & /*mask*/
      64 && l !== (l = /*mask*/
      e[6].h)) && c(o, "height", l), (!Q || Y & /*geom*/
      32 && u !== (u = /*geom*/
      e[5].x)) && c(a, "x", u), (!Q || Y & /*geom*/
      32 && d !== (d = /*geom*/
      e[5].y)) && c(a, "y", d), (!Q || Y & /*geom*/
      32 && f !== (f = /*geom*/
      e[5].w)) && c(a, "width", f), (!Q || Y & /*geom*/
      32 && h !== (h = /*geom*/
      e[5].h)) && c(a, "height", h), (!Q || Y & /*geom*/
      32 && g !== (g = /*geom*/
      e[5].x)) && c(m, "x", g), (!Q || Y & /*geom*/
      32 && k !== (k = /*geom*/
      e[5].y)) && c(m, "y", k), (!Q || Y & /*geom*/
      32 && E !== (E = /*geom*/
      e[5].w)) && c(m, "width", E), (!Q || Y & /*geom*/
      32 && S !== (S = /*geom*/
      e[5].h)) && c(m, "height", S), (!Q || Y & /*computedStyle*/
      2) && c(
        A,
        "style",
        /*computedStyle*/
        e[1]
      ), (!Q || Y & /*geom*/
      32 && M !== (M = /*geom*/
      e[5].x)) && c(A, "x", M), (!Q || Y & /*geom*/
      32 && C !== (C = /*geom*/
      e[5].y)) && c(A, "y", C), (!Q || Y & /*geom*/
      32 && T !== (T = /*geom*/
      e[5].w)) && c(A, "width", T), (!Q || Y & /*geom*/
      32 && U !== (U = /*geom*/
      e[5].h)) && c(A, "height", U), (!Q || Y & /*geom*/
      32 && z !== (z = /*geom*/
      e[5].x)) && c(q, "x", z), (!Q || Y & /*geom*/
      32 && w !== (w = /*geom*/
      e[5].y)) && c(q, "y", w), (!Q || Y & /*geom*/
      32 && v !== (v = /*geom*/
      e[5].w)) && c(q, "width", v), (!Q || Y & /*geom*/
      32 && I !== (I = /*geom*/
      e[5].x + /*geom*/
      e[5].w)) && c(b, "x", I), (!Q || Y & /*geom*/
      32 && L !== (L = /*geom*/
      e[5].y)) && c(b, "y", L), (!Q || Y & /*geom*/
      32 && O !== (O = /*geom*/
      e[5].h)) && c(b, "height", O), (!Q || Y & /*geom*/
      32 && Z !== (Z = /*geom*/
      e[5].x)) && c(X, "x", Z), (!Q || Y & /*geom*/
      32 && K !== (K = /*geom*/
      e[5].y + /*geom*/
      e[5].h)) && c(X, "y", K), (!Q || Y & /*geom*/
      32 && J !== (J = /*geom*/
      e[5].w)) && c(X, "width", J), (!Q || Y & /*geom*/
      32 && Ee !== (Ee = /*geom*/
      e[5].x)) && c(oe, "x", Ee), (!Q || Y & /*geom*/
      32 && ke !== (ke = /*geom*/
      e[5].y)) && c(oe, "y", ke), (!Q || Y & /*geom*/
      32 && V !== (V = /*geom*/
      e[5].h)) && c(oe, "height", V);
      const tt = {};
      Y & /*geom*/
      32 && (tt.x = /*geom*/
      e[5].x), Y & /*geom*/
      32 && (tt.y = /*geom*/
      e[5].y), Y & /*viewportScale*/
      8 && (tt.scale = /*viewportScale*/
      e[3]), $.$set(tt);
      const nt = {};
      Y & /*geom*/
      32 && (nt.x = /*geom*/
      e[5].x + /*geom*/
      e[5].w), Y & /*geom*/
      32 && (nt.y = /*geom*/
      e[5].y), Y & /*viewportScale*/
      8 && (nt.scale = /*viewportScale*/
      e[3]), _e.$set(nt);
      const ot = {};
      Y & /*geom*/
      32 && (ot.x = /*geom*/
      e[5].x + /*geom*/
      e[5].w), Y & /*geom*/
      32 && (ot.y = /*geom*/
      e[5].y + /*geom*/
      e[5].h), Y & /*viewportScale*/
      8 && (ot.scale = /*viewportScale*/
      e[3]), Pe.$set(ot);
      const it = {};
      Y & /*geom*/
      32 && (it.x = /*geom*/
      e[5].x), Y & /*geom*/
      32 && (it.y = /*geom*/
      e[5].y + /*geom*/
      e[5].h), Y & /*viewportScale*/
      8 && (it.scale = /*viewportScale*/
      e[3]), Ie.$set(it);
    },
    i(F) {
      Q || (B($.$$.fragment, F), B(_e.$$.fragment, F), B(Pe.$$.fragment, F), B(Ie.$$.fragment, F), Q = true);
    },
    o(F) {
      H($.$$.fragment, F), H(_e.$$.fragment, F), H(Pe.$$.fragment, F), H(Ie.$$.fragment, F), Q = false;
    },
    d(F) {
      F && (D(t), D(p), D(m), D(y), D(A), D(R), D(q), D(_), D(b), D(G), D(X), D(te), D(oe), D(ce), D(fe), D(Be), D(wt)), le($, F), le(_e, F), le(Pe, F), le(Ie, F), bt = false, Se(Wt);
    }
  };
}
function us(e) {
  let t, n;
  return t = new qt({
    props: {
      shape: (
        /*shape*/
        e[0]
      ),
      transform: (
        /*transform*/
        e[2]
      ),
      editor: (
        /*editor*/
        e[7]
      ),
      svgEl: (
        /*svgEl*/
        e[4]
      ),
      $$slots: {
        default: [
          cs,
          ({ grab: o }) => ({ 12: o }),
          ({ grab: o }) => o ? 4096 : 0
        ]
      },
      $$scope: { ctx: e }
    }
  }), t.$on(
    "grab",
    /*grab_handler*/
    e[9]
  ), t.$on(
    "change",
    /*change_handler*/
    e[10]
  ), t.$on(
    "release",
    /*release_handler*/
    e[11]
  ), {
    c() {
      ae(t.$$.fragment);
    },
    m(o, i) {
      re(t, o, i), n = true;
    },
    p(o, [i]) {
      const s = {};
      i & /*shape*/
      1 && (s.shape = /*shape*/
      o[0]), i & /*transform*/
      4 && (s.transform = /*transform*/
      o[2]), i & /*svgEl*/
      16 && (s.svgEl = /*svgEl*/
      o[4]), i & /*$$scope, geom, viewportScale, grab, computedStyle, mask*/
      12394 && (s.$$scope = { dirty: i, ctx: o }), t.$set(s);
    },
    i(o) {
      n || (B(t.$$.fragment, o), n = true);
    },
    o(o) {
      H(t.$$.fragment, o), n = false;
    },
    d(o) {
      le(t, o);
    }
  };
}
function fs(e, t, n) {
  let o, i, { shape: s } = t, { computedStyle: r } = t, { transform: l } = t, { viewportScale: a = 1 } = t, { svgEl: u } = t;
  const d = (g, k, E) => {
    const S = g.geometry.bounds;
    let [y, A] = [S.minX, S.minY], [M, C] = [S.maxX, S.maxY];
    const [T, U] = E;
    if (k === "SHAPE")
      y += T, M += T, A += U, C += U;
    else {
      switch (k) {
        case "TOP":
        case "TOP_LEFT":
        case "TOP_RIGHT": {
          A += U;
          break;
        }
        case "BOTTOM":
        case "BOTTOM_LEFT":
        case "BOTTOM_RIGHT": {
          C += U;
          break;
        }
      }
      switch (k) {
        case "LEFT":
        case "TOP_LEFT":
        case "BOTTOM_LEFT": {
          y += T;
          break;
        }
        case "RIGHT":
        case "TOP_RIGHT":
        case "BOTTOM_RIGHT": {
          M += T;
          break;
        }
      }
    }
    const R = Math.min(y, M), q = Math.min(A, C), z = Math.abs(M - y), w = Math.abs(C - A);
    return {
      ...g,
      geometry: {
        x: R,
        y: q,
        w: z,
        h: w,
        bounds: {
          minX: R,
          minY: q,
          maxX: R + z,
          maxY: q + w
        }
      }
    };
  }, f = `rect-mask-${Math.random().toString(36).substring(2, 12)}`;
  function h(g) {
    ue.call(this, e, g);
  }
  function p(g) {
    ue.call(this, e, g);
  }
  function m(g) {
    ue.call(this, e, g);
  }
  return e.$$set = (g) => {
    "shape" in g && n(0, s = g.shape), "computedStyle" in g && n(1, r = g.computedStyle), "transform" in g && n(2, l = g.transform), "viewportScale" in g && n(3, a = g.viewportScale), "svgEl" in g && n(4, u = g.svgEl);
  }, e.$$.update = () => {
    e.$$.dirty & /*shape*/
    1 && n(5, o = s.geometry), e.$$.dirty & /*geom, viewportScale*/
    40 && n(6, i = yt(o.bounds, 2 / a));
  }, [
    s,
    r,
    l,
    a,
    u,
    o,
    i,
    d,
    f,
    h,
    p,
    m
  ];
}
var ds = class extends pe {
  constructor(t) {
    super(), me(this, t, fs, us, se, {
      shape: 0,
      computedStyle: 1,
      transform: 2,
      viewportScale: 3,
      svgEl: 4
    });
  }
};
var gn = Object.prototype.hasOwnProperty;
function jt(e, t) {
  var n, o;
  if (e === t) return true;
  if (e && t && (n = e.constructor) === t.constructor) {
    if (n === Date) return e.getTime() === t.getTime();
    if (n === RegExp) return e.toString() === t.toString();
    if (n === Array) {
      if ((o = e.length) === t.length)
        for (; o-- && jt(e[o], t[o]); ) ;
      return o === -1;
    }
    if (!n || typeof e == "object") {
      o = 0;
      for (n in e)
        if (gn.call(e, n) && ++o && !gn.call(t, n) || !(n in t) || !jt(e[n], t[n])) return false;
      return Object.keys(t).length === o;
    }
  }
  return e !== e && t !== t;
}
var hs = 12;
var gs = (e, t) => e.polygons.reduce((n, o, i) => {
  const s = o.rings.reduce((r, l, a) => {
    const u = l.points.map((d, f) => {
      const h = f === l.points.length - 1 ? l.points[0] : l.points[f + 1], p = (d[0] + h[0]) / 2, m = (d[1] + h[1]) / 2, k = Math.sqrt(
        Math.pow(h[0] - p, 2) + Math.pow(h[1] - m, 2)
      ) > hs / t;
      return { point: [p, m], visible: k, elementIdx: i, ringIdx: a, pointIdx: f };
    });
    return [...r, ...u];
  }, []);
  return [...n, ...s];
}, []);
function Ct(e) {
  const t = e.slice(), n = (
    /*midpoints*/
    t[10][
      /*visibleMidpoint*/
      t[6]
    ]
  );
  return t[29] = n.point, t;
}
function mn(e, t, n) {
  const o = e.slice();
  return o[30] = t[n], o[32] = n, o;
}
function pn(e, t, n) {
  const o = e.slice();
  return o[33] = t[n], o[35] = n, o;
}
function _n(e, t, n) {
  const o = e.slice();
  return o[29] = t[n], o[37] = n, o;
}
function Ot(e) {
  const t = e.slice(), n = (
    /*midpoints*/
    t[10][
      /*visibleMidpoint*/
      t[6]
    ]
  );
  return t[29] = n.point, t;
}
function Dt(e) {
  const t = e.slice(), n = (
    /*midpoints*/
    t[10][
      /*visibleMidpoint*/
      t[6]
    ]
  );
  return t[29] = n.point, t;
}
function yn(e) {
  let t, n, o, i;
  return {
    c() {
      t = P("circle"), c(t, "cx", n = /*point*/
      e[29][0]), c(t, "cy", o = /*point*/
      e[29][1]), c(t, "r", i = et / /*viewportScale*/
      e[3]), c(t, "class", "svelte-1vxo6dc");
    },
    m(s, r) {
      N(s, t, r);
    },
    p(s, r) {
      r[0] & /*midpoints, visibleMidpoint*/
      1088 && n !== (n = /*point*/
      s[29][0]) && c(t, "cx", n), r[0] & /*midpoints, visibleMidpoint*/
      1088 && o !== (o = /*point*/
      s[29][1]) && c(t, "cy", o), r[0] & /*viewportScale*/
      8 && i !== (i = et / /*viewportScale*/
      s[3]) && c(t, "r", i);
    },
    d(s) {
      s && D(t);
    }
  };
}
function wn(e) {
  let t, n, o, i, s, r, l, a, u, d;
  return {
    c() {
      t = P("mask"), n = P("rect"), l = P("circle"), c(n, "x", o = /*mask*/
      e[9].x), c(n, "y", i = /*mask*/
      e[9].y), c(n, "width", s = /*mask*/
      e[9].w), c(n, "height", r = /*mask*/
      e[9].h), c(n, "class", "svelte-1vxo6dc"), c(l, "cx", a = /*point*/
      e[29][0]), c(l, "cy", u = /*point*/
      e[29][1]), c(l, "r", d = et / /*viewportScale*/
      e[3]), c(l, "class", "svelte-1vxo6dc"), c(t, "id", `${/*maskId*/
      e[18]}-${/*elementIdx*/
      e[32]}-inner`), c(t, "class", "a9s-multipolygon-editor-mask svelte-1vxo6dc");
    },
    m(f, h) {
      N(f, t, h), j(t, n), j(t, l);
    },
    p(f, h) {
      h[0] & /*mask*/
      512 && o !== (o = /*mask*/
      f[9].x) && c(n, "x", o), h[0] & /*mask*/
      512 && i !== (i = /*mask*/
      f[9].y) && c(n, "y", i), h[0] & /*mask*/
      512 && s !== (s = /*mask*/
      f[9].w) && c(n, "width", s), h[0] & /*mask*/
      512 && r !== (r = /*mask*/
      f[9].h) && c(n, "height", r), h[0] & /*midpoints, visibleMidpoint*/
      1088 && a !== (a = /*point*/
      f[29][0]) && c(l, "cx", a), h[0] & /*midpoints, visibleMidpoint*/
      1088 && u !== (u = /*point*/
      f[29][1]) && c(l, "cy", u), h[0] & /*viewportScale*/
      8 && d !== (d = et / /*viewportScale*/
      f[3]) && c(l, "r", d);
    },
    d(f) {
      f && D(t);
    }
  };
}
function bn(e) {
  let t, n;
  function o(...i) {
    return (
      /*func*/
      e[19](
        /*elementIdx*/
        e[32],
        /*ringIdx*/
        e[35],
        /*pointIdx*/
        e[37],
        ...i
      )
    );
  }
  return t = new Fe({
    props: {
      class: "a9s-corner-handle",
      x: (
        /*point*/
        e[29][0]
      ),
      y: (
        /*point*/
        e[29][1]
      ),
      scale: (
        /*viewportScale*/
        e[3]
      ),
      selected: (
        /*selectedCorners*/
        e[8].some(o)
      )
    }
  }), t.$on(
    "pointerenter",
    /*onEnterHandle*/
    e[11]
  ), t.$on(
    "pointerleave",
    /*onLeaveHandle*/
    e[12]
  ), t.$on(
    "pointerdown",
    /*onHandlePointerDown*/
    e[14]
  ), t.$on("pointerdown", function() {
    ie(
      /*grab*/
      e[28](`HANDLE-${/*elementIdx*/
      e[32]}-${/*ringIdx*/
      e[35]}-${/*pointIdx*/
      e[37]}`)
    ) && e[28](`HANDLE-${/*elementIdx*/
    e[32]}-${/*ringIdx*/
    e[35]}-${/*pointIdx*/
    e[37]}`).apply(this, arguments);
  }), t.$on(
    "pointerup",
    /*onHandlePointerUp*/
    e[15](
      /*elementIdx*/
      e[32],
      /*ringIdx*/
      e[35],
      /*pointIdx*/
      e[37]
    )
  ), {
    c() {
      ae(t.$$.fragment);
    },
    m(i, s) {
      re(t, i, s), n = true;
    },
    p(i, s) {
      e = i;
      const r = {};
      s[0] & /*geom*/
      32 && (r.x = /*point*/
      e[29][0]), s[0] & /*geom*/
      32 && (r.y = /*point*/
      e[29][1]), s[0] & /*viewportScale*/
      8 && (r.scale = /*viewportScale*/
      e[3]), s[0] & /*selectedCorners*/
      256 && (r.selected = /*selectedCorners*/
      e[8].some(o)), t.$set(r);
    },
    i(i) {
      n || (B(t.$$.fragment, i), n = true);
    },
    o(i) {
      H(t.$$.fragment, i), n = false;
    },
    d(i) {
      le(t, i);
    }
  };
}
function En(e) {
  let t, n, o = ve(
    /*ring*/
    e[33].points
  ), i = [];
  for (let r = 0; r < o.length; r += 1)
    i[r] = bn(_n(e, o, r));
  const s = (r) => H(i[r], 1, 1, () => {
    i[r] = null;
  });
  return {
    c() {
      for (let r = 0; r < i.length; r += 1)
        i[r].c();
      t = Ae();
    },
    m(r, l) {
      for (let a = 0; a < i.length; a += 1)
        i[a] && i[a].m(r, l);
      N(r, t, l), n = true;
    },
    p(r, l) {
      if (l[0] & /*geom, viewportScale, selectedCorners, onEnterHandle, onLeaveHandle, onHandlePointerDown, grab, onHandlePointerUp*/
      268491048) {
        o = ve(
          /*ring*/
          r[33].points
        );
        let a;
        for (a = 0; a < o.length; a += 1) {
          const u = _n(r, o, a);
          i[a] ? (i[a].p(u, l), B(i[a], 1)) : (i[a] = bn(u), i[a].c(), B(i[a], 1), i[a].m(t.parentNode, t));
        }
        for (we(), a = o.length; a < i.length; a += 1)
          s(a);
        be();
      }
    },
    i(r) {
      if (!n) {
        for (let l = 0; l < o.length; l += 1)
          B(i[l]);
        n = true;
      }
    },
    o(r) {
      i = i.filter(Boolean);
      for (let l = 0; l < i.length; l += 1)
        H(i[l]);
      n = false;
    },
    d(r) {
      r && D(t), Ne(i, r);
    }
  };
}
function vn(e) {
  let t, n, o, i, s, r, l, a, u, d, f, h, p, m, g, k, E, S = (
    /*visibleMidpoint*/
    e[6] !== void 0 && !/*isHandleHovered*/
    e[7] && yn(Dt(e))
  ), y = (
    /*visibleMidpoint*/
    e[6] !== void 0 && !/*isHandleHovered*/
    e[7] && wn(Ot(e))
  ), A = ve(
    /*element*/
    e[30].rings
  ), M = [];
  for (let T = 0; T < A.length; T += 1)
    M[T] = En(pn(e, A, T));
  const C = (T) => H(M[T], 1, 1, () => {
    M[T] = null;
  });
  return {
    c() {
      t = P("g"), n = P("defs"), o = P("mask"), i = P("rect"), u = P("path"), S && S.c(), y && y.c(), f = P("path"), p = P("path");
      for (let T = 0; T < M.length; T += 1)
        M[T].c();
      c(i, "x", s = /*mask*/
      e[9].x), c(i, "y", r = /*mask*/
      e[9].y), c(i, "width", l = /*mask*/
      e[9].w), c(i, "height", a = /*mask*/
      e[9].h), c(i, "class", "svelte-1vxo6dc"), c(u, "d", d = Te(
        /*element*/
        e[30]
      )), c(u, "class", "svelte-1vxo6dc"), c(o, "id", `${/*maskId*/
      e[18]}-${/*elementIdx*/
      e[32]}-outer`), c(o, "class", "a9s-multipolygon-editor-mask svelte-1vxo6dc"), c(f, "class", "a9s-outer"), c(f, "mask", `url(#${/*maskId*/
      e[18]}-${/*elementIdx*/
      e[32]}-outer)`), c(f, "fill-rule", "evenodd"), c(f, "d", h = Te(
        /*element*/
        e[30]
      )), c(p, "class", "a9s-inner"), c(p, "mask", `url(#${/*maskId*/
      e[18]}-${/*elementIdx*/
      e[32]}-inner)`), c(
        p,
        "style",
        /*computedStyle*/
        e[1]
      ), c(p, "fill-rule", "evenodd"), c(p, "d", m = Te(
        /*element*/
        e[30]
      ));
    },
    m(T, U) {
      N(T, t, U), j(t, n), j(n, o), j(o, i), j(o, u), S && S.m(o, null), y && y.m(n, null), j(t, f), j(t, p);
      for (let R = 0; R < M.length; R += 1)
        M[R] && M[R].m(t, null);
      g = true, k || (E = [
        W(
          f,
          "pointerup",
          /*onShapePointerUp*/
          e[13]
        ),
        W(f, "pointerdown", function() {
          ie(
            /*grab*/
            e[28]("SHAPE")
          ) && e[28]("SHAPE").apply(this, arguments);
        }),
        W(
          p,
          "pointerup",
          /*onShapePointerUp*/
          e[13]
        ),
        W(p, "pointerdown", function() {
          ie(
            /*grab*/
            e[28]("SHAPE")
          ) && e[28]("SHAPE").apply(this, arguments);
        })
      ], k = true);
    },
    p(T, U) {
      if (e = T, (!g || U[0] & /*mask*/
      512 && s !== (s = /*mask*/
      e[9].x)) && c(i, "x", s), (!g || U[0] & /*mask*/
      512 && r !== (r = /*mask*/
      e[9].y)) && c(i, "y", r), (!g || U[0] & /*mask*/
      512 && l !== (l = /*mask*/
      e[9].w)) && c(i, "width", l), (!g || U[0] & /*mask*/
      512 && a !== (a = /*mask*/
      e[9].h)) && c(i, "height", a), (!g || U[0] & /*geom*/
      32 && d !== (d = Te(
        /*element*/
        e[30]
      ))) && c(u, "d", d), /*visibleMidpoint*/
      e[6] !== void 0 && !/*isHandleHovered*/
      e[7] ? S ? S.p(Dt(e), U) : (S = yn(Dt(e)), S.c(), S.m(o, null)) : S && (S.d(1), S = null), /*visibleMidpoint*/
      e[6] !== void 0 && !/*isHandleHovered*/
      e[7] ? y ? y.p(Ot(e), U) : (y = wn(Ot(e)), y.c(), y.m(n, null)) : y && (y.d(1), y = null), (!g || U[0] & /*geom*/
      32 && h !== (h = Te(
        /*element*/
        e[30]
      ))) && c(f, "d", h), (!g || U[0] & /*computedStyle*/
      2) && c(
        p,
        "style",
        /*computedStyle*/
        e[1]
      ), (!g || U[0] & /*geom*/
      32 && m !== (m = Te(
        /*element*/
        e[30]
      ))) && c(p, "d", m), U[0] & /*geom, viewportScale, selectedCorners, onEnterHandle, onLeaveHandle, onHandlePointerDown, grab, onHandlePointerUp*/
      268491048) {
        A = ve(
          /*element*/
          e[30].rings
        );
        let R;
        for (R = 0; R < A.length; R += 1) {
          const q = pn(e, A, R);
          M[R] ? (M[R].p(q, U), B(M[R], 1)) : (M[R] = En(q), M[R].c(), B(M[R], 1), M[R].m(t, null));
        }
        for (we(), R = A.length; R < M.length; R += 1)
          C(R);
        be();
      }
    },
    i(T) {
      if (!g) {
        for (let U = 0; U < A.length; U += 1)
          B(M[U]);
        g = true;
      }
    },
    o(T) {
      M = M.filter(Boolean);
      for (let U = 0; U < M.length; U += 1)
        H(M[U]);
      g = false;
    },
    d(T) {
      T && D(t), S && S.d(), y && y.d(), Ne(M, T), k = false, Se(E);
    }
  };
}
function Sn(e) {
  let t, n;
  return t = new lo({
    props: {
      x: (
        /*point*/
        e[29][0]
      ),
      y: (
        /*point*/
        e[29][1]
      ),
      scale: (
        /*viewportScale*/
        e[3]
      )
    }
  }), t.$on("pointerdown", function() {
    ie(
      /*onAddPoint*/
      e[17](
        /*visibleMidpoint*/
        e[6]
      )
    ) && e[17](
      /*visibleMidpoint*/
      e[6]
    ).apply(this, arguments);
  }), {
    c() {
      ae(t.$$.fragment);
    },
    m(o, i) {
      re(t, o, i), n = true;
    },
    p(o, i) {
      e = o;
      const s = {};
      i[0] & /*midpoints, visibleMidpoint*/
      1088 && (s.x = /*point*/
      e[29][0]), i[0] & /*midpoints, visibleMidpoint*/
      1088 && (s.y = /*point*/
      e[29][1]), i[0] & /*viewportScale*/
      8 && (s.scale = /*viewportScale*/
      e[3]), t.$set(s);
    },
    i(o) {
      n || (B(t.$$.fragment, o), n = true);
    },
    o(o) {
      H(t.$$.fragment, o), n = false;
    },
    d(o) {
      le(t, o);
    }
  };
}
function ms(e) {
  let t, n, o, i = ve(
    /*geom*/
    e[5].polygons
  ), s = [];
  for (let a = 0; a < i.length; a += 1)
    s[a] = vn(mn(e, i, a));
  const r = (a) => H(s[a], 1, 1, () => {
    s[a] = null;
  });
  let l = (
    /*visibleMidpoint*/
    e[6] !== void 0 && !/*isHandleHovered*/
    e[7] && Sn(Ct(e))
  );
  return {
    c() {
      for (let a = 0; a < s.length; a += 1)
        s[a].c();
      t = ye(), l && l.c(), n = Ae();
    },
    m(a, u) {
      for (let d = 0; d < s.length; d += 1)
        s[d] && s[d].m(a, u);
      N(a, t, u), l && l.m(a, u), N(a, n, u), o = true;
    },
    p(a, u) {
      if (u[0] & /*geom, viewportScale, selectedCorners, onEnterHandle, onLeaveHandle, onHandlePointerDown, grab, onHandlePointerUp, maskId, computedStyle, onShapePointerUp, midpoints, visibleMidpoint, mask, isHandleHovered*/
      268763114) {
        i = ve(
          /*geom*/
          a[5].polygons
        );
        let d;
        for (d = 0; d < i.length; d += 1) {
          const f = mn(a, i, d);
          s[d] ? (s[d].p(f, u), B(s[d], 1)) : (s[d] = vn(f), s[d].c(), B(s[d], 1), s[d].m(t.parentNode, t));
        }
        for (we(), d = i.length; d < s.length; d += 1)
          r(d);
        be();
      }
      a[6] !== void 0 && !/*isHandleHovered*/
      a[7] ? l ? (l.p(Ct(a), u), u[0] & /*visibleMidpoint, isHandleHovered*/
      192 && B(l, 1)) : (l = Sn(Ct(a)), l.c(), B(l, 1), l.m(n.parentNode, n)) : l && (we(), H(l, 1, 1, () => {
        l = null;
      }), be());
    },
    i(a) {
      if (!o) {
        for (let u = 0; u < i.length; u += 1)
          B(s[u]);
        B(l), o = true;
      }
    },
    o(a) {
      s = s.filter(Boolean);
      for (let u = 0; u < s.length; u += 1)
        H(s[u]);
      H(l), o = false;
    },
    d(a) {
      a && (D(t), D(n)), Ne(s, a), l && l.d(a);
    }
  };
}
function ps(e) {
  let t, n;
  return t = new qt({
    props: {
      shape: (
        /*shape*/
        e[0]
      ),
      transform: (
        /*transform*/
        e[2]
      ),
      editor: (
        /*editor*/
        e[16]
      ),
      svgEl: (
        /*svgEl*/
        e[4]
      ),
      $$slots: {
        default: [
          ms,
          ({ grab: o }) => ({ 28: o }),
          ({ grab: o }) => [o ? 268435456 : 0]
        ]
      },
      $$scope: { ctx: e }
    }
  }), t.$on(
    "change",
    /*change_handler*/
    e[20]
  ), t.$on(
    "grab",
    /*grab_handler*/
    e[21]
  ), t.$on(
    "release",
    /*release_handler*/
    e[22]
  ), {
    c() {
      ae(t.$$.fragment);
    },
    m(o, i) {
      re(t, o, i), n = true;
    },
    p(o, i) {
      const s = {};
      i[0] & /*shape*/
      1 && (s.shape = /*shape*/
      o[0]), i[0] & /*transform*/
      4 && (s.transform = /*transform*/
      o[2]), i[0] & /*svgEl*/
      16 && (s.svgEl = /*svgEl*/
      o[4]), i[0] & /*midpoints, visibleMidpoint, viewportScale, isHandleHovered, geom, selectedCorners, grab, computedStyle, mask*/
      268437482 | i[1] & /*$$scope*/
      128 && (s.$$scope = { dirty: i, ctx: o }), t.$set(s);
    },
    i(o) {
      n || (B(t.$$.fragment, o), n = true);
    },
    o(o) {
      H(t.$$.fragment, o), n = false;
    },
    d(o) {
      le(t, o);
    }
  };
}
var _s = 250;
var ys = 1e3;
var et = 4.5;
function ws(e, t, n) {
  let o, i, s;
  const r = Oe();
  let { shape: l } = t, { computedStyle: a } = t, { transform: u } = t, { viewportScale: d = 1 } = t, { svgEl: f } = t, h, p = false, m, g = [];
  const k = () => n(7, p = true), E = () => n(7, p = false), S = (b) => {
    if (g.length > 0 || !i.some((J) => J.visible)) {
      n(6, h = void 0);
      return;
    }
    const [I, L] = u.elementToImage(b.offsetX, b.offsetY), O = (J) => Math.pow(J[0] - I, 2) + Math.pow(J[1] - L, 2), G = Ro(o).reduce((J, te) => O(te) < O(J) ? te : J), X = i.filter((J) => J.visible).reduce((J, te) => O(te.point) < O(J.point) ? te : J), Z = Math.pow(ys / d, 2);
    O(G) < Z || O(X.point) < Z ? n(6, h = i.indexOf(X)) : n(6, h = void 0);
  }, y = () => {
    document.activeElement !== f && f.focus();
  }, A = () => {
    n(8, g = []), y();
  }, M = (b) => {
    n(7, p = true), b.preventDefault(), b.stopPropagation(), m = performance.now();
  }, C = (b, I, L) => (O) => {
    if (!m || Le || performance.now() - m > _s) return;
    const G = (Z) => Z.polygon === b && Z.ring === I && Z.point === L, X = g.some(G);
    O.metaKey || O.ctrlKey || O.shiftKey ? X ? n(8, g = g.filter((Z) => !G(Z))) : n(8, g = [...g, { polygon: b, ring: I, point: L }]) : X && g.length > 1 ? n(8, g = [{ polygon: b, ring: I, point: L }]) : X ? n(8, g = []) : n(8, g = [{ polygon: b, ring: I, point: L }]), y();
  }, T = (b, I, L) => {
    y();
    const O = b.geometry.polygons;
    let G;
    if (I === "SHAPE")
      G = O.map((X) => {
        const Z = X.rings.map((J, te) => ({ points: J.points.map((Ee, ke) => [Ee[0] + L[0], Ee[1] + L[1]]) })), K = ge(Z[0].points);
        return { rings: Z, bounds: K };
      });
    else {
      const [X, Z, K, J] = I.split("-").map((te) => parseInt(te));
      G = O.map((te, oe) => {
        if (oe === Z) {
          const Ee = te.rings.map((V, ce) => ce === K ? { points: V.points.map((fe, _e) => _e === J ? [fe[0] + L[0], fe[1] + L[1]] : fe) } : V), ke = ge(Ee[0].points);
          return { rings: Ee, bounds: ke };
        } else
          return te;
      });
    }
    return {
      ...b,
      geometry: {
        polygons: G,
        bounds: ft(G)
      }
    };
  }, U = (b) => async (I) => {
    I.stopPropagation();
    const L = i[b], O = o.polygons.map((X, Z) => {
      if (Z === L.elementIdx) {
        const K = X.rings.map((te, oe) => oe === L.ringIdx ? { points: [
          ...te.points.slice(0, L.pointIdx + 1),
          L.point,
          ...te.points.slice(L.pointIdx + 1)
        ] } : te), J = ge(K[0].points);
        return { rings: K, bounds: J };
      } else
        return X;
    });
    r("change", {
      ...l,
      geometry: {
        polygons: O,
        bounds: ft(O)
      }
    }), await Wn();
    const G = [...document.querySelectorAll(".a9s-handle")][b + 1];
    if (G != null && G.firstChild) {
      const X = new PointerEvent(
        "pointerdown",
        {
          bubbles: true,
          cancelable: true,
          clientX: I.clientX,
          clientY: I.clientY,
          pointerId: I.pointerId,
          pointerType: I.pointerType,
          isPrimary: I.isPrimary,
          buttons: I.buttons
        }
      );
      G.firstChild.dispatchEvent(X);
    }
  }, R = () => {
    const b = o.polygons.map((L, O) => {
      if (g.some((X) => X.polygon === O)) {
        const X = L.rings.map((K, J) => {
          const te = g.filter((oe) => oe.polygon === O && oe.ring === J);
          return te.length && K.points.length - te.length >= 3 ? { points: K.points.filter((Ee, ke) => !te.some((V) => V.point === ke)) } : K;
        }), Z = ge(X[0].points);
        return { rings: X, bounds: Z };
      } else
        return L;
    });
    !jt(o.polygons, b) && (r("change", {
      ...l,
      geometry: {
        polygons: b,
        bounds: ft(b)
      }
    }), n(8, g = []));
  };
  Re(() => {
    if (Le) return;
    const b = (I) => {
      (I.key === "Delete" || I.key === "Backspace") && (I.preventDefault(), R());
    };
    return f.addEventListener("pointermove", S), f.addEventListener("keydown", b), () => {
      f.removeEventListener("pointermove", S), f.removeEventListener("keydown", b);
    };
  });
  const q = `polygon-mask-${Math.random().toString(36).substring(2, 12)}`, z = (b, I, L, { polygon: O, ring: G, point: X }) => O === b && G === I && X === L;
  function w(b) {
    ue.call(this, e, b);
  }
  function v(b) {
    ue.call(this, e, b);
  }
  function _(b) {
    ue.call(this, e, b);
  }
  return e.$$set = (b) => {
    "shape" in b && n(0, l = b.shape), "computedStyle" in b && n(1, a = b.computedStyle), "transform" in b && n(2, u = b.transform), "viewportScale" in b && n(3, d = b.viewportScale), "svgEl" in b && n(4, f = b.svgEl);
  }, e.$$.update = () => {
    e.$$.dirty[0] & /*shape*/
    1 && n(5, o = l.geometry), e.$$.dirty[0] & /*geom, viewportScale*/
    40 && n(10, i = Le ? [] : gs(o, d)), e.$$.dirty[0] & /*geom, viewportScale*/
    40 && n(9, s = yt(o.bounds, et / d));
  }, [
    l,
    a,
    u,
    d,
    f,
    o,
    h,
    p,
    g,
    s,
    i,
    k,
    E,
    A,
    M,
    C,
    T,
    U,
    q,
    z,
    w,
    v,
    _
  ];
}
var bs = class extends pe {
  constructor(t) {
    super(), me(
      this,
      t,
      ws,
      ps,
      se,
      {
        shape: 0,
        computedStyle: 1,
        transform: 2,
        viewportScale: 3,
        svgEl: 4
      },
      null,
      [-1, -1]
    );
  }
};
var ao = /* @__PURE__ */ new Map([
  [x.RECTANGLE, ds],
  [x.POLYGON, as],
  [x.MULTIPOLYGON, bs]
]);
var Es = (e) => ao.get(e.type);
var vs = (e, t) => ao.set(e, t);
function Ss(e, t, n) {
  let o;
  const i = Oe();
  let { annotation: s } = t, { editor: r } = t, { style: l } = t, { target: a } = t, { transform: u } = t, { viewportScale: d } = t, f;
  return Re(() => (n(6, f = new r({
    target: a,
    props: {
      shape: s.target.selector,
      computedStyle: o,
      transform: u,
      viewportScale: d,
      svgEl: a.closest("svg")
    }
  })), f.$on("change", (h) => {
    f.$$set({ shape: h.detail }), i("change", h.detail);
  }), f.$on("grab", (h) => i("grab", h.detail)), f.$on("release", (h) => i("release", h.detail)), () => {
    f.$destroy();
  })), e.$$set = (h) => {
    "annotation" in h && n(0, s = h.annotation), "editor" in h && n(1, r = h.editor), "style" in h && n(2, l = h.style), "target" in h && n(3, a = h.target), "transform" in h && n(4, u = h.transform), "viewportScale" in h && n(5, d = h.viewportScale);
  }, e.$$.update = () => {
    e.$$.dirty & /*annotation, style*/
    5 && n(7, o = Ye(s, l)), e.$$.dirty & /*annotation, editorComponent*/
    65 && s && (f == null || f.$set({ shape: s.target.selector })), e.$$.dirty & /*editorComponent, transform*/
    80 && f && f.$set({ transform: u }), e.$$.dirty & /*editorComponent, viewportScale*/
    96 && f && f.$set({ viewportScale: d }), e.$$.dirty & /*editorComponent, computedStyle*/
    192 && f && o && f.$set({ computedStyle: o });
  }, [
    s,
    r,
    l,
    a,
    u,
    d,
    f,
    o
  ];
}
var As = class extends pe {
  constructor(t) {
    super(), me(this, t, Ss, null, se, {
      annotation: 0,
      editor: 1,
      style: 2,
      target: 3,
      transform: 4,
      viewportScale: 5
    });
  }
};
function ks(e, t, n) {
  const o = Oe();
  let { drawingMode: i } = t, { target: s } = t, { tool: r } = t, { transform: l } = t, { viewportScale: a } = t, u;
  return Re(() => {
    const d = s.closest("svg"), f = [], h = (p, m, g) => {
      d == null || d.addEventListener(p, m, g), f.push(() => d == null ? void 0 : d.removeEventListener(p, m, g));
    };
    return n(5, u = new r({
      target: s,
      props: {
        addEventListener: h,
        drawingMode: i,
        transform: l,
        viewportScale: a
      }
    })), u.$on("create", (p) => o("create", p.detail)), () => {
      f.forEach((p) => p()), u.$destroy();
    };
  }), e.$$set = (d) => {
    "drawingMode" in d && n(0, i = d.drawingMode), "target" in d && n(1, s = d.target), "tool" in d && n(2, r = d.tool), "transform" in d && n(3, l = d.transform), "viewportScale" in d && n(4, a = d.viewportScale);
  }, e.$$.update = () => {
    e.$$.dirty & /*toolComponent, transform*/
    40 && u && u.$set({ transform: l }), e.$$.dirty & /*toolComponent, viewportScale*/
    48 && u && u.$set({ viewportScale: a });
  }, [i, s, r, l, a, u];
}
var Ms = class extends pe {
  constructor(t) {
    super(), me(this, t, ks, null, se, {
      drawingMode: 0,
      target: 1,
      tool: 2,
      transform: 3,
      viewportScale: 4
    });
  }
};
function An(e) {
  let t, n, o, i, s, r, l, a, u, d;
  return {
    c() {
      t = P("defs"), n = P("mask"), o = P("rect"), a = P("rect"), u = P("rect"), d = P("rect"), c(o, "class", "rect-mask-bg svelte-1a76qe7"), c(o, "x", i = /*x*/
      e[1] - /*buffer*/
      e[5]), c(o, "y", s = /*y*/
      e[2] - /*buffer*/
      e[5]), c(o, "width", r = /*w*/
      e[3] + 2 * /*buffer*/
      e[5]), c(o, "height", l = /*h*/
      e[4] + 2 * /*buffer*/
      e[5]), c(a, "class", "rect-mask-fg svelte-1a76qe7"), c(
        a,
        "x",
        /*x*/
        e[1]
      ), c(
        a,
        "y",
        /*y*/
        e[2]
      ), c(
        a,
        "width",
        /*w*/
        e[3]
      ), c(
        a,
        "height",
        /*h*/
        e[4]
      ), c(
        n,
        "id",
        /*maskId*/
        e[6]
      ), c(n, "class", "a9s-rubberband-rectangle-mask svelte-1a76qe7"), c(u, "class", "a9s-outer"), c(u, "mask", `url(#${/*maskId*/
      e[6]})`), c(
        u,
        "x",
        /*x*/
        e[1]
      ), c(
        u,
        "y",
        /*y*/
        e[2]
      ), c(
        u,
        "width",
        /*w*/
        e[3]
      ), c(
        u,
        "height",
        /*h*/
        e[4]
      ), c(d, "class", "a9s-inner"), c(
        d,
        "x",
        /*x*/
        e[1]
      ), c(
        d,
        "y",
        /*y*/
        e[2]
      ), c(
        d,
        "width",
        /*w*/
        e[3]
      ), c(
        d,
        "height",
        /*h*/
        e[4]
      );
    },
    m(f, h) {
      N(f, t, h), j(t, n), j(n, o), j(n, a), N(f, u, h), N(f, d, h);
    },
    p(f, h) {
      h & /*x, buffer*/
      34 && i !== (i = /*x*/
      f[1] - /*buffer*/
      f[5]) && c(o, "x", i), h & /*y, buffer*/
      36 && s !== (s = /*y*/
      f[2] - /*buffer*/
      f[5]) && c(o, "y", s), h & /*w, buffer*/
      40 && r !== (r = /*w*/
      f[3] + 2 * /*buffer*/
      f[5]) && c(o, "width", r), h & /*h, buffer*/
      48 && l !== (l = /*h*/
      f[4] + 2 * /*buffer*/
      f[5]) && c(o, "height", l), h & /*x*/
      2 && c(
        a,
        "x",
        /*x*/
        f[1]
      ), h & /*y*/
      4 && c(
        a,
        "y",
        /*y*/
        f[2]
      ), h & /*w*/
      8 && c(
        a,
        "width",
        /*w*/
        f[3]
      ), h & /*h*/
      16 && c(
        a,
        "height",
        /*h*/
        f[4]
      ), h & /*x*/
      2 && c(
        u,
        "x",
        /*x*/
        f[1]
      ), h & /*y*/
      4 && c(
        u,
        "y",
        /*y*/
        f[2]
      ), h & /*w*/
      8 && c(
        u,
        "width",
        /*w*/
        f[3]
      ), h & /*h*/
      16 && c(
        u,
        "height",
        /*h*/
        f[4]
      ), h & /*x*/
      2 && c(
        d,
        "x",
        /*x*/
        f[1]
      ), h & /*y*/
      4 && c(
        d,
        "y",
        /*y*/
        f[2]
      ), h & /*w*/
      8 && c(
        d,
        "width",
        /*w*/
        f[3]
      ), h & /*h*/
      16 && c(
        d,
        "height",
        /*h*/
        f[4]
      );
    },
    d(f) {
      f && (D(t), D(u), D(d));
    }
  };
}
function Ts(e) {
  let t, n = (
    /*origin*/
    e[0] && An(e)
  );
  return {
    c() {
      t = P("g"), n && n.c(), c(t, "class", "a9s-annotation a9s-rubberband");
    },
    m(o, i) {
      N(o, t, i), n && n.m(t, null);
    },
    p(o, [i]) {
      o[0] ? n ? n.p(o, i) : (n = An(o), n.c(), n.m(t, null)) : n && (n.d(1), n = null);
    },
    i: ee,
    o: ee,
    d(o) {
      o && D(t), n && n.d();
    }
  };
}
function Ls(e, t, n) {
  let o;
  const i = Oe();
  let { addEventListener: s } = t, { drawingMode: r } = t, { transform: l } = t, { viewportScale: a = 1 } = t, u, d, f, h, p, m, g;
  const k = (M) => {
    const C = M;
    u = performance.now(), r === "drag" && (n(0, d = l.elementToImage(C.offsetX, C.offsetY)), f = d, n(1, h = d[0]), n(2, p = d[1]), n(3, m = 1), n(4, g = 1));
  }, E = (M) => {
    const C = M;
    d && (f = l.elementToImage(C.offsetX, C.offsetY), n(1, h = Math.min(f[0], d[0])), n(2, p = Math.min(f[1], d[1])), n(3, m = Math.abs(f[0] - d[0])), n(4, g = Math.abs(f[1] - d[1])));
  }, S = (M) => {
    const C = M, T = performance.now() - u;
    if (r === "click") {
      if (T > 300) return;
      d ? y() : (n(0, d = l.elementToImage(C.offsetX, C.offsetY)), f = d, n(1, h = d[0]), n(2, p = d[1]), n(3, m = 1), n(4, g = 1));
    } else d && (T > 300 || m * g > 100 ? (C.stopPropagation(), y()) : (n(0, d = void 0), f = void 0));
  }, y = () => {
    if (m * g > 15) {
      const M = {
        type: x.RECTANGLE,
        geometry: {
          bounds: {
            minX: h,
            minY: p,
            maxX: h + m,
            maxY: p + g
          },
          x: h,
          y: p,
          w: m,
          h: g
        }
      };
      i("create", M);
    }
    n(0, d = void 0), f = void 0;
  };
  Re(() => {
    s("pointerdown", k), s("pointermove", E), s("pointerup", S, true);
  });
  const A = `rect-mask-${Math.random().toString(36).substring(2, 12)}`;
  return e.$$set = (M) => {
    "addEventListener" in M && n(7, s = M.addEventListener), "drawingMode" in M && n(8, r = M.drawingMode), "transform" in M && n(9, l = M.transform), "viewportScale" in M && n(10, a = M.viewportScale);
  }, e.$$.update = () => {
    e.$$.dirty & /*viewportScale*/
    1024 && n(5, o = 2 / a);
  }, [
    d,
    h,
    p,
    m,
    g,
    o,
    A,
    s,
    r,
    l,
    a
  ];
}
var Ps = class extends pe {
  constructor(t) {
    super(), me(this, t, Ls, Ts, se, {
      addEventListener: 7,
      drawingMode: 8,
      transform: 9,
      viewportScale: 10
    });
  }
};
function Nt(e) {
  const t = e.slice(), n = (
    /*coords*/
    t[2].map((o) => o.join(",")).join(" ")
  );
  return t[19] = n, t;
}
function kn(e) {
  let t, n, o, i, s, r, l, a, u, d, f, h, p, m, g = (
    /*isClosable*/
    e[1] && Mn(e)
  );
  return {
    c() {
      t = P("defs"), n = P("mask"), o = P("rect"), a = P("polygon"), d = P("polygon"), h = P("polygon"), g && g.c(), m = Ae(), c(o, "x", i = /*mask*/
      e[3].x), c(o, "y", s = /*mask*/
      e[3].y), c(o, "width", r = /*mask*/
      e[3].w), c(o, "height", l = /*mask*/
      e[3].h), c(o, "class", "svelte-18wrg3t"), c(a, "points", u = /*str*/
      e[19]), c(a, "class", "svelte-18wrg3t"), c(
        n,
        "id",
        /*maskId*/
        e[5]
      ), c(n, "class", "a9s-rubberband-polygon-mask svelte-18wrg3t"), c(d, "class", "a9s-outer"), c(d, "mask", `url(#${/*maskId*/
      e[5]})`), c(d, "points", f = /*str*/
      e[19]), c(h, "class", "a9s-inner"), c(h, "points", p = /*str*/
      e[19]);
    },
    m(k, E) {
      N(k, t, E), j(t, n), j(n, o), j(n, a), N(k, d, E), N(k, h, E), g && g.m(k, E), N(k, m, E);
    },
    p(k, E) {
      E & /*mask*/
      8 && i !== (i = /*mask*/
      k[3].x) && c(o, "x", i), E & /*mask*/
      8 && s !== (s = /*mask*/
      k[3].y) && c(o, "y", s), E & /*mask*/
      8 && r !== (r = /*mask*/
      k[3].w) && c(o, "width", r), E & /*mask*/
      8 && l !== (l = /*mask*/
      k[3].h) && c(o, "height", l), E & /*coords*/
      4 && u !== (u = /*str*/
      k[19]) && c(a, "points", u), E & /*coords*/
      4 && f !== (f = /*str*/
      k[19]) && c(d, "points", f), E & /*coords*/
      4 && p !== (p = /*str*/
      k[19]) && c(h, "points", p), /*isClosable*/
      k[1] ? g ? g.p(k, E) : (g = Mn(k), g.c(), g.m(m.parentNode, m)) : g && (g.d(1), g = null);
    },
    d(k) {
      k && (D(t), D(d), D(h), D(m)), g && g.d(k);
    }
  };
}
function Mn(e) {
  let t, n, o;
  return {
    c() {
      t = P("circle"), c(t, "class", "a9s-handle svelte-18wrg3t"), c(t, "cx", n = /*points*/
      e[0][0][0]), c(t, "cy", o = /*points*/
      e[0][0][1]), c(
        t,
        "r",
        /*handleRadius*/
        e[4]
      );
    },
    m(i, s) {
      N(i, t, s);
    },
    p(i, s) {
      s & /*points*/
      1 && n !== (n = /*points*/
      i[0][0][0]) && c(t, "cx", n), s & /*points*/
      1 && o !== (o = /*points*/
      i[0][0][1]) && c(t, "cy", o), s & /*handleRadius*/
      16 && c(
        t,
        "r",
        /*handleRadius*/
        i[4]
      );
    },
    d(i) {
      i && D(t);
    }
  };
}
function Is(e) {
  let t, n = (
    /*mask*/
    e[3] && kn(Nt(e))
  );
  return {
    c() {
      t = P("g"), n && n.c(), c(t, "class", "a9s-annotation a9s-rubberband");
    },
    m(o, i) {
      N(o, t, i), n && n.m(t, null);
    },
    p(o, [i]) {
      o[3] ? n ? n.p(Nt(o), i) : (n = kn(Nt(o)), n.c(), n.m(t, null)) : n && (n.d(1), n = null);
    },
    i: ee,
    o: ee,
    d(o) {
      o && D(t), n && n.d();
    }
  };
}
var Cs = 20;
var Os = 1500;
function Ds(e, t, n) {
  let o, i, s;
  const r = Oe();
  let { addEventListener: l } = t, { drawingMode: a } = t, { transform: u } = t, { viewportScale: d = 1 } = t, f, h = [], p, m, g = false;
  const k = (C) => {
    const T = C, { timeStamp: U, offsetX: R, offsetY: q } = T;
    if (f = { timeStamp: U, offsetX: R, offsetY: q }, a === "drag" && h.length === 0) {
      const z = u.elementToImage(T.offsetX, T.offsetY);
      h.push(z), n(10, p = z);
    }
  }, E = (C) => {
    const T = C;
    if (m && clearTimeout(m), h.length > 0) {
      if (n(10, p = u.elementToImage(T.offsetX, T.offsetY)), h.length > 2) {
        const U = ut(p, h[0]) * d;
        n(1, g = U < Cs);
      }
      T.pointerType === "touch" && (m = setTimeout(
        () => {
          y();
        },
        Os
      ));
    }
  }, S = (C) => {
    const T = C;
    if (m && clearTimeout(m), a === "click") {
      const U = T.timeStamp - f.timeStamp, R = ut([f.offsetX, f.offsetY], [T.offsetX, T.offsetY]);
      if (U > 300 || R > 15) return;
      if (g)
        A();
      else if (h.length === 0) {
        const q = u.elementToImage(T.offsetX, T.offsetY);
        h.push(q), n(10, p = q);
      } else
        p && h.push(p);
    } else {
      if (!p) return;
      if (h.length === 1 && ut(h[0], p) <= 4) {
        n(0, h = []), n(10, p = void 0);
        return;
      }
      T.stopImmediatePropagation(), g ? A() : h.push(p);
    }
  }, y = () => {
    if (!p) return;
    const C = h.slice(0, -1);
    if (C.length < 3) return;
    const T = {
      type: x.POLYGON,
      geometry: {
        bounds: ge(h),
        points: C
      }
    };
    Ht(T) > 4 && (n(0, h = []), n(10, p = void 0), r("create", T));
  }, A = () => {
    const C = {
      type: x.POLYGON,
      geometry: {
        bounds: ge(h),
        points: [...h]
      }
    };
    n(0, h = []), n(10, p = void 0), r("create", C);
  };
  Re(() => {
    l("pointerdown", k, true), l("pointermove", E), l("pointerup", S, true), l("dblclick", y, true);
  });
  const M = `polygon-mask-${Math.random().toString(36).substring(2, 12)}`;
  return e.$$set = (C) => {
    "addEventListener" in C && n(6, l = C.addEventListener), "drawingMode" in C && n(7, a = C.drawingMode), "transform" in C && n(8, u = C.transform), "viewportScale" in C && n(9, d = C.viewportScale);
  }, e.$$.update = () => {
    e.$$.dirty & /*viewportScale*/
    512 && n(4, o = 4 / d), e.$$.dirty & /*cursor, isClosable, points*/
    1027 && n(2, i = p ? g ? h : [...h, p] : []), e.$$.dirty & /*coords, viewportScale*/
    516 && n(3, s = i.length > 0 ? yt(ge(i), 2 / d) : void 0);
  }, [
    h,
    g,
    i,
    s,
    o,
    M,
    l,
    a,
    u,
    d,
    p
  ];
}
var Ns = class extends pe {
  constructor(t) {
    super(), me(this, t, Ds, Is, se, {
      addEventListener: 6,
      drawingMode: 7,
      transform: 8,
      viewportScale: 9
    });
  }
};
var Kt = /* @__PURE__ */ new Map([
  ["rectangle", { tool: Ps }],
  ["polygon", { tool: Ns }]
]);
var co = () => [...Kt.keys()];
var uo = (e) => Kt.get(e);
var Rs = (e, t, n = {}) => Kt.set(e, { tool: t, opts: n });
function Ys(e) {
  let t, n, o, i, s;
  return {
    c() {
      t = P("g"), n = P("ellipse"), i = P("ellipse"), c(n, "class", "a9s-outer"), c(n, "style", o = /*computedStyle*/
      e[1] ? "display:none;" : void 0), c(
        n,
        "cx",
        /*cx*/
        e[2]
      ), c(
        n,
        "cy",
        /*cy*/
        e[3]
      ), c(
        n,
        "rx",
        /*rx*/
        e[4]
      ), c(
        n,
        "ry",
        /*ry*/
        e[5]
      ), c(i, "class", "a9s-inner"), c(
        i,
        "style",
        /*computedStyle*/
        e[1]
      ), c(
        i,
        "cx",
        /*cx*/
        e[2]
      ), c(
        i,
        "cy",
        /*cy*/
        e[3]
      ), c(
        i,
        "rx",
        /*rx*/
        e[4]
      ), c(
        i,
        "ry",
        /*ry*/
        e[5]
      ), c(t, "class", "a9s-annotation"), c(t, "data-id", s = /*annotation*/
      e[0].id);
    },
    m(r, l) {
      N(r, t, l), j(t, n), j(t, i);
    },
    p(r, [l]) {
      l & /*computedStyle*/
      2 && o !== (o = /*computedStyle*/
      r[1] ? "display:none;" : void 0) && c(n, "style", o), l & /*computedStyle*/
      2 && c(
        i,
        "style",
        /*computedStyle*/
        r[1]
      ), l & /*annotation*/
      1 && s !== (s = /*annotation*/
      r[0].id) && c(t, "data-id", s);
    },
    i: ee,
    o: ee,
    d(r) {
      r && D(t);
    }
  };
}
function Bs(e, t, n) {
  let o, { annotation: i } = t, { geom: s } = t, { style: r } = t;
  const { cx: l, cy: a, rx: u, ry: d } = s;
  return e.$$set = (f) => {
    "annotation" in f && n(0, i = f.annotation), "geom" in f && n(6, s = f.geom), "style" in f && n(7, r = f.style);
  }, e.$$.update = () => {
    e.$$.dirty & /*annotation, style*/
    129 && n(1, o = Ye(i, r));
  }, [i, o, l, a, u, d, s, r];
}
var Us = class extends pe {
  constructor(t) {
    super(), me(this, t, Bs, Ys, se, { annotation: 0, geom: 6, style: 7 });
  }
};
function Vs(e) {
  let t, n, o, i, s;
  return {
    c() {
      t = P("g"), n = P("line"), i = P("line"), c(n, "class", "a9s-outer"), c(n, "style", o = /*computedStyle*/
      e[1] ? "display:none;" : void 0), c(
        n,
        "x1",
        /*x1*/
        e[2]
      ), c(
        n,
        "y1",
        /*y1*/
        e[3]
      ), c(
        n,
        "x2",
        /*x2*/
        e[4]
      ), c(
        n,
        "y2",
        /*y2*/
        e[5]
      ), c(i, "class", "a9s-inner"), c(
        i,
        "style",
        /*computedStyle*/
        e[1]
      ), c(
        i,
        "x1",
        /*x1*/
        e[2]
      ), c(
        i,
        "y1",
        /*y1*/
        e[3]
      ), c(
        i,
        "x2",
        /*x2*/
        e[4]
      ), c(
        i,
        "y2",
        /*y2*/
        e[5]
      ), c(t, "class", "a9s-annotation"), c(t, "data-id", s = /*annotation*/
      e[0].id);
    },
    m(r, l) {
      N(r, t, l), j(t, n), j(t, i);
    },
    p(r, [l]) {
      l & /*computedStyle*/
      2 && o !== (o = /*computedStyle*/
      r[1] ? "display:none;" : void 0) && c(n, "style", o), l & /*computedStyle*/
      2 && c(
        i,
        "style",
        /*computedStyle*/
        r[1]
      ), l & /*annotation*/
      1 && s !== (s = /*annotation*/
      r[0].id) && c(t, "data-id", s);
    },
    i: ee,
    o: ee,
    d(r) {
      r && D(t);
    }
  };
}
function Xs(e, t, n) {
  let o, { annotation: i } = t, { geom: s } = t, { style: r } = t;
  const { points: l } = s, [[a, u], [d, f]] = l;
  return e.$$set = (h) => {
    "annotation" in h && n(0, i = h.annotation), "geom" in h && n(6, s = h.geom), "style" in h && n(7, r = h.style);
  }, e.$$.update = () => {
    e.$$.dirty & /*annotation, style*/
    129 && n(1, o = Ye(i, r));
  }, [i, o, a, u, d, f, s, r];
}
var Hs = class extends pe {
  constructor(t) {
    super(), me(this, t, Xs, Vs, se, { annotation: 0, geom: 6, style: 7 });
  }
};
function Tn(e, t, n) {
  const o = e.slice();
  return o[5] = t[n], o;
}
function Ln(e) {
  let t, n, o;
  return {
    c() {
      t = P("path"), o = P("path"), c(t, "class", "a9s-outer"), c(t, "style", n = /*computedStyle*/
      e[1] ? "display:none;" : void 0), c(t, "fill-rule", "evenodd"), c(t, "d", Te(
        /*polygonElement*/
        e[5]
      )), c(o, "class", "a9s-inner"), c(
        o,
        "style",
        /*computedStyle*/
        e[1]
      ), c(o, "fill-rule", "evenodd"), c(o, "d", Te(
        /*polygonElement*/
        e[5]
      ));
    },
    m(i, s) {
      N(i, t, s), N(i, o, s);
    },
    p(i, s) {
      s & /*computedStyle*/
      2 && n !== (n = /*computedStyle*/
      i[1] ? "display:none;" : void 0) && c(t, "style", n), s & /*computedStyle*/
      2 && c(
        o,
        "style",
        /*computedStyle*/
        i[1]
      );
    },
    d(i) {
      i && (D(t), D(o));
    }
  };
}
function Gs(e) {
  let t, n, o = ve(
    /*polygons*/
    e[2]
  ), i = [];
  for (let s = 0; s < o.length; s += 1)
    i[s] = Ln(Tn(e, o, s));
  return {
    c() {
      t = P("g");
      for (let s = 0; s < i.length; s += 1)
        i[s].c();
      c(t, "class", "a9s-annotation"), c(t, "data-id", n = /*annotation*/
      e[0].id);
    },
    m(s, r) {
      N(s, t, r);
      for (let l = 0; l < i.length; l += 1)
        i[l] && i[l].m(t, null);
    },
    p(s, [r]) {
      if (r & /*computedStyle, polygons, undefined*/
      6) {
        o = ve(
          /*polygons*/
          s[2]
        );
        let l;
        for (l = 0; l < o.length; l += 1) {
          const a = Tn(s, o, l);
          i[l] ? i[l].p(a, r) : (i[l] = Ln(a), i[l].c(), i[l].m(t, null));
        }
        for (; l < i.length; l += 1)
          i[l].d(1);
        i.length = o.length;
      }
      r & /*annotation*/
      1 && n !== (n = /*annotation*/
      s[0].id) && c(t, "data-id", n);
    },
    i: ee,
    o: ee,
    d(s) {
      s && D(t), Ne(i, s);
    }
  };
}
function js(e, t, n) {
  let o, { annotation: i } = t, { geom: s } = t, { style: r } = t;
  const { polygons: l } = s;
  return e.$$set = (a) => {
    "annotation" in a && n(0, i = a.annotation), "geom" in a && n(3, s = a.geom), "style" in a && n(4, r = a.style);
  }, e.$$.update = () => {
    e.$$.dirty & /*annotation, style*/
    17 && n(1, o = Ye(i, r));
  }, [i, o, l, s, r];
}
var zs = class extends pe {
  constructor(t) {
    super(), me(this, t, js, Gs, se, { annotation: 0, geom: 3, style: 4 });
  }
};
function Fs(e) {
  let t, n, o, i, s;
  return {
    c() {
      t = P("g"), n = P("polygon"), i = P("polygon"), c(n, "class", "a9s-outer"), c(n, "style", o = /*computedStyle*/
      e[1] ? "display:none;" : void 0), c(
        n,
        "points",
        /*points*/
        e[2].map(qs).join(" ")
      ), c(i, "class", "a9s-inner"), c(
        i,
        "style",
        /*computedStyle*/
        e[1]
      ), c(
        i,
        "points",
        /*points*/
        e[2].map(Ks).join(" ")
      ), c(t, "class", "a9s-annotation"), c(t, "data-id", s = /*annotation*/
      e[0].id);
    },
    m(r, l) {
      N(r, t, l), j(t, n), j(t, i);
    },
    p(r, [l]) {
      l & /*computedStyle*/
      2 && o !== (o = /*computedStyle*/
      r[1] ? "display:none;" : void 0) && c(n, "style", o), l & /*computedStyle*/
      2 && c(
        i,
        "style",
        /*computedStyle*/
        r[1]
      ), l & /*annotation*/
      1 && s !== (s = /*annotation*/
      r[0].id) && c(t, "data-id", s);
    },
    i: ee,
    o: ee,
    d(r) {
      r && D(t);
    }
  };
}
var qs = (e) => e.join(",");
var Ks = (e) => e.join(",");
function Ws(e, t, n) {
  let o, { annotation: i } = t, { geom: s } = t, { style: r } = t;
  const { points: l } = s;
  return e.$$set = (a) => {
    "annotation" in a && n(0, i = a.annotation), "geom" in a && n(3, s = a.geom), "style" in a && n(4, r = a.style);
  }, e.$$.update = () => {
    e.$$.dirty & /*annotation, style*/
    17 && n(1, o = Ye(i, r));
  }, [i, o, l, s, r];
}
var Zs = class extends pe {
  constructor(t) {
    super(), me(this, t, Ws, Fs, se, { annotation: 0, geom: 3, style: 4 });
  }
};
function Js(e) {
  let t, n, o, i, s, r, l;
  return {
    c() {
      t = P("g"), n = P("path"), s = P("path"), c(n, "class", o = ze(`a9s-outer ${/*cssClass*/
      e[1]}`) + " svelte-1w0132l"), c(n, "style", i = /*computedStyle*/
      e[3] ? "display:none;" : void 0), c(
        n,
        "d",
        /*d*/
        e[2]
      ), c(s, "class", r = ze(`a9s-inner ${/*cssClass*/
      e[1]}`) + " svelte-1w0132l"), c(
        s,
        "style",
        /*computedStyle*/
        e[3]
      ), c(
        s,
        "d",
        /*d*/
        e[2]
      ), c(t, "class", "a9s-annotation"), c(t, "data-id", l = /*annotation*/
      e[0].id);
    },
    m(a, u) {
      N(a, t, u), j(t, n), j(t, s);
    },
    p(a, [u]) {
      u & /*cssClass*/
      2 && o !== (o = ze(`a9s-outer ${/*cssClass*/
      a[1]}`) + " svelte-1w0132l") && c(n, "class", o), u & /*computedStyle*/
      8 && i !== (i = /*computedStyle*/
      a[3] ? "display:none;" : void 0) && c(n, "style", i), u & /*d*/
      4 && c(
        n,
        "d",
        /*d*/
        a[2]
      ), u & /*cssClass*/
      2 && r !== (r = ze(`a9s-inner ${/*cssClass*/
      a[1]}`) + " svelte-1w0132l") && c(s, "class", r), u & /*computedStyle*/
      8 && c(
        s,
        "style",
        /*computedStyle*/
        a[3]
      ), u & /*d*/
      4 && c(
        s,
        "d",
        /*d*/
        a[2]
      ), u & /*annotation*/
      1 && l !== (l = /*annotation*/
      a[0].id) && c(t, "data-id", l);
    },
    i: ee,
    o: ee,
    d(a) {
      a && D(t);
    }
  };
}
function Qs(e, t, n) {
  let o, i, s, { annotation: r } = t, { geom: l } = t, { style: a } = t;
  return e.$$set = (u) => {
    "annotation" in u && n(0, r = u.annotation), "geom" in u && n(4, l = u.geom), "style" in u && n(5, a = u.style);
  }, e.$$.update = () => {
    e.$$.dirty & /*annotation, style*/
    33 && n(3, o = Ye(r, a)), e.$$.dirty & /*geom*/
    16 && n(2, i = $n(l)), e.$$.dirty & /*geom*/
    16 && n(1, s = l.closed ? "closed" : "open");
  }, [r, s, i, o, l, a];
}
var xs = class extends pe {
  constructor(t) {
    super(), me(this, t, Qs, Js, se, { annotation: 0, geom: 4, style: 5 });
  }
};
function $s(e) {
  let t, n, o, i, s;
  return {
    c() {
      t = P("g"), n = P("rect"), i = P("rect"), c(n, "class", "a9s-outer"), c(n, "style", o = /*computedStyle*/
      e[5] ? "display:none;" : void 0), c(
        n,
        "x",
        /*x*/
        e[4]
      ), c(
        n,
        "y",
        /*y*/
        e[3]
      ), c(
        n,
        "width",
        /*w*/
        e[2]
      ), c(
        n,
        "height",
        /*h*/
        e[1]
      ), c(i, "class", "a9s-inner"), c(
        i,
        "style",
        /*computedStyle*/
        e[5]
      ), c(
        i,
        "x",
        /*x*/
        e[4]
      ), c(
        i,
        "y",
        /*y*/
        e[3]
      ), c(
        i,
        "width",
        /*w*/
        e[2]
      ), c(
        i,
        "height",
        /*h*/
        e[1]
      ), c(t, "class", "a9s-annotation"), c(t, "data-id", s = /*annotation*/
      e[0].id);
    },
    m(r, l) {
      N(r, t, l), j(t, n), j(t, i);
    },
    p(r, [l]) {
      l & /*computedStyle*/
      32 && o !== (o = /*computedStyle*/
      r[5] ? "display:none;" : void 0) && c(n, "style", o), l & /*x*/
      16 && c(
        n,
        "x",
        /*x*/
        r[4]
      ), l & /*y*/
      8 && c(
        n,
        "y",
        /*y*/
        r[3]
      ), l & /*w*/
      4 && c(
        n,
        "width",
        /*w*/
        r[2]
      ), l & /*h*/
      2 && c(
        n,
        "height",
        /*h*/
        r[1]
      ), l & /*computedStyle*/
      32 && c(
        i,
        "style",
        /*computedStyle*/
        r[5]
      ), l & /*x*/
      16 && c(
        i,
        "x",
        /*x*/
        r[4]
      ), l & /*y*/
      8 && c(
        i,
        "y",
        /*y*/
        r[3]
      ), l & /*w*/
      4 && c(
        i,
        "width",
        /*w*/
        r[2]
      ), l & /*h*/
      2 && c(
        i,
        "height",
        /*h*/
        r[1]
      ), l & /*annotation*/
      1 && s !== (s = /*annotation*/
      r[0].id) && c(t, "data-id", s);
    },
    i: ee,
    o: ee,
    d(r) {
      r && D(t);
    }
  };
}
function er(e, t, n) {
  let o, i, s, r, l, { annotation: a } = t, { geom: u } = t, { style: d } = t;
  return e.$$set = (f) => {
    "annotation" in f && n(0, a = f.annotation), "geom" in f && n(6, u = f.geom), "style" in f && n(7, d = f.style);
  }, e.$$.update = () => {
    e.$$.dirty & /*annotation, style*/
    129 && n(5, o = Ye(a, d)), e.$$.dirty & /*geom*/
    64 && n(4, { x: i, y: s, w: r, h: l } = u, i, (n(3, s), n(6, u)), (n(2, r), n(6, u)), (n(1, l), n(6, u)));
  }, [a, l, r, s, i, o, u, d];
}
var tr = class extends pe {
  constructor(t) {
    super(), me(this, t, er, $s, se, { annotation: 0, geom: 6, style: 7 });
  }
};
var Ur = {
  elementToImage: (e, t) => [e, t]
};
var nr = (e) => ({
  elementToImage: (t, n) => {
    const o = e.getBoundingClientRect(), i = e.createSVGPoint();
    i.x = t + o.x, i.y = n + o.y;
    const { x: s, y: r } = i.matrixTransform(e.getScreenCTM().inverse());
    return [s, r];
  }
});
var or = 250;
var ir = (e, t) => {
  const n = Oe();
  let o;
  return { onPointerDown: () => o = performance.now(), onPointerUp: (r) => {
    if (performance.now() - o < or) {
      const { x: a, y: u } = fo(r, e), d = Le ? 10 : 2, f = t.getAt(a, u, void 0, d);
      f ? n("click", { originalEvent: r, annotation: f }) : n("click", { originalEvent: r });
    }
  } };
};
var fo = (e, t) => {
  const n = t.createSVGPoint(), o = t.getBoundingClientRect(), i = e.clientX - o.x, s = e.clientY - o.y, { left: r, top: l } = t.getBoundingClientRect();
  return n.x = i + r, n.y = s + l, n.matrixTransform(t.getScreenCTM().inverse());
};
function Pn(e, t, n) {
  const o = e.slice();
  return o[39] = t[n], o;
}
function In(e, t, n) {
  const o = e.slice();
  return o[42] = t[n], o;
}
function Rt(e) {
  const t = e.slice(), n = (
    /*annotation*/
    t[42].target.selector
  );
  return t[45] = n, t;
}
function Cn(e) {
  let t = (
    /*annotation*/
    e[42]
  ), n, o, i = On(e);
  return {
    c() {
      i.c(), n = Ae();
    },
    m(s, r) {
      i.m(s, r), N(s, n, r), o = true;
    },
    p(s, r) {
      r[0] & /*$store*/
      131072 && se(t, t = /*annotation*/
      s[42]) ? (we(), H(i, 1, 1, ee), be(), i = On(s), i.c(), B(i, 1), i.m(n.parentNode, n)) : i.p(s, r);
    },
    i(s) {
      o || (B(i), o = true);
    },
    o(s) {
      H(i), o = false;
    },
    d(s) {
      s && D(n), i.d(s);
    }
  };
}
function sr(e) {
  let t, n;
  return t = new Hs({
    props: {
      annotation: (
        /*annotation*/
        e[42]
      ),
      geom: (
        /*selector*/
        e[45].geometry
      ),
      style: (
        /*style*/
        e[1]
      )
    }
  }), {
    c() {
      ae(t.$$.fragment);
    },
    m(o, i) {
      re(t, o, i), n = true;
    },
    p(o, i) {
      const s = {};
      i[0] & /*$store*/
      131072 && (s.annotation = /*annotation*/
      o[42]), i[0] & /*$store*/
      131072 && (s.geom = /*selector*/
      o[45].geometry), i[0] & /*style*/
      2 && (s.style = /*style*/
      o[1]), t.$set(s);
    },
    i(o) {
      n || (B(t.$$.fragment, o), n = true);
    },
    o(o) {
      H(t.$$.fragment, o), n = false;
    },
    d(o) {
      le(t, o);
    }
  };
}
function rr(e) {
  let t, n;
  return t = new xs({
    props: {
      annotation: (
        /*annotation*/
        e[42]
      ),
      geom: (
        /*selector*/
        e[45].geometry
      ),
      style: (
        /*style*/
        e[1]
      )
    }
  }), {
    c() {
      ae(t.$$.fragment);
    },
    m(o, i) {
      re(t, o, i), n = true;
    },
    p(o, i) {
      const s = {};
      i[0] & /*$store*/
      131072 && (s.annotation = /*annotation*/
      o[42]), i[0] & /*$store*/
      131072 && (s.geom = /*selector*/
      o[45].geometry), i[0] & /*style*/
      2 && (s.style = /*style*/
      o[1]), t.$set(s);
    },
    i(o) {
      n || (B(t.$$.fragment, o), n = true);
    },
    o(o) {
      H(t.$$.fragment, o), n = false;
    },
    d(o) {
      le(t, o);
    }
  };
}
function lr(e) {
  let t, n;
  return t = new zs({
    props: {
      annotation: (
        /*annotation*/
        e[42]
      ),
      geom: (
        /*selector*/
        e[45].geometry
      ),
      style: (
        /*style*/
        e[1]
      )
    }
  }), {
    c() {
      ae(t.$$.fragment);
    },
    m(o, i) {
      re(t, o, i), n = true;
    },
    p(o, i) {
      const s = {};
      i[0] & /*$store*/
      131072 && (s.annotation = /*annotation*/
      o[42]), i[0] & /*$store*/
      131072 && (s.geom = /*selector*/
      o[45].geometry), i[0] & /*style*/
      2 && (s.style = /*style*/
      o[1]), t.$set(s);
    },
    i(o) {
      n || (B(t.$$.fragment, o), n = true);
    },
    o(o) {
      H(t.$$.fragment, o), n = false;
    },
    d(o) {
      le(t, o);
    }
  };
}
function ar(e) {
  let t, n;
  return t = new Zs({
    props: {
      annotation: (
        /*annotation*/
        e[42]
      ),
      geom: (
        /*selector*/
        e[45].geometry
      ),
      style: (
        /*style*/
        e[1]
      )
    }
  }), {
    c() {
      ae(t.$$.fragment);
    },
    m(o, i) {
      re(t, o, i), n = true;
    },
    p(o, i) {
      const s = {};
      i[0] & /*$store*/
      131072 && (s.annotation = /*annotation*/
      o[42]), i[0] & /*$store*/
      131072 && (s.geom = /*selector*/
      o[45].geometry), i[0] & /*style*/
      2 && (s.style = /*style*/
      o[1]), t.$set(s);
    },
    i(o) {
      n || (B(t.$$.fragment, o), n = true);
    },
    o(o) {
      H(t.$$.fragment, o), n = false;
    },
    d(o) {
      le(t, o);
    }
  };
}
function cr(e) {
  let t, n;
  return t = new tr({
    props: {
      annotation: (
        /*annotation*/
        e[42]
      ),
      geom: (
        /*selector*/
        e[45].geometry
      ),
      style: (
        /*style*/
        e[1]
      )
    }
  }), {
    c() {
      ae(t.$$.fragment);
    },
    m(o, i) {
      re(t, o, i), n = true;
    },
    p(o, i) {
      const s = {};
      i[0] & /*$store*/
      131072 && (s.annotation = /*annotation*/
      o[42]), i[0] & /*$store*/
      131072 && (s.geom = /*selector*/
      o[45].geometry), i[0] & /*style*/
      2 && (s.style = /*style*/
      o[1]), t.$set(s);
    },
    i(o) {
      n || (B(t.$$.fragment, o), n = true);
    },
    o(o) {
      H(t.$$.fragment, o), n = false;
    },
    d(o) {
      le(t, o);
    }
  };
}
function ur(e) {
  var o;
  let t, n;
  return t = new Us({
    props: {
      annotation: (
        /*annotation*/
        e[42]
      ),
      geom: (
        /*selector*/
        (o = e[45]) == null ? void 0 : o.geometry
      ),
      style: (
        /*style*/
        e[1]
      )
    }
  }), {
    c() {
      ae(t.$$.fragment);
    },
    m(i, s) {
      re(t, i, s), n = true;
    },
    p(i, s) {
      var l;
      const r = {};
      s[0] & /*$store*/
      131072 && (r.annotation = /*annotation*/
      i[42]), s[0] & /*$store*/
      131072 && (r.geom = /*selector*/
      (l = i[45]) == null ? void 0 : l.geometry), s[0] & /*style*/
      2 && (r.style = /*style*/
      i[1]), t.$set(r);
    },
    i(i) {
      n || (B(t.$$.fragment, i), n = true);
    },
    o(i) {
      H(t.$$.fragment, i), n = false;
    },
    d(i) {
      le(t, i);
    }
  };
}
function On(e) {
  let t, n, o, i;
  const s = [
    ur,
    cr,
    ar,
    lr,
    rr,
    sr
  ], r = [];
  function l(a, u) {
    var d, f, h, p, m, g;
    return (
      /*selector*/
      ((d = a[45]) == null ? void 0 : d.type) === x.ELLIPSE ? 0 : (
        /*selector*/
        ((f = a[45]) == null ? void 0 : f.type) === x.RECTANGLE ? 1 : (
          /*selector*/
          ((h = a[45]) == null ? void 0 : h.type) === x.POLYGON ? 2 : (
            /*selector*/
            ((p = a[45]) == null ? void 0 : p.type) === x.MULTIPOLYGON ? 3 : (
              /*selector*/
              ((m = a[45]) == null ? void 0 : m.type) === x.POLYLINE ? 4 : (
                /*selector*/
                ((g = a[45]) == null ? void 0 : g.type) === x.LINE ? 5 : -1
              )
            )
          )
        )
      )
    );
  }
  return ~(t = l(e)) && (n = r[t] = s[t](e)), {
    c() {
      n && n.c(), o = Ae();
    },
    m(a, u) {
      ~t && r[t].m(a, u), N(a, o, u), i = true;
    },
    p(a, u) {
      let d = t;
      t = l(a), t === d ? ~t && r[t].p(a, u) : (n && (we(), H(r[d], 1, 1, () => {
        r[d] = null;
      }), be()), ~t ? (n = r[t], n ? n.p(a, u) : (n = r[t] = s[t](a), n.c()), B(n, 1), n.m(o.parentNode, o)) : n = null);
    },
    i(a) {
      i || (B(n), i = true);
    },
    o(a) {
      H(n), i = false;
    },
    d(a) {
      a && D(o), ~t && r[t].d(a);
    }
  };
}
function Dn(e) {
  let t = pt(
    /*annotation*/
    e[42]
  ) && !/*isEditable*/
  e[10](
    /*annotation*/
    e[42]
  ), n, o, i = t && Cn(Rt(e));
  return {
    c() {
      i && i.c(), n = Ae();
    },
    m(s, r) {
      i && i.m(s, r), N(s, n, r), o = true;
    },
    p(s, r) {
      r[0] & /*$store, isEditable*/
      132096 && (t = pt(
        /*annotation*/
        s[42]
      ) && !/*isEditable*/
      s[10](
        /*annotation*/
        s[42]
      )), t ? i ? (i.p(Rt(s), r), r[0] & /*$store, isEditable*/
      132096 && B(i, 1)) : (i = Cn(Rt(s)), i.c(), B(i, 1), i.m(n.parentNode, n)) : i && (we(), H(i, 1, 1, () => {
        i = null;
      }), be());
    },
    i(s) {
      o || (B(i), o = true);
    },
    o(s) {
      H(i), o = false;
    },
    d(s) {
      s && D(n), i && i.d(s);
    }
  };
}
function Nn(e) {
  let t, n, o, i;
  const s = [dr, fr], r = [];
  function l(a, u) {
    return (
      /*editors*/
      a[6] ? 0 : (
        /*tool*/
        a[15] && /*drawingEnabled*/
        a[0] ? 1 : -1
      )
    );
  }
  return ~(t = l(e)) && (n = r[t] = s[t](e)), {
    c() {
      n && n.c(), o = Ae();
    },
    m(a, u) {
      ~t && r[t].m(a, u), N(a, o, u), i = true;
    },
    p(a, u) {
      let d = t;
      t = l(a), t === d ? ~t && r[t].p(a, u) : (n && (we(), H(r[d], 1, 1, () => {
        r[d] = null;
      }), be()), ~t ? (n = r[t], n ? n.p(a, u) : (n = r[t] = s[t](a), n.c()), B(n, 1), n.m(o.parentNode, o)) : n = null);
    },
    i(a) {
      i || (B(n), i = true);
    },
    o(a) {
      H(n), i = false;
    },
    d(a) {
      a && D(o), ~t && r[t].d(a);
    }
  };
}
function fr(e) {
  let t = `${/*toolName*/
  e[2]}-${/*toolMountKey*/
  e[7]}`, n, o, i = Rn(e);
  return {
    c() {
      i.c(), n = Ae();
    },
    m(s, r) {
      i.m(s, r), N(s, n, r), o = true;
    },
    p(s, r) {
      r[0] & /*toolName, toolMountKey*/
      132 && se(t, t = `${/*toolName*/
      s[2]}-${/*toolMountKey*/
      s[7]}`) ? (we(), H(i, 1, 1, ee), be(), i = Rn(s), i.c(), B(i, 1), i.m(n.parentNode, n)) : i.p(s, r);
    },
    i(s) {
      o || (B(i), o = true);
    },
    o(s) {
      H(i), o = false;
    },
    d(s) {
      s && D(n), i.d(s);
    }
  };
}
function dr(e) {
  let t, n, o = ve(
    /*editors*/
    e[6]
  ), i = [];
  for (let r = 0; r < o.length; r += 1)
    i[r] = Bn(Pn(e, o, r));
  const s = (r) => H(i[r], 1, 1, () => {
    i[r] = null;
  });
  return {
    c() {
      for (let r = 0; r < i.length; r += 1)
        i[r].c();
      t = Ae();
    },
    m(r, l) {
      for (let a = 0; a < i.length; a += 1)
        i[a] && i[a].m(r, l);
      N(r, t, l), n = true;
    },
    p(r, l) {
      if (l[0] & /*editors, drawingEl, style, transform, $scale, onChangeSelected*/
      8659266) {
        o = ve(
          /*editors*/
          r[6]
        );
        let a;
        for (a = 0; a < o.length; a += 1) {
          const u = Pn(r, o, a);
          i[a] ? (i[a].p(u, l), B(i[a], 1)) : (i[a] = Bn(u), i[a].c(), B(i[a], 1), i[a].m(t.parentNode, t));
        }
        for (we(), a = o.length; a < i.length; a += 1)
          s(a);
        be();
      }
    },
    i(r) {
      if (!n) {
        for (let l = 0; l < o.length; l += 1)
          B(i[l]);
        n = true;
      }
    },
    o(r) {
      i = i.filter(Boolean);
      for (let l = 0; l < i.length; l += 1)
        H(i[l]);
      n = false;
    },
    d(r) {
      r && D(t), Ne(i, r);
    }
  };
}
function Rn(e) {
  let t, n;
  return t = new Ms({
    props: {
      target: (
        /*drawingEl*/
        e[8]
      ),
      tool: (
        /*tool*/
        e[15]
      ),
      drawingMode: (
        /*drawingMode*/
        e[14]
      ),
      transform: (
        /*transform*/
        e[13]
      ),
      viewportScale: (
        /*$scale*/
        e[18]
      )
    }
  }), t.$on(
    "create",
    /*onSelectionCreated*/
    e[22]
  ), {
    c() {
      ae(t.$$.fragment);
    },
    m(o, i) {
      re(t, o, i), n = true;
    },
    p(o, i) {
      const s = {};
      i[0] & /*drawingEl*/
      256 && (s.target = /*drawingEl*/
      o[8]), i[0] & /*tool*/
      32768 && (s.tool = /*tool*/
      o[15]), i[0] & /*drawingMode*/
      16384 && (s.drawingMode = /*drawingMode*/
      o[14]), i[0] & /*transform*/
      8192 && (s.transform = /*transform*/
      o[13]), i[0] & /*$scale*/
      262144 && (s.viewportScale = /*$scale*/
      o[18]), t.$set(s);
    },
    i(o) {
      n || (B(t.$$.fragment, o), n = true);
    },
    o(o) {
      H(t.$$.fragment, o), n = false;
    },
    d(o) {
      le(t, o);
    }
  };
}
function Yn(e) {
  let t, n;
  return t = new As({
    props: {
      target: (
        /*drawingEl*/
        e[8]
      ),
      editor: (
        /*editable*/
        e[39].editor
      ),
      annotation: (
        /*editable*/
        e[39].annotation
      ),
      style: (
        /*style*/
        e[1]
      ),
      transform: (
        /*transform*/
        e[13]
      ),
      viewportScale: (
        /*$scale*/
        e[18]
      )
    }
  }), t.$on("change", function() {
    ie(
      /*onChangeSelected*/
      e[23](
        /*editable*/
        e[39].annotation
      )
    ) && e[23](
      /*editable*/
      e[39].annotation
    ).apply(this, arguments);
  }), {
    c() {
      ae(t.$$.fragment);
    },
    m(o, i) {
      re(t, o, i), n = true;
    },
    p(o, i) {
      e = o;
      const s = {};
      i[0] & /*drawingEl*/
      256 && (s.target = /*drawingEl*/
      e[8]), i[0] & /*editors*/
      64 && (s.editor = /*editable*/
      e[39].editor), i[0] & /*editors*/
      64 && (s.annotation = /*editable*/
      e[39].annotation), i[0] & /*style*/
      2 && (s.style = /*style*/
      e[1]), i[0] & /*transform*/
      8192 && (s.transform = /*transform*/
      e[13]), i[0] & /*$scale*/
      262144 && (s.viewportScale = /*$scale*/
      e[18]), t.$set(s);
    },
    i(o) {
      n || (B(t.$$.fragment, o), n = true);
    },
    o(o) {
      H(t.$$.fragment, o), n = false;
    },
    d(o) {
      le(t, o);
    }
  };
}
function Bn(e) {
  let t = (
    /*editable*/
    e[39].annotation.id
  ), n, o, i = Yn(e);
  return {
    c() {
      i.c(), n = Ae();
    },
    m(s, r) {
      i.m(s, r), N(s, n, r), o = true;
    },
    p(s, r) {
      r[0] & /*editors*/
      64 && se(t, t = /*editable*/
      s[39].annotation.id) ? (we(), H(i, 1, 1, ee), be(), i = Yn(s), i.c(), B(i, 1), i.m(n.parentNode, n)) : i.p(s, r);
    },
    i(s) {
      o || (B(i), o = true);
    },
    o(s) {
      H(i), o = false;
    },
    d(s) {
      s && D(n), i.d(s);
    }
  };
}
function hr(e) {
  let t, n, o, i, s, r, l = ve(
    /*$store*/
    e[17].filter(
      /*func*/
      e[34]
    )
  ), a = [];
  for (let f = 0; f < l.length; f += 1)
    a[f] = Dn(In(e, l, f));
  const u = (f) => H(a[f], 1, 1, () => {
    a[f] = null;
  });
  let d = (
    /*drawingEl*/
    e[8] && Nn(e)
  );
  return {
    c() {
      t = P("svg"), n = P("g");
      for (let f = 0; f < a.length; f += 1)
        a[f].c();
      o = P("g"), d && d.c(), c(o, "class", "drawing"), c(t, "role", "application"), c(t, "tabindex", 0), c(t, "class", "a9s-annotationlayer"), Me(
        t,
        "drawing",
        /*tool*/
        e[15]
      ), Me(
        t,
        "editing",
        /*editableAnnotations*/
        e[5]
      ), Me(t, "hidden", !/*visible*/
      e[3]), Me(
        t,
        "hover",
        /*$hover*/
        e[16]
      );
    },
    m(f, h) {
      N(f, t, h), j(t, n);
      for (let p = 0; p < a.length; p += 1)
        a[p] && a[p].m(n, null);
      j(t, o), d && d.m(o, null), e[35](o), e[36](t), i = true, s || (r = [
        W(t, "pointerup", function() {
          ie(
            /*onPointerUp*/
            e[11]
          ) && e[11].apply(this, arguments);
        }),
        W(t, "pointerdown", function() {
          ie(
            /*onPointerDown*/
            e[12]
          ) && e[12].apply(this, arguments);
        }),
        W(
          t,
          "pointermove",
          /*onPointerMove*/
          e[24]
        )
      ], s = true);
    },
    p(f, h) {
      if (e = f, h[0] & /*$store, style, isEditable*/
      132098) {
        l = ve(
          /*$store*/
          e[17].filter(
            /*func*/
            e[34]
          )
        );
        let p;
        for (p = 0; p < l.length; p += 1) {
          const m = In(e, l, p);
          a[p] ? (a[p].p(m, h), B(a[p], 1)) : (a[p] = Dn(m), a[p].c(), B(a[p], 1), a[p].m(n, null));
        }
        for (we(), p = l.length; p < a.length; p += 1)
          u(p);
        be();
      }
      e[8] ? d ? (d.p(e, h), h[0] & /*drawingEl*/
      256 && B(d, 1)) : (d = Nn(e), d.c(), B(d, 1), d.m(o, null)) : d && (we(), H(d, 1, 1, () => {
        d = null;
      }), be()), (!i || h[0] & /*tool*/
      32768) && Me(
        t,
        "drawing",
        /*tool*/
        e[15]
      ), (!i || h[0] & /*editableAnnotations*/
      32) && Me(
        t,
        "editing",
        /*editableAnnotations*/
        e[5]
      ), (!i || h[0] & /*visible*/
      8) && Me(t, "hidden", !/*visible*/
      e[3]), (!i || h[0] & /*$hover*/
      65536) && Me(
        t,
        "hover",
        /*$hover*/
        e[16]
      );
    },
    i(f) {
      if (!i) {
        for (let h = 0; h < l.length; h += 1)
          B(a[h]);
        B(d), i = true;
      }
    },
    o(f) {
      a = a.filter(Boolean);
      for (let h = 0; h < a.length; h += 1)
        H(a[h]);
      H(d), i = false;
    },
    d(f) {
      f && D(t), Ne(a, f), d && d.d(), e[35](null), e[36](null), s = false, Se(r);
    }
  };
}
function gr(e, t, n) {
  let o, i, s, r, l, a, u, d, f, h, p, m, g = ee, k = () => (g(), g = Gn(b, (V) => n(18, m = V)), b);
  e.$$.on_destroy.push(() => g());
  let { drawingEnabled: E } = t, { image: S } = t, { preferredDrawingMode: y } = t, { state: A } = t, { style: M = void 0 } = t, { toolName: C = co()[0] } = t, { user: T } = t, { visible: U = true } = t, R = 0;
  const q = () => n(7, R += 1), z = () => C, w = () => E;
  let v, _, b;
  Re(() => k(n(9, b = zi(S, _))));
  const { hover: I, selection: L, store: O } = A;
  vt(e, I, (V) => n(16, f = V)), vt(e, L, (V) => n(33, h = V)), vt(e, O, (V) => n(17, p = V));
  let G, X;
  const Z = (V) => {
    G && O.unobserve(G);
    const ce = V.filter(({ editable: $ }) => $).map(({ id: $ }) => $);
    ce.length > 0 ? (n(5, X = ce.map(($) => O.getAnnotation($)).filter(($) => $ && pt($))), G = ($) => {
      const { updated: fe } = $.changes;
      n(5, X = fe == null ? void 0 : fe.map((_e) => _e.newValue));
    }, O.observe(G, { annotations: ce })) : n(5, X = void 0);
  }, K = (V) => {
    const ce = no(), $ = {
      id: ce,
      bodies: [],
      target: {
        annotation: ce,
        selector: V.detail,
        creator: T,
        created: /* @__PURE__ */ new Date()
      }
    };
    O.addAnnotation($), L.setSelected($.id);
  }, J = (V) => (ce) => {
    var Be;
    const { target: $ } = V, fe = 10 * 60 * 1e3, _e = ((Be = $.creator) == null ? void 0 : Be.id) !== T.id || !$.created || (/* @__PURE__ */ new Date()).getTime() - $.created.getTime() > fe;
    O.updateTarget({
      ...$,
      selector: ce.detail,
      created: _e ? $.created : /* @__PURE__ */ new Date(),
      updated: _e ? /* @__PURE__ */ new Date() : void 0,
      updatedBy: _e ? T : void 0
    });
  }, te = (V) => {
    const { x: ce, y: $ } = fo(V, _), fe = O.getAt(ce, $, void 0, 2);
    fe ? f !== fe.id && I.set(fe.id) : I.set(void 0);
  }, oe = (V) => pt(V);
  function Ee(V) {
    ht[V ? "unshift" : "push"](() => {
      v = V, n(8, v);
    });
  }
  function ke(V) {
    ht[V ? "unshift" : "push"](() => {
      _ = V, n(4, _);
    });
  }
  return e.$$set = (V) => {
    "drawingEnabled" in V && n(0, E = V.drawingEnabled), "image" in V && n(25, S = V.image), "preferredDrawingMode" in V && n(26, y = V.preferredDrawingMode), "state" in V && n(27, A = V.state), "style" in V && n(1, M = V.style), "toolName" in V && n(2, C = V.toolName), "user" in V && n(28, T = V.user), "visible" in V && n(3, U = V.visible);
  }, e.$$.update = () => {
    e.$$.dirty[0] & /*toolName*/
    4 && n(15, { tool: o, opts: i } = uo(C) || { tool: void 0, opts: void 0 }, o, (n(32, i), n(2, C))), e.$$.dirty[0] & /*preferredDrawingMode*/
    67108864 | e.$$.dirty[1] & /*opts*/
    2 && n(14, s = (i == null ? void 0 : i.drawingMode) || y), e.$$.dirty[0] & /*svgEl*/
    16 && n(13, r = nr(_)), e.$$.dirty[0] & /*svgEl*/
    16 && n(12, { onPointerDown: l, onPointerUp: a } = ir(_, O), l, (n(11, a), n(4, _))), e.$$.dirty[1] & /*$selection*/
    4 && Z(h.selected), e.$$.dirty[0] & /*editableAnnotations*/
    32 && n(6, u = X ? X.map((V) => ({
      annotation: V,
      editor: Es(V.target.selector)
    })).filter((V) => V.editor) : void 0), e.$$.dirty[0] & /*editors*/
    64 && n(10, d = (V) => u && u.some((ce) => ce.annotation.id === V.id));
  }, [
    E,
    M,
    C,
    U,
    _,
    X,
    u,
    R,
    v,
    b,
    d,
    a,
    l,
    r,
    s,
    o,
    f,
    p,
    m,
    I,
    L,
    O,
    K,
    J,
    te,
    S,
    y,
    A,
    T,
    q,
    z,
    w,
    i,
    h,
    oe,
    Ee,
    ke
  ];
}
var mr = class extends pe {
  constructor(t) {
    super(), me(
      this,
      t,
      gr,
      hr,
      se,
      {
        drawingEnabled: 0,
        image: 25,
        preferredDrawingMode: 26,
        state: 27,
        style: 1,
        toolName: 2,
        user: 28,
        visible: 3,
        cancelDrawing: 29,
        getDrawingTool: 30,
        isDrawingEnabled: 31
      },
      null,
      [-1, -1]
    );
  }
  get cancelDrawing() {
    return this.$$.ctx[29];
  }
  get getDrawingTool() {
    return this.$$.ctx[30];
  }
  get isDrawingEnabled() {
    return this.$$.ctx[31];
  }
};
function ho(e, t, n = 0, o = e.length - 1, i = pr) {
  for (; o > n; ) {
    if (o - n > 600) {
      const a = o - n + 1, u = t - n + 1, d = Math.log(a), f = 0.5 * Math.exp(2 * d / 3), h = 0.5 * Math.sqrt(d * f * (a - f) / a) * (u - a / 2 < 0 ? -1 : 1), p = Math.max(n, Math.floor(t - u * f / a + h)), m = Math.min(o, Math.floor(t + (a - u) * f / a + h));
      ho(e, t, p, m, i);
    }
    const s = e[t];
    let r = n, l = o;
    for (We(e, n, t), i(e[o], s) > 0 && We(e, n, o); r < l; ) {
      for (We(e, r, l), r++, l--; i(e[r], s) < 0; ) r++;
      for (; i(e[l], s) > 0; ) l--;
    }
    i(e[n], s) === 0 ? We(e, n, l) : (l++, We(e, l, o)), l <= t && (n = l + 1), t <= l && (o = l - 1);
  }
}
function We(e, t, n) {
  const o = e[t];
  e[t] = e[n], e[n] = o;
}
function pr(e, t) {
  return e < t ? -1 : e > t ? 1 : 0;
}
var _r = class {
  constructor(t = 9) {
    this._maxEntries = Math.max(4, t), this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4)), this.clear();
  }
  all() {
    return this._all(this.data, []);
  }
  search(t) {
    let n = this.data;
    const o = [];
    if (!at(t, n)) return o;
    const i = this.toBBox, s = [];
    for (; n; ) {
      for (let r = 0; r < n.children.length; r++) {
        const l = n.children[r], a = n.leaf ? i(l) : l;
        at(t, a) && (n.leaf ? o.push(l) : Bt(t, a) ? this._all(l, o) : s.push(l));
      }
      n = s.pop();
    }
    return o;
  }
  collides(t) {
    let n = this.data;
    if (!at(t, n)) return false;
    const o = [];
    for (; n; ) {
      for (let i = 0; i < n.children.length; i++) {
        const s = n.children[i], r = n.leaf ? this.toBBox(s) : s;
        if (at(t, r)) {
          if (n.leaf || Bt(t, r)) return true;
          o.push(s);
        }
      }
      n = o.pop();
    }
    return false;
  }
  load(t) {
    if (!(t && t.length)) return this;
    if (t.length < this._minEntries) {
      for (let o = 0; o < t.length; o++)
        this.insert(t[o]);
      return this;
    }
    let n = this._build(t.slice(), 0, t.length - 1, 0);
    if (!this.data.children.length)
      this.data = n;
    else if (this.data.height === n.height)
      this._splitRoot(this.data, n);
    else {
      if (this.data.height < n.height) {
        const o = this.data;
        this.data = n, n = o;
      }
      this._insert(n, this.data.height - n.height - 1, true);
    }
    return this;
  }
  insert(t) {
    return t && this._insert(t, this.data.height - 1), this;
  }
  clear() {
    return this.data = je([]), this;
  }
  remove(t, n) {
    if (!t) return this;
    let o = this.data;
    const i = this.toBBox(t), s = [], r = [];
    let l, a, u;
    for (; o || s.length; ) {
      if (o || (o = s.pop(), a = s[s.length - 1], l = r.pop(), u = true), o.leaf) {
        const d = yr(t, o.children, n);
        if (d !== -1)
          return o.children.splice(d, 1), s.push(o), this._condense(s), this;
      }
      !u && !o.leaf && Bt(o, i) ? (s.push(o), r.push(l), l = 0, a = o, o = o.children[0]) : a ? (l++, o = a.children[l], u = false) : o = null;
    }
    return this;
  }
  toBBox(t) {
    return t;
  }
  compareMinX(t, n) {
    return t.minX - n.minX;
  }
  compareMinY(t, n) {
    return t.minY - n.minY;
  }
  toJSON() {
    return this.data;
  }
  fromJSON(t) {
    return this.data = t, this;
  }
  _all(t, n) {
    const o = [];
    for (; t; )
      t.leaf ? n.push(...t.children) : o.push(...t.children), t = o.pop();
    return n;
  }
  _build(t, n, o, i) {
    const s = o - n + 1;
    let r = this._maxEntries, l;
    if (s <= r)
      return l = je(t.slice(n, o + 1)), He(l, this.toBBox), l;
    i || (i = Math.ceil(Math.log(s) / Math.log(r)), r = Math.ceil(s / Math.pow(r, i - 1))), l = je([]), l.leaf = false, l.height = i;
    const a = Math.ceil(s / r), u = a * Math.ceil(Math.sqrt(r));
    Un(t, n, o, u, this.compareMinX);
    for (let d = n; d <= o; d += u) {
      const f = Math.min(d + u - 1, o);
      Un(t, d, f, a, this.compareMinY);
      for (let h = d; h <= f; h += a) {
        const p = Math.min(h + a - 1, f);
        l.children.push(this._build(t, h, p, i - 1));
      }
    }
    return He(l, this.toBBox), l;
  }
  _chooseSubtree(t, n, o, i) {
    for (; i.push(n), !(n.leaf || i.length - 1 === o); ) {
      let s = 1 / 0, r = 1 / 0, l;
      for (let a = 0; a < n.children.length; a++) {
        const u = n.children[a], d = Yt(u), f = Er(t, u) - d;
        f < r ? (r = f, s = d < s ? d : s, l = u) : f === r && d < s && (s = d, l = u);
      }
      n = l || n.children[0];
    }
    return n;
  }
  _insert(t, n, o) {
    const i = o ? t : this.toBBox(t), s = [], r = this._chooseSubtree(i, this.data, n, s);
    for (r.children.push(t), Je(r, i); n >= 0 && s[n].children.length > this._maxEntries; )
      this._split(s, n), n--;
    this._adjustParentBBoxes(i, s, n);
  }
  // split overflowed node into two
  _split(t, n) {
    const o = t[n], i = o.children.length, s = this._minEntries;
    this._chooseSplitAxis(o, s, i);
    const r = this._chooseSplitIndex(o, s, i), l = je(o.children.splice(r, o.children.length - r));
    l.height = o.height, l.leaf = o.leaf, He(o, this.toBBox), He(l, this.toBBox), n ? t[n - 1].children.push(l) : this._splitRoot(o, l);
  }
  _splitRoot(t, n) {
    this.data = je([t, n]), this.data.height = t.height + 1, this.data.leaf = false, He(this.data, this.toBBox);
  }
  _chooseSplitIndex(t, n, o) {
    let i, s = 1 / 0, r = 1 / 0;
    for (let l = n; l <= o - n; l++) {
      const a = Ze(t, 0, l, this.toBBox), u = Ze(t, l, o, this.toBBox), d = vr(a, u), f = Yt(a) + Yt(u);
      d < s ? (s = d, i = l, r = f < r ? f : r) : d === s && f < r && (r = f, i = l);
    }
    return i || o - n;
  }
  // sorts node children by the best axis for split
  _chooseSplitAxis(t, n, o) {
    const i = t.leaf ? this.compareMinX : wr, s = t.leaf ? this.compareMinY : br, r = this._allDistMargin(t, n, o, i), l = this._allDistMargin(t, n, o, s);
    r < l && t.children.sort(i);
  }
  // total margin of all possible split distributions where each node is at least m full
  _allDistMargin(t, n, o, i) {
    t.children.sort(i);
    const s = this.toBBox, r = Ze(t, 0, n, s), l = Ze(t, o - n, o, s);
    let a = lt(r) + lt(l);
    for (let u = n; u < o - n; u++) {
      const d = t.children[u];
      Je(r, t.leaf ? s(d) : d), a += lt(r);
    }
    for (let u = o - n - 1; u >= n; u--) {
      const d = t.children[u];
      Je(l, t.leaf ? s(d) : d), a += lt(l);
    }
    return a;
  }
  _adjustParentBBoxes(t, n, o) {
    for (let i = o; i >= 0; i--)
      Je(n[i], t);
  }
  _condense(t) {
    for (let n = t.length - 1, o; n >= 0; n--)
      t[n].children.length === 0 ? n > 0 ? (o = t[n - 1].children, o.splice(o.indexOf(t[n]), 1)) : this.clear() : He(t[n], this.toBBox);
  }
};
function yr(e, t, n) {
  if (!n) return t.indexOf(e);
  for (let o = 0; o < t.length; o++)
    if (n(e, t[o])) return o;
  return -1;
}
function He(e, t) {
  Ze(e, 0, e.children.length, t, e);
}
function Ze(e, t, n, o, i) {
  i || (i = je(null)), i.minX = 1 / 0, i.minY = 1 / 0, i.maxX = -1 / 0, i.maxY = -1 / 0;
  for (let s = t; s < n; s++) {
    const r = e.children[s];
    Je(i, e.leaf ? o(r) : r);
  }
  return i;
}
function Je(e, t) {
  return e.minX = Math.min(e.minX, t.minX), e.minY = Math.min(e.minY, t.minY), e.maxX = Math.max(e.maxX, t.maxX), e.maxY = Math.max(e.maxY, t.maxY), e;
}
function wr(e, t) {
  return e.minX - t.minX;
}
function br(e, t) {
  return e.minY - t.minY;
}
function Yt(e) {
  return (e.maxX - e.minX) * (e.maxY - e.minY);
}
function lt(e) {
  return e.maxX - e.minX + (e.maxY - e.minY);
}
function Er(e, t) {
  return (Math.max(t.maxX, e.maxX) - Math.min(t.minX, e.minX)) * (Math.max(t.maxY, e.maxY) - Math.min(t.minY, e.minY));
}
function vr(e, t) {
  const n = Math.max(e.minX, t.minX), o = Math.max(e.minY, t.minY), i = Math.min(e.maxX, t.maxX), s = Math.min(e.maxY, t.maxY);
  return Math.max(0, i - n) * Math.max(0, s - o);
}
function Bt(e, t) {
  return e.minX <= t.minX && e.minY <= t.minY && t.maxX <= e.maxX && t.maxY <= e.maxY;
}
function at(e, t) {
  return t.minX <= e.maxX && t.minY <= e.maxY && t.maxX >= e.minX && t.maxY >= e.minY;
}
function je(e) {
  return {
    children: e,
    height: 1,
    leaf: true,
    minX: 1 / 0,
    minY: 1 / 0,
    maxX: -1 / 0,
    maxY: -1 / 0
  };
}
function Un(e, t, n, o, i) {
  const s = [t, n];
  for (; s.length; ) {
    if (n = s.pop(), t = s.pop(), n - t <= o) continue;
    const r = t + Math.ceil((n - t) / o / 2) * o;
    ho(e, r, t, n, i), s.push(t, r, r, n);
  }
}
var Sr = () => {
  const e = new _r(), t = /* @__PURE__ */ new Map(), n = () => [...t.values()], o = () => {
    e.clear(), t.clear();
  }, i = (f) => {
    if (!dt(f)) return;
    const { minX: h, minY: p, maxX: m, maxY: g } = f.selector.geometry.bounds, k = { minX: h, minY: p, maxX: m, maxY: g, target: f };
    e.insert(k), t.set(f.annotation, k);
  }, s = (f) => {
    if (!dt(f)) return;
    const h = t.get(f.annotation);
    h && e.remove(h), t.delete(f.annotation);
  };
  return {
    all: n,
    clear: o,
    getAt: (f, h, p = 0) => {
      const g = e.search({
        minX: f - p,
        minY: h - p,
        maxX: f + p,
        maxY: h + p
      }).map((k) => k.target).filter((k) => k.selector.type === x.RECTANGLE || Io(k.selector, f, h, p));
      return g.length > 0 ? (g.sort((k, E) => Ht(k.selector) - Ht(E.selector)), g) : [];
    },
    getIntersecting: (f, h, p, m) => e.search({
      minX: f,
      minY: h,
      maxX: f + p,
      maxY: h + m
    }).map((g) => g.target),
    insert: i,
    remove: s,
    set: (f, h = true) => {
      h && o();
      const p = f.reduce((m, g) => {
        if (dt(g)) {
          const { minX: k, minY: E, maxX: S, maxY: y } = g.selector.geometry.bounds;
          return [...m, { minX: k, minY: E, maxX: S, maxY: y, target: g }];
        } else
          return m;
      }, []);
      p.forEach((m) => t.set(m.target.annotation, m)), e.load(p);
    },
    size: () => e.all().length,
    update: (f, h) => {
      s(f), i(h);
    }
  };
};
var Ar = (e) => {
  const t = Ei(), n = Sr(), o = li(t, e.userSelectAction, e.adapter), i = ri(t), s = Mi();
  return t.observe(({ changes: a }) => {
    n.set((a.created || []).map((u) => u.target), false), (a.deleted || []).forEach((u) => n.remove(u.target)), (a.updated || []).forEach(({ oldValue: u, newValue: d }) => n.update(u.target, d.target));
  }), {
    store: {
      ...t,
      getAt: (a, u, d, f) => {
        const h = n.getAt(a, u, f);
        if (d)
          return h.map((m) => t.getAnnotation(m.annotation)).filter(Boolean).filter(d)[0];
        {
          const p = h[0];
          return p ? t.getAnnotation(p.annotation) : void 0;
        }
      },
      getIntersecting: (a, u, d, f) => n.getIntersecting(a, u, d, f).map((h) => t.getAnnotation(h.annotation)).filter(Boolean)
    },
    selection: o,
    hover: i,
    viewport: s
  };
};
var kr = (e) => {
  const t = Ar(e);
  return {
    ...t,
    store: vi(t.store)
  };
};
var Mr = (e) => {
  let t, n;
  if (e.nodeName === "CANVAS")
    t = e, n = t.getContext("2d", { willReadFrequently: true });
  else {
    const i = e;
    t = document.createElement("canvas"), t.width = i.width, t.height = i.height, n = t.getContext("2d", { willReadFrequently: true }), n.drawImage(i, 0, 0, i.width, i.height);
  }
  let o = 0;
  for (let i = 1; i < 10; i++)
    for (let s = 1; s < 10; s++) {
      const r = Math.round(s * t.width / 10), l = Math.round(i * t.height / 10), a = n.getImageData(r, l, 1, 1).data, u = (0.299 * a[0] + 0.587 * a[1] + 0.114 * a[2]) / 255;
      o += u;
    }
  return o / 81;
};
var Tr = (e) => {
  const t = Mr(e), n = t > 0.6 ? "dark" : "light";
  return console.log(`[Annotorious] Image brightness: ${t.toFixed(1)}. Setting ${n} theme.`), n;
};
var Vn = (e, t, n) => t.setAttribute("data-theme", n === "auto" ? Tr(e) : n);
var Lr = (e, t) => ({
  ...e,
  drawingEnabled: e.drawingEnabled === void 0 ? t.drawingEnabled : e.drawingEnabled,
  drawingMode: e.drawingMode || t.drawingMode,
  userSelectAction: e.userSelectAction || t.userSelectAction,
  theme: e.theme || t.theme
});
var Xn = typeof navigator > "u" ? false : navigator.userAgent.indexOf("Mac OS X") !== -1;
var Pr = (e, t) => {
  const n = t || document, o = (r) => {
    const l = r;
    l.key === "z" && l.ctrlKey ? e.undo() : l.key === "y" && l.ctrlKey && e.redo();
  }, i = (r) => {
    const l = r;
    l.key === "z" && l.metaKey && (l.shiftKey ? e.redo() : e.undo());
  }, s = () => {
    Xn ? n.removeEventListener("keydown", i) : n.removeEventListener("keydown", o);
  };
  return Xn ? n.addEventListener("keydown", i) : n.addEventListener("keydown", o), {
    destroy: s
  };
};
var Vr = (e, t = {}) => {
  if (!e)
    throw "Missing argument: image";
  const n = typeof e == "string" ? document.getElementById(e) : e, o = Lr(t, {
    drawingEnabled: true,
    drawingMode: "drag",
    userSelectAction: oo.EDIT,
    theme: "light"
  }), i = kr(o), { selection: s, store: r } = i, l = ki(r, o.initialHistory), a = Ti(
    i,
    l,
    o.adapter,
    o.autoSave
  ), u = document.createElement("DIV");
  u.style.position = "relative", u.style.display = "inline-block", n.style.display = "block", n.parentNode.insertBefore(u, n), u.appendChild(n);
  const d = Pr(l);
  let f = Ri();
  Vn(n, u, o.theme);
  const h = new mr({
    target: u,
    props: {
      drawingEnabled: !!o.drawingEnabled,
      image: n,
      preferredDrawingMode: o.drawingMode,
      state: i,
      style: o.style,
      user: f
    }
  });
  h.$on("click", (w) => {
    const { originalEvent: v, annotation: _ } = w.detail;
    _ ? s.userSelect(_.id, v) : s.isEmpty() || s.clear();
  });
  const p = Pi(i, l, o.adapter), m = () => h.cancelDrawing(), g = () => {
    h.$destroy(), u.parentNode.insertBefore(n, u), u.parentNode.removeChild(u), d.destroy(), l.destroy();
  }, k = () => h.getDrawingTool(), E = () => f, S = () => h.isDrawingEnabled(), y = (w, v, _) => Rs(w, v, _), A = (w, v) => vs(w, v), M = (w) => {
    if (!uo(w))
      throw `No drawing tool named ${w}`;
    h.$set({ toolName: w });
  }, C = (w) => h.$set({ drawingEnabled: w }), T = (w) => {
    console.warn("Filter not implemented yet");
  }, U = (w) => h.$set({ style: w }), R = (w) => Vn(n, u, w), q = (w) => {
    f = w, h.$set({ user: w });
  }, z = (w) => (
    // @ts-ignore
    h.$set({ visible: w })
  );
  return {
    ...p,
    cancelDrawing: m,
    destroy: g,
    getDrawingTool: k,
    getUser: E,
    isDrawingEnabled: S,
    listDrawingTools: co,
    on: a.on,
    off: a.off,
    registerDrawingTool: y,
    registerShapeEditor: A,
    setDrawingEnabled: C,
    setDrawingTool: M,
    setFilter: T,
    setStyle: U,
    setTheme: R,
    setUser: q,
    setVisible: z,
    element: u,
    state: i
  };
};
export {
  qt as Editor,
  As as EditorMount,
  Fe as Handle,
  Ur as IdentityTransform,
  lo as MidpointHandle,
  as as PolygonEditor,
  ds as RectangleEditor,
  Vo as RectangleUtil,
  Ps as RubberbandRectangle,
  mr as SVGAnnotationLayer,
  x as ShapeType,
  Ms as ToolMount,
  oo as UserSelectAction,
  Br as W3CImageFormat,
  ir as addEventListeners,
  Gt as approximateAsPolygon,
  ft as boundsFromMultiPolygonElements,
  ge as boundsFromPoints,
  Rr as chainStyles,
  Ht as computeArea,
  gt as computePolygonArea,
  $n as computeSVGPath,
  Nr as computeStyle,
  Dr as createBody,
  Vr as createImageAnnotator,
  Ar as createImageAnnotatorState,
  nr as createSVGTransform,
  kr as createSvelteImageAnnotatorState,
  Yr as defaultColorProvider,
  Tr as detectTheme,
  ut as distance,
  zi as enableResponsive,
  Lr as fillDefaults,
  Ro as getAllCorners,
  Es as getEditor,
  yt as getMaskDimensions,
  fo as getSVGPoint,
  uo as getTool,
  Pr as initKeyboardCommands,
  Io as intersects,
  pt as isImageAnnotation,
  dt as isImageAnnotationTarget,
  Xn as isMac,
  mt as isPointInPolygon,
  Le as isTouch,
  co as listDrawingTools,
  Te as multipolygonElementToPath,
  Xo as parseFragmentSelector,
  Qo as parseSVGSelector,
  Xi as parseW3CImageAnnotation,
  Co as pointsToPath,
  vs as registerEditor,
  Ke as registerShapeUtil,
  Rs as registerTool,
  Mr as sampleBrightness,
  Ho as serializeFragmentSelector,
  $o as serializeSVGSelector,
  Hi as serializeW3CImageAnnotation,
  Vn as setTheme,
  Cr as simplifyMultiPolygon,
  Qn as simplifyPoints,
  Or as simplifyPolygon
};
//# sourceMappingURL=@annotorious_annotorious.js.map
