var M = Object.prototype.hasOwnProperty;
function N(e, t) {
  var n, o;
  if (e === t) return !0;
  if (e && t && (n = e.constructor) === t.constructor) {
    if (n === Date) return e.getTime() === t.getTime();
    if (n === RegExp) return e.toString() === t.toString();
    if (n === Array) {
      if ((o = e.length) === t.length)
        for (; o-- && N(e[o], t[o]); ) ;
      return o === -1;
    }
    if (!n || typeof e == "object") {
      o = 0;
      for (n in e)
        if (M.call(e, n) && ++o && !M.call(t, n) || !(n in t) || !N(e[n], t[n])) return !1;
      return Object.keys(t).length === o;
    }
  }
  return e !== e && t !== t;
}
function V() {
}
function Z(e, t) {
  return e != e ? t == t : e !== t || e && typeof e == "object" || typeof e == "function";
}
const z = [];
function P(e, t = V) {
  let n;
  const o = /* @__PURE__ */ new Set();
  function s(v) {
    if (Z(e, v) && (e = v, n)) {
      const E = !z.length;
      for (const h of o)
        h[1](), z.push(h, e);
      if (E) {
        for (let h = 0; h < z.length; h += 2)
          z[h][0](z[h + 1]);
        z.length = 0;
      }
    }
  }
  function g(v) {
    s(v(e));
  }
  function m(v, E = V) {
    const h = [v, E];
    return o.add(h), o.size === 1 && (n = t(s, g) || V), v(e), () => {
      o.delete(h), o.size === 0 && n && (n(), n = null);
    };
  }
  return { set: s, update: g, subscribe: m };
}
const De = (e) => {
  const { subscribe: t, set: n } = P();
  let o;
  return t((s) => o = s), e.observe(({ changes: s }) => {
    if (o) {
      (s.deleted || []).some((v) => v.id === o) && n(void 0);
      const m = (s.updated || []).find(({ oldValue: v }) => v.id === o);
      m && n(m.newValue.id);
    }
  }), {
    get current() {
      return o;
    },
    subscribe: t,
    set: n
  };
};
var F = /* @__PURE__ */ ((e) => (e.EDIT = "EDIT", e.SELECT = "SELECT", e.NONE = "NONE", e))(F || {});
const $ = { selected: [] }, Be = (e, t, n) => {
  const { subscribe: o, set: s } = P($);
  let g = t, m = $;
  o((A) => m = A);
  const v = () => {
    N(m, $) || s($);
  }, E = () => {
    var A;
    return ((A = m.selected) == null ? void 0 : A.length) === 0;
  }, h = (A) => {
    if (E())
      return !1;
    const L = typeof A == "string" ? A : A.id;
    return m.selected.some((c) => c.id === L);
  }, T = (A, L) => {
    let c;
    if (Array.isArray(A)) {
      if (c = A.map((f) => e.getAnnotation(f)).filter(Boolean), c.length < A.length) {
        console.warn("Invalid selection: " + A.filter((f) => !c.some((b) => b.id === f)));
        return;
      }
    } else {
      const f = e.getAnnotation(A);
      if (!f) {
        console.warn("Invalid selection: " + A);
        return;
      }
      c = [f];
    }
    const u = c.reduce((f, b) => {
      const d = C(b);
      return d === "EDIT" ? [...f, { id: b.id, editable: !0 }] : d === "SELECT" ? [...f, { id: b.id }] : f;
    }, []);
    s({ selected: u, event: L });
  }, a = (A, L) => {
    const c = Array.isArray(A) ? A : [A], u = c.map((f) => e.getAnnotation(f)).filter((f) => !!f);
    s({
      selected: u.map((f) => {
        const b = L === void 0 ? C(f) === "EDIT" : L;
        return { id: f.id, editable: b };
      })
    }), u.length !== c.length && console.warn("Invalid selection", A);
  }, w = (A) => {
    if (E())
      return !1;
    const { selected: L } = m;
    L.some(({ id: u }) => A.includes(u)) && s({ selected: L.filter(({ id: u }) => !A.includes(u)) });
  }, D = (A) => {
    g = A, a(m.selected.map(({ id: L }) => L));
  }, C = (A) => K(A, g, n);
  return e.observe(
    ({ changes: A }) => w((A.deleted || []).map((L) => L.id))
  ), {
    get event() {
      return m ? m.event : null;
    },
    get selected() {
      return m ? [...m.selected] : null;
    },
    get userSelectAction() {
      return g;
    },
    clear: v,
    evalSelectAction: C,
    isEmpty: E,
    isSelected: h,
    setSelected: a,
    setUserSelectAction: D,
    subscribe: o,
    userSelect: T
  };
}, K = (e, t, n) => {
  const o = n ? n.serialize(e) : e;
  return typeof t == "function" ? t(o) : t || "EDIT";
}, R = [];
for (let e = 0; e < 256; ++e)
  R.push((e + 256).toString(16).slice(1));
function ee(e, t = 0) {
  return (R[e[t + 0]] + R[e[t + 1]] + R[e[t + 2]] + R[e[t + 3]] + "-" + R[e[t + 4]] + R[e[t + 5]] + "-" + R[e[t + 6]] + R[e[t + 7]] + "-" + R[e[t + 8]] + R[e[t + 9]] + "-" + R[e[t + 10]] + R[e[t + 11]] + R[e[t + 12]] + R[e[t + 13]] + R[e[t + 14]] + R[e[t + 15]]).toLowerCase();
}
let Y;
const te = new Uint8Array(16);
function ne() {
  if (!Y) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    Y = crypto.getRandomValues.bind(crypto);
  }
  return Y(te);
}
const oe = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), W = { randomUUID: oe };
function se(e, t, n) {
  var s;
  e = e || {};
  const o = e.random ?? ((s = e.rng) == null ? void 0 : s.call(e)) ?? ne();
  if (o.length < 16)
    throw new Error("Random bytes length must be >= 16");
  return o[6] = o[6] & 15 | 64, o[8] = o[8] & 63 | 128, ee(o);
}
function q(e, t, n) {
  return W.randomUUID && !e ? W.randomUUID() : se(e);
}
const Re = (e) => {
  const { creator: t, updatedBy: n } = e.target, o = e.bodies.reduce((s, g) => [...s, g.creator, g.updatedBy].filter(Boolean), []);
  return [
    t,
    n,
    ...o
  ].filter((s) => s);
}, j = (e) => {
  const t = (n) => {
    const o = { ...n };
    return n.created && typeof n.created == "string" && (o.created = new Date(n.created)), n.updated && typeof n.updated == "string" && (o.updated = new Date(n.updated)), o;
  };
  return {
    ...e,
    bodies: (e.bodies || []).map(t),
    target: t(e.target)
  };
}, xe = (e, t, n, o) => ({
  id: q(),
  annotation: typeof e == "string" ? e : e.id,
  created: n || /* @__PURE__ */ new Date(),
  creator: o,
  ...t
}), ie = (e, t) => {
  const n = new Set(e.bodies.map((o) => o.id));
  return t.bodies.filter((o) => !n.has(o.id));
}, de = (e, t) => {
  const n = new Set(t.bodies.map((o) => o.id));
  return e.bodies.filter((o) => !n.has(o.id));
}, re = (e, t) => t.bodies.map((n) => {
  const o = e.bodies.find((s) => s.id === n.id);
  return { newBody: n, oldBody: o && !N(o, n) ? o : void 0 };
}).filter(({ oldBody: n }) => n).map(({ oldBody: n, newBody: o }) => ({ oldBody: n, newBody: o })), ce = (e, t) => !N(e.target, t.target), G = (e, t) => {
  const n = ie(e, t), o = de(e, t), s = re(e, t);
  return {
    oldValue: e,
    newValue: t,
    bodiesCreated: n.length > 0 ? n : void 0,
    bodiesDeleted: o.length > 0 ? o : void 0,
    bodiesUpdated: s.length > 0 ? s : void 0,
    targetUpdated: ce(e, t) ? { oldTarget: e.target, newTarget: t.target } : void 0
  };
};
var ae = /* @__PURE__ */ ((e) => (e.BODY_ONLY = "BODY_ONLY", e.TARGET_ONLY = "TARGET_ONLY", e))(ae || {}), O = /* @__PURE__ */ ((e) => (e.LOCAL = "LOCAL", e.REMOTE = "REMOTE", e.SILENT = "SILENT", e))(O || {});
const le = (e, t) => {
  var g, m;
  const { changes: n, origin: o } = t;
  if (!(e.options.origin ? e.options.origin === o : o !== "SILENT"))
    return !1;
  if (e.options.ignore) {
    const { ignore: v } = e.options, E = (T) => T && T.length > 0;
    if (!(E(n.created) || E(n.deleted))) {
      const T = (g = n.updated) == null ? void 0 : g.some((w) => E(w.bodiesCreated) || E(w.bodiesDeleted) || E(w.bodiesUpdated)), a = (m = n.updated) == null ? void 0 : m.some((w) => w.targetUpdated);
      if (v === "BODY_ONLY" && T && !a || v === "TARGET_ONLY" && a && !T)
        return !1;
    }
  }
  if (e.options.annotations) {
    const v = /* @__PURE__ */ new Set([
      ...(n.created || []).map((h) => h.id),
      ...(n.deleted || []).map((h) => h.id),
      ...(n.updated || []).map(({ oldValue: h }) => h.id)
    ]);
    return !!(Array.isArray(e.options.annotations) ? e.options.annotations : [e.options.annotations]).find((h) => v.has(h));
  } else
    return !0;
}, ue = (e, t) => {
  const n = new Set((e.created || []).map((a) => a.id)), o = new Set((e.updated || []).map(({ newValue: a }) => a.id)), s = new Set((t.created || []).map((a) => a.id)), g = new Set((t.deleted || []).map((a) => a.id)), m = new Set((t.updated || []).map(({ oldValue: a }) => a.id)), v = new Set((t.updated || []).filter(({ oldValue: a }) => n.has(a.id) || o.has(a.id)).map(({ oldValue: a }) => a.id)), E = [
    ...(e.created || []).filter((a) => !g.has(a.id)).map((a) => m.has(a.id) ? t.updated.find(({ oldValue: w }) => w.id === a.id).newValue : a),
    ...t.created || []
  ], h = [
    ...(e.deleted || []).filter((a) => !s.has(a.id)),
    ...(t.deleted || []).filter((a) => !n.has(a.id))
  ], T = [
    ...(e.updated || []).filter(({ newValue: a }) => !g.has(a.id)).map((a) => {
      const { oldValue: w, newValue: D } = a;
      if (m.has(D.id)) {
        const C = t.updated.find((A) => A.oldValue.id === D.id).newValue;
        return G(w, C);
      } else
        return a;
    }),
    ...(t.updated || []).filter(({ oldValue: a }) => !v.has(a.id))
  ];
  return { created: E, deleted: h, updated: T };
}, _ = (e) => {
  const t = e.id === void 0 ? q() : e.id;
  return {
    ...e,
    id: t,
    bodies: e.bodies === void 0 ? [] : e.bodies.map((n) => ({
      ...n,
      annotation: t
    })),
    target: {
      ...e.target,
      annotation: t
    }
  };
}, fe = (e) => e.id !== void 0, ke = () => {
  const e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Map(), n = [], o = (i, r = {}) => {
    n.push({ onChange: i, options: r });
  }, s = (i) => {
    const r = n.findIndex((l) => l.onChange == i);
    r > -1 && n.splice(r, 1);
  }, g = (i, r) => {
    const l = {
      origin: i,
      changes: {
        created: r.created || [],
        updated: r.updated || [],
        deleted: r.deleted || []
      },
      state: [...e.values()]
    };
    n.forEach((p) => {
      le(p, l) && p.onChange(l);
    });
  }, m = (i, r = O.LOCAL) => {
    if (i.id && e.get(i.id))
      throw Error(`Cannot add annotation ${i.id} - exists already`);
    {
      const p = _(i);
      e.set(p.id, p), p.bodies.forEach((U) => t.set(U.id, p.id)), g(r, { created: [p] });
    }
  }, v = (i, r) => {
    const l = _(typeof i == "string" ? r : i), p = typeof i == "string" ? i : i.id, U = p && e.get(p);
    if (U) {
      const y = G(U, l);
      return p === l.id ? e.set(p, l) : (e.delete(p), e.set(l.id, l)), U.bodies.forEach((B) => t.delete(B.id)), l.bodies.forEach((B) => t.set(B.id, l.id)), y;
    } else
      console.warn(`Cannot update annotation ${p} - does not exist`);
  }, E = (i, r = O.LOCAL, l = O.LOCAL) => {
    const p = fe(r) ? l : r, U = v(i, r);
    U && g(p, { updated: [U] });
  }, h = (i, r = O.LOCAL) => {
    !!e.get(i.id) ? E(i, r) : m(i, r);
  }, T = (i, r = O.LOCAL) => {
    const l = i.reduce((p, U) => {
      const y = v(U);
      return y ? [...p, y] : p;
    }, []);
    l.length > 0 && g(r, { updated: l });
  }, a = (i, r = O.LOCAL) => {
    const l = i.map(_), { toAdd: p, toUpdate: U } = l.reduce((B, I) => e.get(I.id) ? { ...B, toUpdate: [...B.toUpdate, I] } : { ...B, toAdd: [...B.toAdd, I] }, { toAdd: [], toUpdate: [] }), y = U.map((B) => v(B, r)).filter(Boolean);
    p.forEach((B) => {
      e.set(B.id, B), B.bodies.forEach((I) => t.set(I.id, B.id));
    }), g(r, { created: p, updated: y });
  }, w = (i, r = O.LOCAL) => {
    const l = e.get(i.annotation);
    if (l) {
      const p = {
        ...l,
        bodies: [...l.bodies, i]
      };
      e.set(l.id, p), t.set(i.id, p.id), g(r, { updated: [{
        oldValue: l,
        newValue: p,
        bodiesCreated: [i]
      }] });
    } else
      console.warn(`Attempt to add body to missing annotation: ${i.annotation}`);
  }, D = () => [...e.values()], C = (i = O.LOCAL) => {
    const r = [...e.values()];
    e.clear(), t.clear(), g(i, { deleted: r });
  }, A = (i, r = !0, l = O.LOCAL) => {
    const p = i.map(_);
    if (r) {
      const U = [...e.values()];
      e.clear(), t.clear(), p.forEach((y) => {
        e.set(y.id, y), y.bodies.forEach((B) => t.set(B.id, y.id));
      }), g(l, { created: p, deleted: U });
    } else {
      const U = i.reduce((y, B) => {
        const I = B.id && e.get(B.id);
        return I ? [...y, I] : y;
      }, []);
      if (U.length > 0)
        throw Error(`Bulk insert would overwrite the following annotations: ${U.map((y) => y.id).join(", ")}`);
      p.forEach((y) => {
        e.set(y.id, y), y.bodies.forEach((B) => t.set(B.id, y.id));
      }), g(l, { created: p });
    }
  }, L = (i) => {
    const r = typeof i == "string" ? i : i.id, l = e.get(r);
    if (l)
      return e.delete(r), l.bodies.forEach((p) => t.delete(p.id)), l;
    console.warn(`Attempt to delete missing annotation: ${r}`);
  }, c = (i, r = O.LOCAL) => {
    const l = L(i);
    l && g(r, { deleted: [l] });
  }, u = (i, r = O.LOCAL) => {
    const l = i.reduce((p, U) => {
      const y = L(U);
      return y ? [...p, y] : p;
    }, []);
    l.length > 0 && g(r, { deleted: l });
  }, f = (i) => {
    const r = e.get(i.annotation);
    if (r) {
      const l = r.bodies.find((p) => p.id === i.id);
      if (l) {
        t.delete(l.id);
        const p = {
          ...r,
          bodies: r.bodies.filter((y) => y.id !== i.id)
        };
        return e.set(r.id, p), {
          oldValue: r,
          newValue: p,
          bodiesDeleted: [l]
        };
      } else
        console.warn(`Attempt to delete missing body ${i.id} from annotation ${i.annotation}`);
    } else
      console.warn(`Attempt to delete body from missing annotation ${i.annotation}`);
  }, b = (i, r = O.LOCAL) => {
    const l = f(i);
    l && g(r, { updated: [l] });
  }, d = (i, r = O.LOCAL) => {
    const l = i.map((p) => f(p)).filter(Boolean);
    l.length > 0 && g(r, { updated: l });
  }, S = (i) => {
    const r = e.get(i);
    return r ? { ...r } : void 0;
  }, x = (i) => {
    const r = t.get(i);
    if (r) {
      const p = S(r).bodies.find((U) => U.id === i);
      if (p)
        return p;
      console.error(`Store integrity error: body ${i} in index, but not in annotation`);
    } else
      console.warn(`Attempt to retrieve missing body: ${i}`);
  }, k = (i, r) => {
    if (i.annotation !== r.annotation)
      throw "Annotation integrity violation: annotation ID must be the same when updating bodies";
    const l = e.get(i.annotation);
    if (l) {
      const p = l.bodies.find((y) => y.id === i.id), U = {
        ...l,
        bodies: l.bodies.map((y) => y.id === p.id ? r : y)
      };
      return e.set(l.id, U), p.id !== r.id && (t.delete(p.id), t.set(r.id, U.id)), {
        oldValue: l,
        newValue: U,
        bodiesUpdated: [{ oldBody: p, newBody: r }]
      };
    } else
      console.warn(`Attempt to add body to missing annotation ${i.annotation}`);
  }, Q = (i, r, l = O.LOCAL) => {
    const p = k(i, r);
    p && g(l, { updated: [p] });
  }, X = (i, r = O.LOCAL) => {
    const l = i.map((p) => k({ id: p.id, annotation: p.annotation }, p)).filter(Boolean);
    g(r, { updated: l });
  }, H = (i) => {
    const r = e.get(i.annotation);
    if (r) {
      const l = {
        ...r,
        target: {
          ...r.target,
          ...i
        }
      };
      return e.set(r.id, l), {
        oldValue: r,
        newValue: l,
        targetUpdated: {
          oldTarget: r.target,
          newTarget: i
        }
      };
    } else
      console.warn(`Attempt to update target on missing annotation: ${i.annotation}`);
  };
  return {
    addAnnotation: m,
    addBody: w,
    all: D,
    bulkAddAnnotations: A,
    bulkDeleteAnnotations: u,
    bulkDeleteBodies: d,
    bulkUpdateAnnotations: T,
    bulkUpdateBodies: X,
    bulkUpdateTargets: (i, r = O.LOCAL) => {
      const l = i.map((p) => H(p)).filter(Boolean);
      l.length > 0 && g(r, { updated: l });
    },
    bulkUpsertAnnotations: a,
    clear: C,
    deleteAnnotation: c,
    deleteBody: b,
    getAnnotation: S,
    getBody: x,
    observe: o,
    unobserve: s,
    updateAnnotation: E,
    updateBody: Q,
    updateTarget: (i, r = O.LOCAL) => {
      const l = H(i);
      l && g(r, { updated: [l] });
    },
    upsertAnnotation: h
  };
}, Ie = (e) => ({
  ...e,
  subscribe: (n) => {
    const o = (s) => n(s.state);
    return e.observe(o), n(e.all()), () => e.unobserve(o);
  }
});
let J = () => ({
  emit(e, ...t) {
    for (let n = this.events[e] || [], o = 0, s = n.length; o < s; o++)
      n[o](...t);
  },
  events: {},
  on(e, t) {
    var n;
    return ((n = this.events)[e] || (n[e] = [])).push(t), () => {
      var o;
      this.events[e] = (o = this.events[e]) == null ? void 0 : o.filter((s) => t !== s);
    };
  }
});
const pe = 250, Ne = (e, t) => {
  const n = J(), o = (t == null ? void 0 : t.changes) || [];
  let s = t ? t.pointer : -1, g = !1, m = 0;
  const v = (d) => {
    if (!g) {
      const { changes: S } = d, x = performance.now();
      if (x - m > pe)
        o.splice(s + 1), o.push(S), s = o.length - 1;
      else {
        const k = o.length - 1;
        o[k] = ue(o[k], S);
      }
      m = x;
    }
    g = !1;
  };
  e.observe(v, { origin: O.LOCAL });
  const E = (d) => d && d.length > 0 && e.bulkDeleteAnnotations(d), h = (d) => d && d.length > 0 && e.bulkAddAnnotations(d, !1), T = (d) => d && d.length > 0 && e.bulkUpdateAnnotations(d.map(({ oldValue: S }) => S)), a = (d) => d && d.length > 0 && e.bulkUpdateAnnotations(d.map(({ newValue: S }) => S)), w = (d) => d && d.length > 0 && e.bulkAddAnnotations(d, !1), D = (d) => d && d.length > 0 && e.bulkDeleteAnnotations(d);
  return {
    canRedo: () => o.length - 1 > s,
    canUndo: () => s > -1,
    destroy: () => e.unobserve(v),
    getHistory: () => ({ changes: [...o], pointer: s }),
    on: (d, S) => n.on(d, S),
    redo: () => {
      if (o.length - 1 > s) {
        g = !0;
        const { created: d, updated: S, deleted: x } = o[s + 1];
        h(d), a(S), D(x), n.emit("redo", o[s + 1]), s += 1;
      }
    },
    undo: () => {
      if (s > -1) {
        g = !0;
        const { created: d, updated: S, deleted: x } = o[s];
        E(d), T(S), w(x), n.emit("undo", o[s]), s -= 1;
      }
    }
  };
}, ze = () => {
  const { subscribe: e, set: t } = P([]);
  return {
    subscribe: e,
    set: t
  };
}, _e = (e, t, n, o) => {
  const { hover: s, selection: g, store: m, viewport: v } = e, E = /* @__PURE__ */ new Map();
  let h = [], T, a;
  const w = (c, u) => {
    E.has(c) ? E.get(c).push(u) : E.set(c, [u]);
  }, D = (c, u) => {
    const f = E.get(c);
    if (f) {
      const b = f.indexOf(u);
      b !== -1 && f.splice(b, 1);
    }
  }, C = (c, u, f) => {
    E.has(c) && setTimeout(() => {
      E.get(c).forEach((b) => {
        if (n) {
          const d = Array.isArray(u) ? u.map((x) => n.serialize(x)) : n.serialize(u), S = f ? f instanceof PointerEvent ? f : n.serialize(f) : void 0;
          b(d, S);
        } else
          b(u, f);
      });
    }, 1);
  }, A = () => {
    const { selected: c } = g, u = (c || []).map(({ id: f }) => m.getAnnotation(f));
    u.forEach((f) => {
      const b = h.find((d) => d.id === f.id);
      (!b || !N(b, f)) && C("updateAnnotation", f, b);
    }), h = h.map((f) => {
      const b = u.find(({ id: d }) => d === f.id);
      return b || f;
    });
  };
  g.subscribe(({ selected: c }) => {
    if (!(h.length === 0 && c.length === 0)) {
      if (h.length === 0 && c.length > 0)
        h = c.map(({ id: u }) => m.getAnnotation(u));
      else if (h.length > 0 && c.length === 0)
        h.forEach((u) => {
          const f = m.getAnnotation(u.id);
          f && !N(f, u) && C("updateAnnotation", f, u);
        }), h = [];
      else {
        const u = new Set(h.map((d) => d.id)), f = new Set(c.map(({ id: d }) => d));
        h.filter((d) => !f.has(d.id)).forEach((d) => {
          const S = m.getAnnotation(d.id);
          S && !N(S, d) && C("updateAnnotation", S, d);
        }), h = [
          // Remove annotations that were deselected
          ...h.filter((d) => f.has(d.id)),
          // Add editable annotations that were selected
          ...c.filter(({ id: d }) => !u.has(d)).map(({ id: d }) => m.getAnnotation(d))
        ];
      }
      C("selectionChanged", h);
    }
  }), s.subscribe((c) => {
    !T && c ? C("mouseEnterAnnotation", m.getAnnotation(c)) : T && !c ? C("mouseLeaveAnnotation", m.getAnnotation(T)) : T && c && (C("mouseLeaveAnnotation", m.getAnnotation(T)), C("mouseEnterAnnotation", m.getAnnotation(c))), T = c;
  }), v == null || v.subscribe((c) => C("viewportIntersect", c.map((u) => m.getAnnotation(u)))), m.observe((c) => {
    o && (a && clearTimeout(a), a = setTimeout(A, 1e3));
    const { created: u, deleted: f } = c.changes;
    (u || []).forEach((d) => C("createAnnotation", d)), (f || []).forEach((d) => C("deleteAnnotation", d)), (c.changes.updated || []).filter((d) => [
      ...d.bodiesCreated || [],
      ...d.bodiesDeleted || [],
      ...d.bodiesUpdated || []
    ].length > 0).forEach(({ oldValue: d, newValue: S }) => {
      const x = h.find((k) => k.id === d.id) || d;
      h = h.map((k) => k.id === d.id ? S : k), C("updateAnnotation", S, x);
    });
  }, { origin: O.LOCAL }), m.observe((c) => {
    if (h) {
      const u = new Set(h.map((b) => b.id)), f = (c.changes.updated || []).filter(({ newValue: b }) => u.has(b.id)).map(({ newValue: b }) => b);
      f.length > 0 && (h = h.map((b) => {
        const d = f.find((S) => S.id === b.id);
        return d || b;
      }));
    }
  }, { origin: O.REMOTE });
  const L = (c) => (u) => {
    const { updated: f } = u;
    c ? (f || []).forEach((b) => C("updateAnnotation", b.oldValue, b.newValue)) : (f || []).forEach((b) => C("updateAnnotation", b.newValue, b.oldValue));
  };
  return t.on("undo", L(!0)), t.on("redo", L(!1)), { on: w, off: D, emit: C };
}, $e = (e) => (t) => t.map((n) => e.serialize(n)), ge = (e) => (t) => t.reduce((n, o) => {
  const { parsed: s, error: g } = e.parse(o);
  return g ? {
    parsed: n.parsed,
    failed: [...n.failed, o]
  } : s ? {
    parsed: [...n.parsed, s],
    failed: n.failed
  } : {
    ...n
  };
}, { parsed: [], failed: [] }), Ve = (e, t, n) => {
  const { store: o, selection: s } = e, g = (c) => {
    if (n) {
      const { parsed: u, error: f } = n.parse(c);
      u ? o.addAnnotation(u, O.REMOTE) : console.error(f);
    } else
      o.addAnnotation(j(c), O.REMOTE);
  }, m = () => s.clear(), v = () => o.clear(), E = (c) => {
    const u = o.getAnnotation(c);
    return n && u ? n.serialize(u) : u;
  }, h = () => n ? o.all().map(n.serialize) : o.all(), T = () => {
    var f;
    const u = (((f = s.selected) == null ? void 0 : f.map((b) => b.id)) || []).map((b) => o.getAnnotation(b)).filter(Boolean);
    return n ? u.map(n.serialize) : u;
  }, a = (c, u = !0) => fetch(c).then((f) => f.json()).then((f) => (D(f, u), f)), w = (c) => {
    if (typeof c == "string") {
      const u = o.getAnnotation(c);
      if (o.deleteAnnotation(c), u)
        return n ? n.serialize(u) : u;
    } else {
      const u = n ? n.parse(c).parsed : c;
      if (u)
        return o.deleteAnnotation(u), c;
    }
  }, D = (c, u = !0) => {
    if (n) {
      const f = n.parseAll || ge(n), { parsed: b, failed: d } = f(c);
      d.length > 0 && console.warn(`Discarded ${d.length} invalid annotations`, d), o.bulkAddAnnotations(b, u, O.REMOTE);
    } else
      o.bulkAddAnnotations(c.map(j), u, O.REMOTE);
  }, C = (c, u) => {
    c ? s.setSelected(c, u) : s.clear();
  }, A = (c) => {
    s.setUserSelectAction(c);
  }, L = (c) => {
    if (n) {
      const u = n.parse(c).parsed, f = n.serialize(o.getAnnotation(u.id));
      return o.updateAnnotation(u), f;
    } else {
      const u = o.getAnnotation(c.id);
      return o.updateAnnotation(j(c)), u;
    }
  };
  return {
    addAnnotation: g,
    cancelSelected: m,
    canRedo: t.canRedo,
    canUndo: t.canUndo,
    clearAnnotations: v,
    getAnnotationById: E,
    getAnnotations: h,
    getHistory: t.getHistory,
    getSelected: T,
    loadAnnotations: a,
    redo: t.redo,
    removeAnnotation: w,
    setAnnotations: D,
    setSelected: C,
    setUserSelectAction: A,
    undo: t.undo,
    updateAnnotation: L
  };
}, Ye = (e, t, n) => typeof t == "function" ? t(e, n) : t, je = (e, t) => typeof e != "function" && typeof t != "function" ? {
  ...e || {},
  ...t || {}
} : (n, o) => {
  const s = typeof e == "function" ? e(n, o) : e, g = typeof t == "function" ? t(n, o) : t;
  return {
    ...s || {},
    ...g || {}
  };
}, he = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
let me = (e) => crypto.getRandomValues(new Uint8Array(e)), Ae = (e, t, n) => {
  let o = (2 << Math.log2(e.length - 1)) - 1, s = -~(1.6 * o * t / e.length);
  return (g = t) => {
    let m = "";
    for (; ; ) {
      let v = n(s), E = s | 0;
      for (; E--; )
        if (m += e[v[E] & o] || "", m.length >= g) return m;
    }
  };
}, be = (e, t = 21) => Ae(e, t | 0, me), ve = (e = 21) => {
  let t = "", n = crypto.getRandomValues(new Uint8Array(e |= 0));
  for (; e--; )
    t += he[n[e] & 63];
  return t;
};
const Pe = () => ({ isGuest: !0, id: be("1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_", 20)() }), Ee = (e) => {
  const t = JSON.stringify(e);
  let n = 0;
  for (let o = 0, s = t.length; o < s; o++) {
    let g = t.charCodeAt(o);
    n = (n << 5) - n + g, n |= 0;
  }
  return `${n}`;
}, we = (e) => e ? typeof e == "object" ? { ...e } : e : void 0, He = (e, t) => (Array.isArray(e) ? e : [e]).map((n) => {
  const { id: o, type: s, purpose: g, value: m, created: v, modified: E, creator: h, ...T } = n;
  return {
    id: o || `temp-${Ee(n)}`,
    annotation: t,
    type: s,
    purpose: g,
    value: m,
    creator: we(h),
    created: v ? new Date(v) : void 0,
    updated: E ? new Date(E) : void 0,
    ...T
  };
}), Me = (e) => e.map((t) => {
  var v;
  const { annotation: n, created: o, updated: s, ...g } = t, m = {
    ...g,
    created: o == null ? void 0 : o.toISOString(),
    modified: s == null ? void 0 : s.toISOString()
  };
  return (v = m.id) != null && v.startsWith("temp-") && delete m.id, m;
}), We = (e) => "@context" in e && "creator" in e && "body" in e, Ce = [
  "#ff7c00",
  // orange
  "#1ac938",
  // green
  "#e8000b",
  // red
  "#8b2be2",
  // purple
  "#9f4800",
  // brown
  "#f14cc1",
  // pink
  "#ffc400",
  // khaki
  "#00d7ff",
  // cyan
  "#023eff"
  // blue
], ye = () => {
  const e = [...Ce];
  return { assignRandomColor: () => {
    const o = Math.floor(Math.random() * e.length), s = e[o];
    return e.splice(o, 1), s;
  }, releaseColor: (o) => e.push(o) };
}, Le = () => {
  const e = ye();
  return { addUser: (o, s) => {
    const g = e.assignRandomColor();
    return {
      label: s.name || s.id,
      avatar: s.avatar,
      color: g
    };
  }, removeUser: (o) => e.releaseColor(o.appearance.color) };
}, Ue = (e, t) => e.every((n) => e.includes(n)) && t.every((n) => e.includes(n)), qe = ve(), Ge = (e = Le()) => {
  const t = J(), n = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map(), s = (a, w) => {
    if (n.has(a)) {
      console.warn("Attempt to add user that is already present", a, w);
      return;
    }
    const D = e.addUser(a, w);
    n.set(a, {
      ...w,
      presenceKey: a,
      appearance: D
    });
  }, g = (a) => {
    const w = n.get(a);
    if (!w) {
      console.warn("Attempt to remove user that is not present", a);
      return;
    }
    e.removeUser(w), n.delete(a);
  }, m = (a) => {
    const w = new Set(a.map((A) => A.presenceKey)), D = a.filter(({ presenceKey: A }) => !n.has(A)), C = Array.from(n.values()).filter((A) => !w.has(A.presenceKey));
    D.forEach(({ presenceKey: A, user: L }) => s(A, L)), C.forEach((A) => {
      const { presenceKey: L } = A;
      o.has(L) && t.emit("selectionChange", A, null), g(L);
    }), (D.length > 0 || C.length > 0) && t.emit("presence", h());
  }, v = (a, w) => {
    const D = n.get(a);
    if (!D) {
      console.warn("Activity notification from user that is not present");
      return;
    }
    const C = o.get(a);
    (!C || !Ue(C, w)) && (o.set(a, w), t.emit("selectionChange", D, w));
  }, E = (a, w) => {
    const D = n.get(a);
    if (!D) {
      console.warn("Selection change for user that is not present", a);
      return;
    }
    w ? o.set(a, w) : o.delete(a), t.emit("selectionChange", D, w);
  }, h = () => [...Array.from(n.values())];
  return {
    getPresentUsers: h,
    notifyActivity: v,
    on: (a, w) => t.on(a, w),
    syncUsers: m,
    updateSelection: E
  };
};
export {
  ae as Ignore,
  O as Origin,
  qe as PRESENCE_KEY,
  F as UserSelectAction,
  je as chainStyles,
  Ye as computeStyle,
  Pe as createAnonymousGuest,
  Ve as createBaseAnnotator,
  xe as createBody,
  Le as createDefaultAppearanceProvider,
  De as createHoverState,
  _e as createLifecycleObserver,
  Ge as createPresenceState,
  Be as createSelectionState,
  ke as createStore,
  Ne as createUndoStack,
  ze as createViewportState,
  ye as defaultColorProvider,
  G as diffAnnotations,
  Re as getContributors,
  We as isW3CAnnotation,
  ue as mergeChanges,
  K as onUserSelect,
  ge as parseAll,
  He as parseW3CBodies,
  we as parseW3CUser,
  j as reviveDates,
  $e as serializeAll,
  Me as serializeW3CBodies,
  le as shouldNotify,
  Ie as toSvelteStore
};
//# sourceMappingURL=annotorious-core.es.js.map
