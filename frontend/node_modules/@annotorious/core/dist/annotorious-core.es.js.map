{"version":3,"file":"annotorious-core.es.js","sources":["../../../node_modules/dequal/lite/index.mjs","../../../node_modules/svelte/src/runtime/internal/utils.js","../../../node_modules/svelte/src/runtime/store/index.js","../src/state/Hover.ts","../src/state/Selection.ts","../../../node_modules/uuid/dist/stringify.js","../../../node_modules/uuid/dist/rng.js","../../../node_modules/uuid/dist/native.js","../../../node_modules/uuid/dist/v4.js","../src/utils/annotationUtils.ts","../src/utils/diffAnnotations.ts","../src/state/StoreObserver.ts","../src/state/Store.ts","../src/state/SvelteStore.ts","../../../node_modules/nanoevents/index.js","../src/state/UndoStack.ts","../src/state/Viewport.ts","../src/lifecycle/Lifecycle.ts","../src/model/FormatAdapter.ts","../src/model/Annotator.ts","../src/model/DrawingStyle.ts","../../../node_modules/nanoid/url-alphabet/index.js","../../../node_modules/nanoid/index.browser.js","../src/model/User.ts","../src/model/W3CAnnotation.ts","../src/presence/ColorPalette.ts","../src/presence/AppearanceProvider.ts","../src/presence/PresenceState.ts"],"sourcesContent":["var has = Object.prototype.hasOwnProperty;\n\nexport function dequal(foo, bar) {\n\tvar ctor, len;\n\tif (foo === bar) return true;\n\n\tif (foo && bar && (ctor=foo.constructor) === bar.constructor) {\n\t\tif (ctor === Date) return foo.getTime() === bar.getTime();\n\t\tif (ctor === RegExp) return foo.toString() === bar.toString();\n\n\t\tif (ctor === Array) {\n\t\t\tif ((len=foo.length) === bar.length) {\n\t\t\t\twhile (len-- && dequal(foo[len], bar[len]));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (!ctor || typeof foo === 'object') {\n\t\t\tlen = 0;\n\t\t\tfor (ctor in foo) {\n\t\t\t\tif (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;\n\t\t\t\tif (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;\n\t\t\t}\n\t\t\treturn Object.keys(bar).length === len;\n\t\t}\n\t}\n\n\treturn foo !== foo && bar !== bar;\n}\n","/** @returns {void} */\nexport function noop() {}\n\nexport const identity = (x) => x;\n\n/**\n * @template T\n * @template S\n * @param {T} tar\n * @param {S} src\n * @returns {T & S}\n */\nexport function assign(tar, src) {\n\t// @ts-ignore\n\tfor (const k in src) tar[k] = src[k];\n\treturn /** @type {T & S} */ (tar);\n}\n\n// Adapted from https://github.com/then/is-promise/blob/master/index.js\n// Distributed under MIT License https://github.com/then/is-promise/blob/master/LICENSE\n/**\n * @param {any} value\n * @returns {value is PromiseLike<any>}\n */\nexport function is_promise(value) {\n\treturn (\n\t\t!!value &&\n\t\t(typeof value === 'object' || typeof value === 'function') &&\n\t\ttypeof (/** @type {any} */ (value).then) === 'function'\n\t);\n}\n\n/** @returns {void} */\nexport function add_location(element, file, line, column, char) {\n\telement.__svelte_meta = {\n\t\tloc: { file, line, column, char }\n\t};\n}\n\nexport function run(fn) {\n\treturn fn();\n}\n\nexport function blank_object() {\n\treturn Object.create(null);\n}\n\n/**\n * @param {Function[]} fns\n * @returns {void}\n */\nexport function run_all(fns) {\n\tfns.forEach(run);\n}\n\n/**\n * @param {any} thing\n * @returns {thing is Function}\n */\nexport function is_function(thing) {\n\treturn typeof thing === 'function';\n}\n\n/** @returns {boolean} */\nexport function safe_not_equal(a, b) {\n\treturn a != a ? b == b : a !== b || (a && typeof a === 'object') || typeof a === 'function';\n}\n\nlet src_url_equal_anchor;\n\n/**\n * @param {string} element_src\n * @param {string} url\n * @returns {boolean}\n */\nexport function src_url_equal(element_src, url) {\n\tif (element_src === url) return true;\n\tif (!src_url_equal_anchor) {\n\t\tsrc_url_equal_anchor = document.createElement('a');\n\t}\n\t// This is actually faster than doing URL(..).href\n\tsrc_url_equal_anchor.href = url;\n\treturn element_src === src_url_equal_anchor.href;\n}\n\n/** @param {string} srcset */\nfunction split_srcset(srcset) {\n\treturn srcset.split(',').map((src) => src.trim().split(' ').filter(Boolean));\n}\n\n/**\n * @param {HTMLSourceElement | HTMLImageElement} element_srcset\n * @param {string | undefined | null} srcset\n * @returns {boolean}\n */\nexport function srcset_url_equal(element_srcset, srcset) {\n\tconst element_urls = split_srcset(element_srcset.srcset);\n\tconst urls = split_srcset(srcset || '');\n\n\treturn (\n\t\turls.length === element_urls.length &&\n\t\turls.every(\n\t\t\t([url, width], i) =>\n\t\t\t\twidth === element_urls[i][1] &&\n\t\t\t\t// We need to test both ways because Vite will create an a full URL with\n\t\t\t\t// `new URL(asset, import.meta.url).href` for the client when `base: './'`, and the\n\t\t\t\t// relative URLs inside srcset are not automatically resolved to absolute URLs by\n\t\t\t\t// browsers (in contrast to img.src). This means both SSR and DOM code could\n\t\t\t\t// contain relative or absolute URLs.\n\t\t\t\t(src_url_equal(element_urls[i][0], url) || src_url_equal(url, element_urls[i][0]))\n\t\t)\n\t);\n}\n\n/** @returns {boolean} */\nexport function not_equal(a, b) {\n\treturn a != a ? b == b : a !== b;\n}\n\n/** @returns {boolean} */\nexport function is_empty(obj) {\n\treturn Object.keys(obj).length === 0;\n}\n\n/** @returns {void} */\nexport function validate_store(store, name) {\n\tif (store != null && typeof store.subscribe !== 'function') {\n\t\tthrow new Error(`'${name}' is not a store with a 'subscribe' method`);\n\t}\n}\n\nexport function subscribe(store, ...callbacks) {\n\tif (store == null) {\n\t\tfor (const callback of callbacks) {\n\t\t\tcallback(undefined);\n\t\t}\n\t\treturn noop;\n\t}\n\tconst unsub = store.subscribe(...callbacks);\n\treturn unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\n\n/**\n * Get the current value from a store by subscribing and immediately unsubscribing.\n *\n * https://svelte.dev/docs/svelte-store#get\n * @template T\n * @param {import('../store/public.js').Readable<T>} store\n * @returns {T}\n */\nexport function get_store_value(store) {\n\tlet value;\n\tsubscribe(store, (_) => (value = _))();\n\treturn value;\n}\n\n/** @returns {void} */\nexport function component_subscribe(component, store, callback) {\n\tcomponent.$$.on_destroy.push(subscribe(store, callback));\n}\n\nexport function create_slot(definition, ctx, $$scope, fn) {\n\tif (definition) {\n\t\tconst slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n\t\treturn definition[0](slot_ctx);\n\t}\n}\n\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n\treturn definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\n\nexport function get_slot_changes(definition, $$scope, dirty, fn) {\n\tif (definition[2] && fn) {\n\t\tconst lets = definition[2](fn(dirty));\n\t\tif ($$scope.dirty === undefined) {\n\t\t\treturn lets;\n\t\t}\n\t\tif (typeof lets === 'object') {\n\t\t\tconst merged = [];\n\t\t\tconst len = Math.max($$scope.dirty.length, lets.length);\n\t\t\tfor (let i = 0; i < len; i += 1) {\n\t\t\t\tmerged[i] = $$scope.dirty[i] | lets[i];\n\t\t\t}\n\t\t\treturn merged;\n\t\t}\n\t\treturn $$scope.dirty | lets;\n\t}\n\treturn $$scope.dirty;\n}\n\n/** @returns {void} */\nexport function update_slot_base(\n\tslot,\n\tslot_definition,\n\tctx,\n\t$$scope,\n\tslot_changes,\n\tget_slot_context_fn\n) {\n\tif (slot_changes) {\n\t\tconst slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n\t\tslot.p(slot_context, slot_changes);\n\t}\n}\n\n/** @returns {void} */\nexport function update_slot(\n\tslot,\n\tslot_definition,\n\tctx,\n\t$$scope,\n\tdirty,\n\tget_slot_changes_fn,\n\tget_slot_context_fn\n) {\n\tconst slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n\tupdate_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\n}\n\n/** @returns {any[] | -1} */\nexport function get_all_dirty_from_scope($$scope) {\n\tif ($$scope.ctx.length > 32) {\n\t\tconst dirty = [];\n\t\tconst length = $$scope.ctx.length / 32;\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tdirty[i] = -1;\n\t\t}\n\t\treturn dirty;\n\t}\n\treturn -1;\n}\n\n/** @returns {{}} */\nexport function exclude_internal_props(props) {\n\tconst result = {};\n\tfor (const k in props) if (k[0] !== '$') result[k] = props[k];\n\treturn result;\n}\n\n/** @returns {{}} */\nexport function compute_rest_props(props, keys) {\n\tconst rest = {};\n\tkeys = new Set(keys);\n\tfor (const k in props) if (!keys.has(k) && k[0] !== '$') rest[k] = props[k];\n\treturn rest;\n}\n\n/** @returns {{}} */\nexport function compute_slots(slots) {\n\tconst result = {};\n\tfor (const key in slots) {\n\t\tresult[key] = true;\n\t}\n\treturn result;\n}\n\n/** @returns {(this: any, ...args: any[]) => void} */\nexport function once(fn) {\n\tlet ran = false;\n\treturn function (...args) {\n\t\tif (ran) return;\n\t\tran = true;\n\t\tfn.call(this, ...args);\n\t};\n}\n\nexport function null_to_empty(value) {\n\treturn value == null ? '' : value;\n}\n\nexport function set_store_value(store, ret, value) {\n\tstore.set(value);\n\treturn ret;\n}\n\nexport const has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\n\nexport function action_destroyer(action_result) {\n\treturn action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\n/** @param {number | string} value\n * @returns {[number, string]}\n */\nexport function split_css_unit(value) {\n\tconst split = typeof value === 'string' && value.match(/^\\s*(-?[\\d.]+)([^\\s]*)\\s*$/);\n\treturn split ? [parseFloat(split[1]), split[2] || 'px'] : [/** @type {number} */ (value), 'px'];\n}\n\nexport const contenteditable_truthy_values = ['', true, 1, 'true', 'contenteditable'];\n","import {\n\trun_all,\n\tsubscribe,\n\tnoop,\n\tsafe_not_equal,\n\tis_function,\n\tget_store_value\n} from '../internal/index.js';\n\nconst subscriber_queue = [];\n\n/**\n * Creates a `Readable` store that allows reading by subscription.\n *\n * https://svelte.dev/docs/svelte-store#readable\n * @template T\n * @param {T} [value] initial value\n * @param {import('./public.js').StartStopNotifier<T>} [start]\n * @returns {import('./public.js').Readable<T>}\n */\nexport function readable(value, start) {\n\treturn {\n\t\tsubscribe: writable(value, start).subscribe\n\t};\n}\n\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n *\n * https://svelte.dev/docs/svelte-store#writable\n * @template T\n * @param {T} [value] initial value\n * @param {import('./public.js').StartStopNotifier<T>} [start]\n * @returns {import('./public.js').Writable<T>}\n */\nexport function writable(value, start = noop) {\n\t/** @type {import('./public.js').Unsubscriber} */\n\tlet stop;\n\t/** @type {Set<import('./private.js').SubscribeInvalidateTuple<T>>} */\n\tconst subscribers = new Set();\n\t/** @param {T} new_value\n\t * @returns {void}\n\t */\n\tfunction set(new_value) {\n\t\tif (safe_not_equal(value, new_value)) {\n\t\t\tvalue = new_value;\n\t\t\tif (stop) {\n\t\t\t\t// store is ready\n\t\t\t\tconst run_queue = !subscriber_queue.length;\n\t\t\t\tfor (const subscriber of subscribers) {\n\t\t\t\t\tsubscriber[1]();\n\t\t\t\t\tsubscriber_queue.push(subscriber, value);\n\t\t\t\t}\n\t\t\t\tif (run_queue) {\n\t\t\t\t\tfor (let i = 0; i < subscriber_queue.length; i += 2) {\n\t\t\t\t\t\tsubscriber_queue[i][0](subscriber_queue[i + 1]);\n\t\t\t\t\t}\n\t\t\t\t\tsubscriber_queue.length = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {import('./public.js').Updater<T>} fn\n\t * @returns {void}\n\t */\n\tfunction update(fn) {\n\t\tset(fn(value));\n\t}\n\n\t/**\n\t * @param {import('./public.js').Subscriber<T>} run\n\t * @param {import('./private.js').Invalidator<T>} [invalidate]\n\t * @returns {import('./public.js').Unsubscriber}\n\t */\n\tfunction subscribe(run, invalidate = noop) {\n\t\t/** @type {import('./private.js').SubscribeInvalidateTuple<T>} */\n\t\tconst subscriber = [run, invalidate];\n\t\tsubscribers.add(subscriber);\n\t\tif (subscribers.size === 1) {\n\t\t\tstop = start(set, update) || noop;\n\t\t}\n\t\trun(value);\n\t\treturn () => {\n\t\t\tsubscribers.delete(subscriber);\n\t\t\tif (subscribers.size === 0 && stop) {\n\t\t\t\tstop();\n\t\t\t\tstop = null;\n\t\t\t}\n\t\t};\n\t}\n\treturn { set, update, subscribe };\n}\n\n/**\n * Derived value store by synchronizing one or more readable stores and\n * applying an aggregation function over its input values.\n *\n * https://svelte.dev/docs/svelte-store#derived\n * @template {import('./private.js').Stores} S\n * @template T\n * @overload\n * @param {S} stores - input stores\n * @param {(values: import('./private.js').StoresValues<S>, set: (value: T) => void, update: (fn: import('./public.js').Updater<T>) => void) => import('./public.js').Unsubscriber | void} fn - function callback that aggregates the values\n * @param {T} [initial_value] - initial value\n * @returns {import('./public.js').Readable<T>}\n */\n\n/**\n * Derived value store by synchronizing one or more readable stores and\n * applying an aggregation function over its input values.\n *\n * https://svelte.dev/docs/svelte-store#derived\n * @template {import('./private.js').Stores} S\n * @template T\n * @overload\n * @param {S} stores - input stores\n * @param {(values: import('./private.js').StoresValues<S>) => T} fn - function callback that aggregates the values\n * @param {T} [initial_value] - initial value\n * @returns {import('./public.js').Readable<T>}\n */\n\n/**\n * @template {import('./private.js').Stores} S\n * @template T\n * @param {S} stores\n * @param {Function} fn\n * @param {T} [initial_value]\n * @returns {import('./public.js').Readable<T>}\n */\nexport function derived(stores, fn, initial_value) {\n\tconst single = !Array.isArray(stores);\n\t/** @type {Array<import('./public.js').Readable<any>>} */\n\tconst stores_array = single ? [stores] : stores;\n\tif (!stores_array.every(Boolean)) {\n\t\tthrow new Error('derived() expects stores as input, got a falsy value');\n\t}\n\tconst auto = fn.length < 2;\n\treturn readable(initial_value, (set, update) => {\n\t\tlet started = false;\n\t\tconst values = [];\n\t\tlet pending = 0;\n\t\tlet cleanup = noop;\n\t\tconst sync = () => {\n\t\t\tif (pending) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcleanup();\n\t\t\tconst result = fn(single ? values[0] : values, set, update);\n\t\t\tif (auto) {\n\t\t\t\tset(result);\n\t\t\t} else {\n\t\t\t\tcleanup = is_function(result) ? result : noop;\n\t\t\t}\n\t\t};\n\t\tconst unsubscribers = stores_array.map((store, i) =>\n\t\t\tsubscribe(\n\t\t\t\tstore,\n\t\t\t\t(value) => {\n\t\t\t\t\tvalues[i] = value;\n\t\t\t\t\tpending &= ~(1 << i);\n\t\t\t\t\tif (started) {\n\t\t\t\t\t\tsync();\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t() => {\n\t\t\t\t\tpending |= 1 << i;\n\t\t\t\t}\n\t\t\t)\n\t\t);\n\t\tstarted = true;\n\t\tsync();\n\t\treturn function stop() {\n\t\t\trun_all(unsubscribers);\n\t\t\tcleanup();\n\t\t\t// We need to set this to false because callbacks can still happen despite having unsubscribed:\n\t\t\t// Callbacks might already be placed in the queue which doesn't know it should no longer\n\t\t\t// invoke this derived store.\n\t\t\tstarted = false;\n\t\t};\n\t});\n}\n\n/**\n * Takes a store and returns a new one derived from the old one that is readable.\n *\n * https://svelte.dev/docs/svelte-store#readonly\n * @template T\n * @param {import('./public.js').Readable<T>} store  - store to make readonly\n * @returns {import('./public.js').Readable<T>}\n */\nexport function readonly(store) {\n\treturn {\n\t\tsubscribe: store.subscribe.bind(store)\n\t};\n}\n\nexport { get_store_value as get };\n","import { writable } from 'svelte/store';\nimport type { Annotation } from '../model';\nimport type { Store } from './Store';\n\nexport type HoverState<T extends Annotation> = ReturnType<typeof createHoverState<T>>;\n\nexport const createHoverState = <T extends Annotation>(store: Store<T>) => {\n\n  const { subscribe, set } = writable<string | undefined>();\n\n  let currentHover: string | undefined;\n\n  subscribe(updated => currentHover = updated);\n\n  // Track store delete and update events\n  store.observe(( { changes }) => {    \n    if (currentHover) {\n      const isDeleted = (changes.deleted || []).some(a => a.id === currentHover);\n      if (isDeleted)\n        set(undefined);\n    \n      const updated = (changes.updated || []).find(({ oldValue }) => oldValue.id === currentHover);\n      if (updated)\n        set(updated.newValue.id);\n    }\n  });\n\n  return { \n    get current() { return currentHover },\n    subscribe, \n    set \n  };\n\n}\n","import { writable } from 'svelte/store';\nimport { dequal } from 'dequal/lite';\nimport type { Annotation, FormatAdapter } from '../model';\nimport type { Store } from './Store';\n\nexport interface Selection {\n\n  selected: { id: string, editable?: boolean }[],\n\n  event?: PointerEvent | KeyboardEvent;\n\n}\n\nexport type SelectionState<I extends Annotation, E extends unknown> = ReturnType<typeof createSelectionState<I, E>>;\n\nexport enum UserSelectAction {\n\n  EDIT = 'EDIT', // Make annotation target(s) editable on pointer select\n\n  SELECT = 'SELECT',  // Just select, but don't make editable\n\n  NONE = 'NONE' // Click won't select - the annotation is completely inert\n\n}\n\nexport type UserSelectActionExpression<T extends unknown> = UserSelectAction | ((a: T) => UserSelectAction);\n\nconst EMPTY: Selection = { selected: [] };\n\nexport const createSelectionState = <I extends Annotation, E extends unknown>(\n  store: Store<I>,\n  defaultSelectionAction?: UserSelectActionExpression<E>,\n  adapter?: FormatAdapter<I, E>\n) => {\n  const { subscribe, set } = writable<Selection>(EMPTY);\n\n  let currentUserSelectAction = defaultSelectionAction;\n\n  let currentSelection: Selection = EMPTY;\n\n  subscribe(updated => currentSelection = updated);\n\n  const clear = () => {\n    if (!dequal(currentSelection, EMPTY)) {\n      set(EMPTY);\n    }\n  };\n\n  const isEmpty = () => currentSelection.selected?.length === 0;\n\n  const isSelected = (annotationOrId: I | string) => {\n    if (isEmpty())\n      return false;\n\n    const id = typeof annotationOrId === 'string' ? annotationOrId : annotationOrId.id;\n    return currentSelection.selected.some(i => i.id === id);\n  }\n\n  const userSelect = (idOrIds: string | string[], event?: Selection['event']) => {\n    let annotations: I[];\n\n    if (Array.isArray(idOrIds)) {\n      annotations = idOrIds.map(id => store.getAnnotation(id)!).filter(Boolean);\n\n      if (annotations.length < idOrIds.length) {\n        console.warn('Invalid selection: ' + idOrIds.filter(id => !annotations.some(a => a.id === id)));\n        return;\n      }\n    } else {\n      const annotation = store.getAnnotation(idOrIds);\n      if (!annotation) {\n        console.warn('Invalid selection: ' + idOrIds);\n        return;\n      }\n\n      annotations = [annotation];\n    }\n\n    const selected = annotations.reduce<{ id: string, editable?: boolean }[]>((sel, a) => {\n      const action = evalSelectAction(a);\n      if (action === UserSelectAction.EDIT)\n        return [...sel, { id: a.id, editable: true }];\n      else if (action === UserSelectAction.SELECT) \n        return [...sel, { id: a.id }];\n      else\n        return sel;\n    }, []);\n\n    set({ selected, event });\n  }\n\n  const setSelected = (idOrIds: string | string[], editable?: boolean) => {\n    const ids = Array.isArray(idOrIds) ? idOrIds : [idOrIds];\n\n    // Remove invalid\n    const annotations = ids\n      .map(id => store.getAnnotation(id))\n      .filter((a): a is I => Boolean(a));\n\n    set({\n      selected: annotations.map(annotation => {\n\n        // If editable isn't set, use the default behavior\n        const isEditable = editable === undefined\n          ? evalSelectAction(annotation) === UserSelectAction.EDIT\n          : editable;\n\n        return { id: annotation.id, editable: isEditable }\n      })\n    });\n\n    if (annotations.length !== ids.length)\n      console.warn('Invalid selection', idOrIds);\n  }\n\n  const removeFromSelection = (ids: string[]) => {\n    if (isEmpty())\n      return false;\n\n    const { selected } = currentSelection;\n\n    // Checks which of the given annotations are actually in the selection\n    const shouldRemove = selected.some(({ id }) => ids.includes(id));\n    if (shouldRemove)\n      set({ selected: selected.filter(({ id }) => !ids.includes(id)) });\n  }\n\n  const setUserSelectAction = (action: UserSelectActionExpression<E> | undefined) => {\n    currentUserSelectAction = action;\n    setSelected(currentSelection.selected.map(({ id }) => id));\n  };\n\n  // Utility to evaluate what the select action will be for the given annotation\n  const evalSelectAction = (annotation: I) =>\n    onUserSelect(annotation, currentUserSelectAction, adapter)\n\n  // Track store delete and update events\n  store.observe(\n    ({ changes }) => removeFromSelection((changes.deleted || []).map(a => a.id))\n  );\n\n  return {\n    get event() {\n      return currentSelection ? currentSelection.event : null;\n    },\n    get selected() {\n      return currentSelection ? [...currentSelection.selected] : null;\n    },\n    get userSelectAction() {\n      return currentUserSelectAction;\n    },\n    clear,\n    evalSelectAction,\n    isEmpty,\n    isSelected,\n    setSelected,\n    setUserSelectAction,\n    subscribe,\n    userSelect\n  };\n\n}\n\nexport const onUserSelect = <I extends Annotation, E extends unknown>(\n  annotation: I,\n  action?: UserSelectActionExpression<E>,\n  adapter?: FormatAdapter<I, E>\n): UserSelectAction => {\n  const crosswalked = adapter ? adapter.serialize(annotation) : annotation as unknown as E;\n  return (typeof action === 'function') ? action(crosswalked) : (action || UserSelectAction.EDIT)\n}\n","import validate from './validate.js';\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n    byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nexport function unsafeStringify(arr, offset = 0) {\n    return (byteToHex[arr[offset + 0]] +\n        byteToHex[arr[offset + 1]] +\n        byteToHex[arr[offset + 2]] +\n        byteToHex[arr[offset + 3]] +\n        '-' +\n        byteToHex[arr[offset + 4]] +\n        byteToHex[arr[offset + 5]] +\n        '-' +\n        byteToHex[arr[offset + 6]] +\n        byteToHex[arr[offset + 7]] +\n        '-' +\n        byteToHex[arr[offset + 8]] +\n        byteToHex[arr[offset + 9]] +\n        '-' +\n        byteToHex[arr[offset + 10]] +\n        byteToHex[arr[offset + 11]] +\n        byteToHex[arr[offset + 12]] +\n        byteToHex[arr[offset + 13]] +\n        byteToHex[arr[offset + 14]] +\n        byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n    const uuid = unsafeStringify(arr, offset);\n    if (!validate(uuid)) {\n        throw TypeError('Stringified UUID is invalid');\n    }\n    return uuid;\n}\nexport default stringify;\n","let getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n    if (!getRandomValues) {\n        if (typeof crypto === 'undefined' || !crypto.getRandomValues) {\n            throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n        }\n        getRandomValues = crypto.getRandomValues.bind(crypto);\n    }\n    return getRandomValues(rnds8);\n}\n","const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default { randomUUID };\n","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\nfunction _v4(options, buf, offset) {\n    options = options || {};\n    const rnds = options.random ?? options.rng?.() ?? rng();\n    if (rnds.length < 16) {\n        throw new Error('Random bytes length must be >= 16');\n    }\n    rnds[6] = (rnds[6] & 0x0f) | 0x40;\n    rnds[8] = (rnds[8] & 0x3f) | 0x80;\n    if (buf) {\n        offset = offset || 0;\n        if (offset < 0 || offset + 16 > buf.length) {\n            throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);\n        }\n        for (let i = 0; i < 16; ++i) {\n            buf[offset + i] = rnds[i];\n        }\n        return buf;\n    }\n    return unsafeStringify(rnds);\n}\nfunction v4(options, buf, offset) {\n    if (native.randomUUID && !buf && !options) {\n        return native.randomUUID();\n    }\n    return _v4(options, buf, offset);\n}\nexport default v4;\n","import { v4 as uuidv4 } from 'uuid';\nimport type { Annotation, AnnotationBody } from '../model/Annotation';\nimport type {  User } from '../model/User';\n\n/**\n * Returns all users listed as creators or updaters in any parts of this\n * annotation.\n */\nexport const getContributors = (annotation: Annotation): User[] => {\n  const { creator, updatedBy } = annotation.target;\n\n  const bodyCollaborators = annotation.bodies.reduce((users, body) =>  (\n    [...users, body.creator, body.updatedBy].filter(Boolean) as User[]\n  ), [] as User[]);\n\n  return [\n    creator,\n    updatedBy,\n    ...bodyCollaborators\n  ].filter(u => u) as User[] // Remove undefined\n}\n\ntype HasTime = { created?: string | Date; updated?: string | Date; };\n\n/** \n * Converts any string dates in the given annotation(-like) \n * object to proper Date objects.\n */\nexport const reviveDates = <A extends Annotation = Annotation>(annotation: any): A => {\n  const revive = <T extends HasTime>(body: T): T => {\n    const revived = {...body};\n\n    if (body.created && typeof body.created === 'string')\n      revived.created = new Date(body.created);\n\n    if (body.updated && typeof body.updated === 'string')\n      revived.updated = new Date(body.updated);\n\n    return revived;\n  }\n\n  return {\n    ...annotation,\n    bodies: (annotation.bodies || []).map(revive),\n    target: revive(annotation.target)\n  } as A;\n}\n\n/**\n * Shorthand/helper.\n */\nexport const createBody = (\n  annotationOrId: string | Annotation, \n  payload: { [key: string]: any },\n  created?: Date,\n  creator?: User\n): AnnotationBody => ({\n  id: uuidv4(),\n  annotation: typeof annotationOrId === 'string' ? annotationOrId : annotationOrId.id,\n  created: created || new Date(),\n  creator,\n  ...payload\n});","import { dequal } from 'dequal/lite';\nimport type { Update } from '../state/StoreObserver';\nimport type { Annotation } from '../model/Annotation';\n\nconst getAddedBodies = (oldValue: Annotation, newValue: Annotation) => {\n  const oldBodyIds = new Set(oldValue.bodies.map(b => b.id));\n  return newValue.bodies.filter(b => !oldBodyIds.has(b.id));\n}\n\nconst getRemovedBodies = (oldValue: Annotation, newValue: Annotation) => {\n  const newBodyIds = new Set(newValue.bodies.map(b => b.id));\n  return oldValue.bodies.filter(b => !newBodyIds.has(b.id));\n}\n\nconst getChangedBodies = (oldValue: Annotation, newValue: Annotation) => \n  newValue.bodies\n    .map(newBody => {\n      const oldBody = oldValue.bodies.find(b => b.id === newBody.id);\n      return { newBody, oldBody: oldBody && !dequal(oldBody, newBody) ? oldBody : undefined }\n    })\n    .filter(({ oldBody }) => oldBody)\n    .map(({ oldBody, newBody }) => ({ oldBody: oldBody!, newBody }));\n\nconst hasTargetChanged = (oldValue: Annotation, newValue: Annotation) => \n  !dequal(oldValue.target, newValue.target);\n\nexport const diffAnnotations = <T extends Annotation = Annotation>(oldValue: T, newValue: T): Update<T> => {\n  const bodiesCreated = getAddedBodies(oldValue, newValue);\n  const bodiesDeleted = getRemovedBodies(oldValue, newValue);\n  const bodiesUpdated = getChangedBodies(oldValue, newValue);\n\n  return {\n    oldValue, \n    newValue,\n    bodiesCreated: bodiesCreated.length > 0 ? bodiesCreated : undefined,\n    bodiesDeleted: bodiesDeleted.length > 0 ? bodiesDeleted : undefined,\n    bodiesUpdated: bodiesUpdated.length > 0 ? bodiesUpdated : undefined,\n    targetUpdated: hasTargetChanged(oldValue, newValue) ? { oldTarget: oldValue.target, newTarget: newValue.target } : undefined\n  }\n}","import type { Annotation, AnnotationBody, AnnotationTarget } from '../model/Annotation';\nimport { diffAnnotations } from '../utils';\n\n/** Interface for listening to changes in the annotation store **/\nexport interface StoreObserver<T extends Annotation> { \n\n  onChange: { (event: StoreChangeEvent<T>): void };\n\n  options: StoreObserveOptions;\n\n}\n\n/** A change event fired when the store state changes **/\nexport interface StoreChangeEvent<T extends Annotation> {\n\n  origin: Origin;\n\n  changes: ChangeSet<T>;\n\n  state: T[];\n\n}\n\nexport interface ChangeSet<T extends Annotation> {\n\n  created?: T[];\n\n  deleted?: T[];\n\n  updated?: Update<T>[];\n\n}\n\nexport interface Update<T extends Annotation> {\n\n  oldValue: T;\n\n  newValue: T;\n\n  bodiesCreated?: T['bodies'];\n\n  bodiesDeleted?: T['bodies'];\n\n  bodiesUpdated?: Array<{ oldBody: T['bodies'][number], newBody: T['bodies'][number] }>;\n\n  targetUpdated?: { oldTarget: T['target'], newTarget: T['target'] };\n\n}\n\n/** Options to control which events the observer wants to get notified about **/\nexport interface StoreObserveOptions {\n\n  // Observe changes on targets, bodies or both?\n  ignore?: Ignore;\n\n  // Observe changes on one more specific annotations\n  annotations?: string | string[];\n\n  // Observer changes only for a specific origin\n  origin?: Origin\n\n}\n\n/** Allows the observer to ignore certain event types **/\nexport enum Ignore { \n\n  // Don't notify this observer for changes that involve bodies only\n  BODY_ONLY = 'BODY_ONLY',\n\n  // Don't notify for changes on targets only\n  TARGET_ONLY = 'TARGET_ONLY'\n\n}\n\n/** \n * Allows the observer to listen only for events that originated locally or from a remote source.\n * \n * SILENT should be used for updates that are not supposed to trigger an event. Remember that \n * with great power comes great responsibility: SILENT is really for Annotorious plugins and\n * extensions ONLY.\n */\nexport enum Origin { \n  \n  LOCAL = 'LOCAL', \n  \n  REMOTE = 'REMOTE',\n  \n  SILENT = 'SILENT'\n\n}\n\n/** Tests if this observer should be notified about this event **/\nexport const shouldNotify = <T extends Annotation>(observer: StoreObserver<T>, event: StoreChangeEvent<T>) => {\n  const { changes, origin } = event;\n\n  const isRelevantOrigin = observer.options.origin \n    ? observer.options.origin === origin \n    : origin !== Origin.SILENT;\n\n  if (!isRelevantOrigin)\n    return false;\n\n  if (observer.options.ignore) {\n    const { ignore } = observer.options;\n\n    // Shorthand\n    const has = (arg: any[] | undefined) => arg && arg.length > 0;\n\n    const hasAnnotationChanges =\n      has(changes.created) || has(changes.deleted);\n\n    if (!hasAnnotationChanges) {\n      const hasBodyChanges =\n        changes.updated?.some(u => has(u.bodiesCreated) || has(u.bodiesDeleted) || has(u.bodiesUpdated));\n    \n      const hasTargetChanges = \n        changes.updated?.some(u => u.targetUpdated);\n\n      if (ignore === Ignore.BODY_ONLY && hasBodyChanges && !hasTargetChanges)\n        return false;\n\n      if (ignore === Ignore.TARGET_ONLY && hasTargetChanges && !hasBodyChanges)\n        return false;\n    }\n  }\n\n  if (observer.options.annotations) {\n    // This observer has a filter set on specific annotations - check affected\n    const affectedAnnotations = new Set([\n      ...(changes.created || []).map(a => a.id),\n      ...(changes.deleted || []).map(a => a.id),\n      ...(changes.updated || []).map(({ oldValue }) => oldValue.id)\n    ]);\n\n    const observed = Array.isArray(observer.options.annotations) ?\n      observer.options.annotations : [ observer.options.annotations ];\n\n    return Boolean(observed.find(id => affectedAnnotations.has(id)));\n  } else {\n    return true;\n  }\n\n}\n\nexport const mergeChanges = <T extends Annotation>(changes: ChangeSet<T>, toMerge: ChangeSet<T>) => {\n  const previouslyCreatedIds = new Set((changes.created || []).map(a => a.id));\n  const previouslyUpdatedIds = new Set((changes.updated || []).map(({ newValue })=> newValue.id));\n\n  const createdIds = new Set((toMerge.created || []).map(a => a.id));\n  const deletedIds = new Set((toMerge.deleted || []).map(a => a.id));\n  const updatedIds = new Set((toMerge.updated || []).map(({ oldValue }) => oldValue.id));\n\n  // Updates that will be merged into create or previous update events\n  const mergeableUpdates = new Set((toMerge.updated || [])\n    .filter(({ oldValue }) => previouslyCreatedIds.has(oldValue.id) || previouslyUpdatedIds.has(oldValue.id))\n    .map(({ oldValue }) => oldValue.id ));\n\n  // * created *\n  // - drop created that were then deleted\n  // - merge any updates on created\n  // - append newly created\n  const created = [\n    ...(changes.created || [])\n      .filter(a => !deletedIds.has(a.id))\n      .map(a => updatedIds.has(a.id) \n        ? toMerge.updated!.find(({ oldValue }) => oldValue.id === a.id)!.newValue\n        : a),\n    ...(toMerge.created || [])\n  ];\n\n  // * deleted *\n  // - drop deleted that were later re-created (redo action!)\n  // - append newly deleted, but remove any that delete annotations \n  //   that were created in the same round\n  const deleted = [\n    ...(changes.deleted || [])\n      .filter(a => !createdIds.has(a.id)),\n    ...(toMerge.deleted || []) \n      .filter(a => !previouslyCreatedIds.has(a.id))\n  ] \n\n  // * updated *\n  // - drop updates on deleted annotations\n  // - merge any updates that override previous ones\n  // - append new updates, but remove any that were merged\n  const updated = [\n    ...(changes.updated || [])\n      .filter(({ newValue }) => !deletedIds.has(newValue.id))\n      .map(update => {\n        const { oldValue, newValue } = update;\n        if (updatedIds.has(newValue.id)) {\n          const updated = toMerge.updated!.find(u => u.oldValue.id === newValue.id)!.newValue;\n          return diffAnnotations(oldValue, updated);\n        } else {\n          return update;\n        }\n      }),\n    ...(toMerge.updated || []).filter(({ oldValue }) => !mergeableUpdates.has(oldValue.id))\n  ]\n\n  return { created, deleted, updated };\n}\n","import { v4 as uuidv4 } from 'uuid';\nimport type { Annotation } from '../model';\nimport { diffAnnotations } from '../utils';\nimport { Origin, shouldNotify, type Update, type ChangeSet } from './StoreObserver';\nimport type { StoreObserver, StoreChangeEvent, StoreObserveOptions } from './StoreObserver';\n\n// Shorthand\ntype AnnotationBodyIdentifier = { id: string, annotation: string }; \n\nconst sanitize = <T extends Annotation>(a: Partial<T>): T => {\n  const id = a.id === undefined ? uuidv4() : a.id;\n\n  return {\n    ...a,\n    id,\n    bodies: a.bodies === undefined ? [] : a.bodies.map(b => ({\n      ...b,\n      annotation: id \n    })),\n    target: {\n      ...a.target,\n      annotation: id\n    }\n  } as T;\n}\n\nexport type Store<T extends Annotation> = ReturnType<typeof createStore<T>>;\n\nconst isAnnotation = <T extends Annotation>(arg: any): arg is T => arg.id !== undefined;\n\nexport const createStore = <T extends Annotation>() => {\n\n  const annotationIndex = new Map<string, T>();\n\n  const bodyIndex = new Map<string, string>();\n\n  const observers: StoreObserver<T>[] = [];\n\n  const observe = (onChange: { (event: StoreChangeEvent<T>): void }, options: StoreObserveOptions = {}) => {\n    observers.push({ onChange, options });\n  }\n\n  const unobserve = (onChange: { (event: StoreChangeEvent<T>): void }) => {\n    const idx = observers.findIndex(observer => observer.onChange == onChange);\n    if (idx > -1)\n      observers.splice(idx, 1);\n  }\n\n  const emit = (origin: Origin, changes: ChangeSet<T>) => {\n    const event: StoreChangeEvent<T> = {\n      origin,\n      changes: {\n        created: changes.created || [],\n        updated: changes.updated || [],\n        deleted: changes.deleted || []\n      },\n      state: [...annotationIndex.values()]\n    };\n\n    observers.forEach(observer => {\n      if (shouldNotify(observer, event))\n        observer.onChange(event);\n    });\n  }\n\n  const addAnnotation = (annotation: Partial<T>, origin = Origin.LOCAL) => {\n    const existing = annotation.id && annotationIndex.get(annotation.id);\n\n    if (existing) {\n      throw Error(`Cannot add annotation ${annotation.id} - exists already`);\n    } else {\n      const sanitized = sanitize(annotation);\n\n      annotationIndex.set(sanitized.id, sanitized);\n      sanitized.bodies.forEach(b => bodyIndex.set(b.id, sanitized.id));\n      emit(origin, { created: [sanitized] });\n    }\n  }\n\n  const updateOneAnnotation = (arg1: string | Partial<T>, arg2?: Partial<T> | Origin) => {\n    const updated: T = typeof arg1 === 'string' ? sanitize(arg2 as Partial<T>) : sanitize(arg1);\n\n    const oldId: string | undefined = typeof arg1 === 'string' ? arg1 : arg1.id;\n    const oldValue = oldId && annotationIndex.get(oldId);\n\n    if (oldValue) {\n      const update: Update<T> = diffAnnotations(oldValue, updated);\n\n      if (oldId === updated.id) {\n        annotationIndex.set(oldId, updated);\n      } else {\n        annotationIndex.delete(oldId);\n        annotationIndex.set(updated.id, updated);\n      }\n\n      oldValue.bodies.forEach(b => bodyIndex.delete(b.id));\n      updated.bodies.forEach(b => bodyIndex.set(b.id, updated.id));\n\n      return update;\n    } else {\n      console.warn(`Cannot update annotation ${oldId} - does not exist`);\n    }\n  }\n  \n  const updateAnnotation = (arg1: string | T, arg2: T | Origin = Origin.LOCAL, arg3 = Origin.LOCAL) => {\n    const origin: Origin = isAnnotation(arg2) ? arg3 : arg2;\n\n    const update = updateOneAnnotation(arg1, arg2);\n    if (update)\n      emit(origin, { updated: [update] })\n  }\n\n  const upsertAnnotation = (annotation: T, origin = Origin.LOCAL) => {\n    const exists = Boolean(annotationIndex.get(annotation.id));\n    if (exists) {\n      updateAnnotation(annotation, origin);\n    } else {\n      addAnnotation(annotation, origin);\n    }\n  }\n\n  const bulkUpdateAnnotations = (annotations: T[], origin = Origin.LOCAL) => {\n    const updated = annotations.reduce((updated, annotation) => {\n      const u = updateOneAnnotation(annotation);\n      return u ? [...updated, u] : updated;\n    }, [] as Update<T>[]);\n\n    if (updated.length > 0)\n      emit(origin, { updated });\n  }\n\n  const bulkUpsertAnnotations = (annotations: Partial<T>[], origin = Origin.LOCAL) => {\n    const sanitized = annotations.map(sanitize);\n\n    const { toAdd, toUpdate } = sanitized.reduce<{ toAdd: T[], toUpdate: T[] }>((agg, annotation) => {\n      const exists = Boolean(annotationIndex.get(annotation.id));\n      if (exists) {\n        return {...agg, toUpdate: [...agg.toUpdate, annotation]};\n      } else {\n        return {...agg, toAdd: [...agg.toAdd, annotation]}\n      }\n    }, { toAdd: [], toUpdate: [] });\n\n    const updated = toUpdate.map(a => updateOneAnnotation(a, origin)!).filter(Boolean);\n\n    toAdd.forEach(annotation => {\n      annotationIndex.set(annotation.id, annotation);\n      annotation.bodies.forEach(b => bodyIndex.set(b.id, annotation.id));\n    });\n\n    emit(origin, { created: toAdd, updated });\n  }\n\n  const addBody = (body: T['bodies'][number], origin = Origin.LOCAL) => {\n    const oldValue = annotationIndex.get(body.annotation);\n    if (oldValue) {\n      const newValue = { \n        ...oldValue,\n        bodies: [ ...oldValue.bodies, body ]\n      };\n\n      annotationIndex.set(oldValue.id, newValue);\n\n      bodyIndex.set(body.id, newValue.id);\n\n      const update: Update<T> = {\n        oldValue, newValue, bodiesCreated: [ body ]\n      };\n\n      emit(origin, { updated: [update] });\n    } else {\n      console.warn(`Attempt to add body to missing annotation: ${body.annotation}`);\n    }\n  }\n\n  const all = () => [...annotationIndex.values()];\n\n  const clear = (origin = Origin.LOCAL) => { \n    const all = [...annotationIndex.values()];\n\n    annotationIndex.clear();\n    bodyIndex.clear();\n\n    emit(origin, { deleted: all });\n  }\n\n  const bulkAddAnnotations = (annotations: Partial<T>[], replace = true, origin = Origin.LOCAL) => {\n    const sanitized = annotations.map(sanitize);\n\n    if (replace) {\n      // Delete existing first\n      const deleted = [...annotationIndex.values()];\n      annotationIndex.clear();\n      bodyIndex.clear();\n\n      sanitized.forEach(annotation => {\n        annotationIndex.set(annotation.id, annotation);\n        annotation.bodies.forEach(b => bodyIndex.set(b.id, annotation.id));\n      });\n\n      emit(origin, { created: sanitized, deleted });\n    } else {\n      // Don't allow overwriting of existing annotations\n      const existing = annotations.reduce((all, next) => {\n        const existing = next.id && annotationIndex.get(next.id);\n        return existing ? [...all, existing ] : all;\n      }, [] as T[]);\n\n      if (existing.length > 0)\n        throw Error(`Bulk insert would overwrite the following annotations: ${existing.map(a => a.id).join(', ')}`);\n\n      sanitized.forEach(annotation => {\n        annotationIndex.set(annotation.id, annotation);\n        annotation.bodies.forEach(b => bodyIndex.set(b.id, annotation.id));\n      });\n\n      emit(origin, { created: sanitized });\n    }\n  }\n\n  const deleteOneAnnotation = (annotationOrId: T | string) => {\n    const id = typeof annotationOrId === 'string' ? annotationOrId : annotationOrId.id;\n\n    const existing = annotationIndex.get(id);\n    if (existing) {\n      annotationIndex.delete(id);\n      existing.bodies.forEach(b => bodyIndex.delete(b.id));\n      return existing;\n    } else {\n      console.warn(`Attempt to delete missing annotation: ${id}`);\n    }\n  }\n\n  const deleteAnnotation = (annotationOrId: T | string, origin = Origin.LOCAL) => {\n    const deleted = deleteOneAnnotation(annotationOrId);\n    if (deleted)\n      emit(origin, { deleted: [ deleted  ]});\n  }\n\n  const bulkDeleteAnnotations = (annotationsOrIds: (T | string)[], origin = Origin.LOCAL) => {\n    const deleted = annotationsOrIds.reduce((deleted, arg) => {\n      const existing = deleteOneAnnotation(arg);\n      return existing ? [...deleted, existing] : deleted;\n    }, [] as T[]);\n\n    if (deleted.length > 0)\n      emit(origin, { deleted });\n  }\n\n  const deleteOneBody = (body: AnnotationBodyIdentifier) => {\n    const oldAnnotation = annotationIndex.get(body.annotation);\n\n    if (oldAnnotation) {\n      const oldBody = oldAnnotation.bodies.find(b => b.id === body.id);\n\n      if (oldBody) {\n        bodyIndex.delete(oldBody.id);\n\n        const newAnnotation = {\n          ...oldAnnotation,\n          bodies: oldAnnotation.bodies.filter(b => b.id !== body.id)\n        };\n\n        annotationIndex.set(oldAnnotation.id, newAnnotation);\n\n        const update: Update<T> = {\n          oldValue: oldAnnotation, newValue: newAnnotation, bodiesDeleted: [oldBody]\n        };\n\n        return update;\n      } else {\n        console.warn(`Attempt to delete missing body ${body.id} from annotation ${body.annotation}`);\n      }\n    } else {\n      console.warn(`Attempt to delete body from missing annotation ${body.annotation}`);\n    }\n  }\n \n  const deleteBody = (body: AnnotationBodyIdentifier, origin = Origin.LOCAL) => {\n    const updated = deleteOneBody(body);\n    if (updated)\n      emit(origin, { updated: [ updated  ]});\n  }\n\n  const bulkDeleteBodies = (bodies: AnnotationBodyIdentifier[], origin = Origin.LOCAL) => {\n    const updated = bodies\n      .map(b => deleteOneBody(b)!)\n      .filter(Boolean);\n\n    if (updated.length > 0)\n      emit(origin, { updated });\n  }\n\n  const getAnnotation = (id: string): T | undefined => {\n    const a = annotationIndex.get(id);\n    return a ? {...a} : undefined;\n  }\n\n  const getBody = (id: string): T['bodies'][number] | undefined => {\n    const annotationId = bodyIndex.get(id);\n    if (annotationId) {\n      const annotation = getAnnotation(annotationId);\n      const body = annotation!.bodies.find(b => b.id === id);\n      if (body) {\n        return body;\n      } else {\n        console.error(`Store integrity error: body ${id} in index, but not in annotation`);\n      }\n    } else {\n      console.warn(`Attempt to retrieve missing body: ${id}`);\n    }\n  }\n\n  const updateOneBody = (oldBodyId: AnnotationBodyIdentifier, newBody: T['bodies'][number]) => {\n    if (oldBodyId.annotation !== newBody.annotation)\n      throw 'Annotation integrity violation: annotation ID must be the same when updating bodies';\n\n    const oldAnnotation = annotationIndex.get(oldBodyId.annotation);\n    if (oldAnnotation) {\n      const oldBody = oldAnnotation.bodies.find(b => b.id === oldBodyId.id)!;\n\n      const newAnnotation = { \n        ...oldAnnotation,\n        bodies: oldAnnotation.bodies.map(b => b.id === oldBody.id ? newBody : b)\n      };\n\n      annotationIndex.set(oldAnnotation.id, newAnnotation);\n\n      if (oldBody.id !== newBody.id) {\n        bodyIndex.delete(oldBody.id);\n        bodyIndex.set(newBody.id, newAnnotation.id);\n      }\n\n      return {\n        oldValue: oldAnnotation, \n        newValue: newAnnotation,\n        bodiesUpdated: [{ oldBody, newBody }]\n      }\n    } else {\n      console.warn(`Attempt to add body to missing annotation ${oldBodyId.annotation}`);\n    }\n  }\n\n  const updateBody = (oldBodyId: AnnotationBodyIdentifier, newBody: T['bodies'][number], origin = Origin.LOCAL) => {\n    const update = updateOneBody(oldBodyId, newBody);\n    if (update)\n      emit(origin, { updated: [ update ]} );\n  }\n\n  const bulkUpdateBodies = (bodies: Array<T['bodies'][number]>, origin = Origin.LOCAL) => {\n    const updated = bodies\n      .map(b => updateOneBody({ id: b.id, annotation: b.annotation }, b)!)\n      .filter(Boolean);\n\n    emit(origin, { updated });\n  }\n\n  const updateOneTarget = (target: T['target']): Update<T> | undefined => {\n    const oldValue = annotationIndex.get(target.annotation);\n    \n    if (oldValue) {\n      const newValue = { \n        ...oldValue, \n        target: {\n          ...oldValue.target,\n          ...target \n        }\n      };\n\n      annotationIndex.set(oldValue.id, newValue);\n\n      return {\n        oldValue, newValue, targetUpdated: { \n          oldTarget: oldValue.target,\n          newTarget: target\n        }\n      };\n    } else {\n      console.warn(`Attempt to update target on missing annotation: ${target.annotation}`);\n    }\n  }\n\n  const updateTarget = (target: T['target'], origin = Origin.LOCAL) => {\n    const update = updateOneTarget(target);\n    if (update)\n      emit(origin, { updated: [ update ]} );\n  }\n\n  const bulkUpdateTargets = (targets: Array<T['target']>, origin = Origin.LOCAL) => {\n    const updated = \n      targets.map(t => updateOneTarget(t)!).filter(Boolean);\n    if (updated.length > 0)\n      emit(origin, { updated });\n  }\n\n\treturn {\n    addAnnotation,\n    addBody,\n    all,\n    bulkAddAnnotations,\n    bulkDeleteAnnotations,\n    bulkDeleteBodies,\n    bulkUpdateAnnotations,\n    bulkUpdateBodies,\n    bulkUpdateTargets,\n    bulkUpsertAnnotations,\n    clear,\n    deleteAnnotation,\n    deleteBody,\n    getAnnotation,\n    getBody,\n    observe,\n    unobserve,\n    updateAnnotation,\n    updateBody,\n    updateTarget,\n    upsertAnnotation\n\t};\n\n}\n","import type { Annotation, Annotator, AnnotatorState } from '../model';\nimport type { Store } from './Store';\nimport type { StoreChangeEvent } from './StoreObserver';\n\ntype Subscriber<T extends Annotation> = (annotation: T[]) => void; \n\nexport interface SvelteStore<T extends Annotation> extends Store<T> {\n\n  subscribe(onChange: Subscriber<T>): void;\n\n}\n\nexport interface SvelteAnnotatorState<I extends Annotation, E extends unknown> extends AnnotatorState<I, E> {\n\n  store: SvelteStore<I>\n\n}\n\nexport interface SvelteAnnotator<I extends Annotation, E extends unknown> extends Annotator<I, E> {\n\n  state: SvelteAnnotatorState<I, E>\n\n}\n\n/** \n * A simple wrapper around the event-based store implementation\n * that adds a Svelte shim, for use with the reactive '$' notation.\n * Other frameworks might not actually need this. But it's pretty\n * convenient for everyone using Svelte, as well as for the\n * basic (Svelte-based) Annotorious standard implementation.\n */\nexport const toSvelteStore = <T extends Annotation = Annotation>(store: Store<T>): SvelteStore<T> => {\n\n  const subscribe = (onChange: Subscriber<T>) => {\n\n    // Register a store observer on behalf of the subscriber\n    const shim = (event: StoreChangeEvent<T>) => onChange(event.state);\n    store.observe(shim);\n\n    // Immediately call the subscriber function with the\n    // current store value, according to the Svelte contract.\n    // https://stackoverflow.com/questions/68220955/how-does-svelte-unsubscribe-actually-work\n    onChange(store.all());\n\n    // Return the unsubscribe function\n    return () => store.unobserve(shim);\n  }\n\n  return {\n    ...store,\n    subscribe\n  }\n\n}","export let createNanoEvents = () => ({\n  emit(event, ...args) {\n    for (\n      let callbacks = this.events[event] || [],\n        i = 0,\n        length = callbacks.length;\n      i < length;\n      i++\n    ) {\n      callbacks[i](...args)\n    }\n  },\n  events: {},\n  on(event, cb) {\n    ;(this.events[event] ||= []).push(cb)\n    return () => {\n      this.events[event] = this.events[event]?.filter(i => cb !== i)\n    }\n  }\n})\n","import { createNanoEvents, type Unsubscribe } from 'nanoevents';\nimport type { Annotation } from '../model';\nimport type { Store } from './Store';\nimport { Origin } from './StoreObserver';\nimport { mergeChanges, type ChangeSet, type StoreChangeEvent, type Update } from './StoreObserver';\n\n// Duration with fast successive changes get merged \n// with the last event in the stack, rather than getting stacked\n// as a new undo/redo step.\nconst DEBOUNCE = 250;\n\nexport interface UndoStack <T extends Annotation> {\n\n  canRedo(): boolean;\n\n  canUndo(): boolean;\n\n  destroy(): void;\n\n  getHistory(): History<T>;\n\n  on<E extends keyof UndoStackEvents<T>>(event: E, callback: UndoStackEvents<T>[E]): Unsubscribe;\n\n  undo(): void;\n\n  redo(): void;\n\n}\n\nexport interface UndoStackEvents <T extends Annotation> {\n\n  redo(change: ChangeSet<T>): void;\n\n  undo(change: ChangeSet<T>): void;\n\n}\n\nexport interface History <T extends Annotation> {\n\n  changes: ChangeSet<T>[];\n  \n  pointer: number;\n\n}\n\nexport const createUndoStack = <T extends Annotation>(store: Store<T>, history?: History<T>): UndoStack<T> => {\n\n  const emitter = createNanoEvents<UndoStackEvents<T>>();\n\n  const changeStack: ChangeSet<T>[] = history?.changes || [];\n\n  let pointer = history ? history.pointer : - 1;\n\n  let muteEvents = false;\n\n  let lastEvent = 0;\n\n  const onChange = (event: StoreChangeEvent<T>) => {\n    if (!muteEvents) {\n      const { changes } = event;\n\n      const now = performance.now();\n\n      if (now - lastEvent > DEBOUNCE) {\n        // Put this change on the stack...\n        changeStack.splice(pointer + 1);\n        changeStack.push(changes);\n\n        // ...and update the pointer\n        pointer = changeStack.length - 1;\n      } else {\n        // Merge this change with the last in the stack\n        const last = changeStack.length - 1;\n        changeStack[last] = mergeChanges(changeStack[last], changes);\n      }\n\n      lastEvent = now;\n    }\n\n    muteEvents = false;\n  }\n\n  store.observe(onChange, { origin: Origin.LOCAL });\n\n  const undoCreated = (created?: T[]) =>\n    created && created.length > 0 && store.bulkDeleteAnnotations(created);\n\n  const redoCreated = (created?: T[]) =>\n    created && created.length > 0 && store.bulkAddAnnotations(created, false);\n\n  const undoUpdated = (updated?: Update<T>[]) =>\n    updated && updated.length > 0 && store.bulkUpdateAnnotations(updated.map(({ oldValue }) => oldValue));\n      \n  const redoUpdated = (updated?: Update<T>[]) =>\n    updated && updated.length > 0 && store.bulkUpdateAnnotations(updated.map(({ newValue }) => newValue));\n\n  const undoDeleted = (deleted?: T[]) => \n    deleted && deleted.length > 0 && store.bulkAddAnnotations(deleted, false);\n\n  const redoDeleted = (deleted?: T[]) =>\n    deleted && deleted.length > 0 && store.bulkDeleteAnnotations(deleted);\n\n  const undo = () => {\n    if (pointer > -1) {\n      muteEvents = true;\n\n      const { created, updated, deleted } = changeStack[pointer];\n\n      undoCreated(created);\n      undoUpdated(updated);\n      undoDeleted(deleted);\n\n      emitter.emit('undo', changeStack[pointer]);\n\n      pointer -= 1;\n    }\n  }\n\n  const canUndo = () => pointer > -1;\n\n  const redo = () => {\n    if (changeStack.length - 1 > pointer) {\n      muteEvents = true;\n\n      const { created, updated, deleted } = changeStack[pointer + 1];\n\n      redoCreated(created);\n      redoUpdated(updated);\n      redoDeleted(deleted);\n\n      emitter.emit('redo', changeStack[pointer + 1]);\n\n      pointer += 1;\n    }\n  }\n\n  const canRedo = () => changeStack.length - 1 > pointer;\n\n  const destroy = () => store.unobserve(onChange);\n\n  const getHistory = () => ({ changes: [...changeStack], pointer });\n\n  const on = <E extends keyof UndoStackEvents<T>>(event: E, callback: UndoStackEvents<T>[E]) => \n    emitter.on(event, callback);\n\n  return {\n    canRedo,\n    canUndo,\n    destroy,\n    getHistory,\n    on,\n    redo,\n    undo\n  }\n\n}","import { writable } from 'svelte/store';\n\nexport type ViewportState = ReturnType<typeof createViewportState>;\n\nexport const createViewportState = () => {\n\n  const { subscribe, set } = writable<string[]>([]);\n\n  return { \n    subscribe, \n    set\n  };\n\n}\n","import { dequal } from 'dequal/lite';\nimport type { Annotation, AnnotatorState, FormatAdapter } from '../model';\nimport { Origin } from '../state';\nimport type { ChangeSet, SelectionState, UndoStack } from '../state';\nimport type { LifecycleEvents } from './LifecycleEvents';\n\nexport type Lifecycle<I extends Annotation, E extends unknown> = \n  ReturnType<typeof createLifecycleObserver<I, E>>;\n\nexport const createLifecycleObserver = <I extends Annotation, E extends unknown>(\n  state: AnnotatorState<I, E>,\n  undoStack: UndoStack<I>,\n  adapter?: FormatAdapter<I, E>,\n  autoSave?: boolean\n) => {\n  const { hover, selection, store, viewport } = state;\n\n  const observers: Map<keyof LifecycleEvents, Function[]> = new Map();\n\n  // The currently selected annotations, in the state when they were selected \n  let initialSelection: I[] = [];\n\n  let currentHover: string | undefined;\n\n  let idleTimeout: ReturnType<typeof setTimeout>;\n\n  const on = <T extends keyof LifecycleEvents>(event: T, callback: LifecycleEvents<E>[T]) => {\n    if (observers.has(event)) {\n      observers.get(event)!.push(callback);\n    } else {\n      observers.set(event, [callback]);\n    }\n  }\n\n  const off = <T extends keyof LifecycleEvents<E>>(event: T, callback: LifecycleEvents<E>[T]) => {\n    const callbacks = observers.get(event);\n    if (callbacks) {\n      const idx = callbacks.indexOf(callback);\n      if (idx !== -1)\n        callbacks.splice(idx, 1);\n    }\n  }\n\n  const emit = (event: keyof LifecycleEvents<E>, arg0: I | I[], arg1?: I | PointerEvent) => {\n    if (observers.has(event)) {\n      setTimeout(() => {\n        observers.get(event)!.forEach(callback => { \n          if (adapter) {\n            const serialized0 = Array.isArray(arg0) ? \n              arg0.map(a => adapter.serialize(a)) : adapter.serialize(arg0);\n            \n            const serialized1: E | PointerEvent | undefined =\n              arg1 ? arg1 instanceof PointerEvent ? arg1 : adapter.serialize(arg1) : undefined;\n\n            callback(serialized0 as E & E[], serialized1); \n          } else {\n            callback(arg0 as E & E[], arg1 as unknown as E);  \n          }\n        });\n      }, 1);\n    }\n  }\n\n  const onIdleUpdate = () => {\n    const { selected } = selection;\n\n    // User idle after activity - fire update events for selected\n    // annotations that changed\n    const updatedSelected = (selected || []).map(({ id }) => store.getAnnotation(id)!);\n\n    updatedSelected.forEach(updated => {\n      const initial = initialSelection.find(a => a.id === updated.id);\n      if (!initial || !dequal(initial, updated)) {\n        emit('updateAnnotation', updated, initial);\n      }\n    });\n\n    initialSelection = initialSelection.map(initial => {\n      const updated = updatedSelected.find(({ id }) => id === initial.id);\n      return updated ? updated : initial\n    });\n  }\n\n  selection.subscribe(({ selected })=> {\n    if (initialSelection.length === 0 && selected.length === 0)\n      return;\n\n    if (initialSelection.length === 0 && selected.length > 0) {\n      // A new selection was made - store the editable annotation as initial state\n      initialSelection = selected.map(({ id }) => store.getAnnotation(id)!);\n    } else if (initialSelection.length > 0 && selected.length === 0) {\n      // Deselect!\n      initialSelection.forEach(initial => {\n        const updatedState = store.getAnnotation(initial.id);  \n        \n        if (updatedState && !dequal(updatedState, initial)) {\n          emit('updateAnnotation', updatedState, initial);\n        }\n      });\n\n      initialSelection = [];\n    } else {\n      // Changed selection\n      const initialIds = new Set(initialSelection.map(a => a.id));\n      const selectedIds = new Set(selected.map(({ id }) => id));\n\n      // Fire update events for deselected annotations that have changed\n      const deselected = initialSelection.filter(a => !selectedIds.has(a.id));\n      deselected.forEach(initial => {\n        const updatedState = store.getAnnotation(initial.id);\n\n        if (updatedState && !dequal(updatedState, initial))\n          emit('updateAnnotation', updatedState, initial);\n      });\n\n      initialSelection = [\n        // Remove annotations that were deselected\n        ...initialSelection.filter(a => selectedIds.has(a.id)),\n        // Add editable annotations that were selected\n        ...selected\n          .filter(({ id }) => !initialIds.has(id))\n          .map(({ id }) => store.getAnnotation(id)!)\n      ];\n    }\n\n    emit('selectionChanged', initialSelection);\n  });\n\n  hover.subscribe(id => {\n    if (!currentHover && id) {\n      emit('mouseEnterAnnotation', store.getAnnotation(id)!);\n    } else if (currentHover && !id) {\n      emit('mouseLeaveAnnotation', store.getAnnotation(currentHover)!);\n    } else if (currentHover && id) {\n      emit('mouseLeaveAnnotation', store.getAnnotation(currentHover)!);\n      emit('mouseEnterAnnotation', store.getAnnotation(id)!);\n    }\n\n    currentHover = id;\n  });\n\n  viewport?.subscribe(ids => \n    emit('viewportIntersect', ids.map(id => store.getAnnotation(id)!)));\n\n  store.observe(event => {\n    // autoSave option triggers update events on idleness\n    if (autoSave) {\n      if (idleTimeout)\n        clearTimeout(idleTimeout);\n\n      idleTimeout = setTimeout(onIdleUpdate, 1000);\n    }\n\n    // Local CREATE and DELETE events are applied immediately\n    const { created, deleted } = event.changes;\n    (created || []).forEach(a => emit('createAnnotation', a));\n    (deleted || []).forEach(a => emit('deleteAnnotation', a));\n\n    // Updates are only applied immediately if they involve body changes\n    const updatesWithBody = (event.changes.updated || []).filter(u => [\n      ...(u.bodiesCreated || []),\n      ...(u.bodiesDeleted || []),\n      ...(u.bodiesUpdated || [])\n    ].length > 0);\n\n    // Emit an update with the new annototation and the stored initial state\n    updatesWithBody.forEach(({ oldValue, newValue }) => {\n      const initial = initialSelection.find(a => a.id === oldValue.id) || oldValue;\n\n      // Record the update as the new last known state\n      initialSelection = initialSelection\n        .map(a => a.id === oldValue.id ? newValue : a);\n\n      emit('updateAnnotation', newValue, initial);\n    });\n  }, { origin: Origin.LOCAL });\n\n  // Track remote changes - these should update the initial state\n  store.observe(event => {\n    if (initialSelection) {\n      const selectedIds = new Set(initialSelection.map(a => a.id));\n\n      const relevantUpdates = (event.changes.updated || [])\n        .filter(({ newValue }) => selectedIds.has(newValue.id))\n        .map(({ newValue }) => newValue);\n\n      if (relevantUpdates.length > 0) {\n        initialSelection = initialSelection.map(selected => {\n          const updated = relevantUpdates.find(updated => updated.id === selected.id);\n          return updated ? updated : selected;\n        })\n      }\n    }\n  }, { origin: Origin.REMOTE });\n\n  const onUndoOrRedo = (undo: boolean) => (changes: ChangeSet<I>) => {\n    // Undo/redo of created/delete will cause lifecycle events automatically,\n    // but we need to handle updates specifically!\n    const { updated } = changes;\n\n    if (undo)\n      (updated || []).forEach(t => emit('updateAnnotation', t.oldValue, t.newValue));\n    else\n      (updated || []).forEach(t => emit('updateAnnotation', t.newValue, t.oldValue));\n  }\n\n  undoStack.on('undo', onUndoOrRedo(true));\n  undoStack.on('redo', onUndoOrRedo(false));\n\n  return { on, off, emit }\n\n}\n","import type { Annotation } from './Annotation';\n\nexport interface FormatAdapter<A extends Annotation, T extends unknown> {\n\n  parse(serialized: T): ParseResult<A>;\n\n  parseAll?(serialized: unknown[]): { parsed: A[], failed: T[] };\n\n  serialize(core: A): T;\n\n}\n\nexport interface ParseResult<A extends Annotation> {\n\n  parsed?: A;\n  \n  error?: Error;\n\n}\n\nexport const serializeAll = \n  <A extends Annotation, T extends unknown>(adapter: FormatAdapter<A, T>) =>\n    (annotations: A[]) => annotations.map(a => adapter.serialize(a));\n\nexport const parseAll = \n  <A extends Annotation, T extends unknown>(adapter: FormatAdapter<A, T>) =>\n    (serialized: T[]) => serialized.reduce((result, next) => {\n      const { parsed, error } = adapter.parse(next);\n      \n      return error ? {\n        parsed: result.parsed,\n        failed: [...result.failed, next ]\n      } : parsed ? {\n        parsed: [...result.parsed, parsed ],\n        failed: result.failed\n      } : {\n        ...result\n      }\n    }, { parsed: [] as A[], failed: [] as T[]});\n  ","import type { Annotation } from './Annotation';\nimport type { User } from './User';\nimport type { PresenceProvider } from '../presence';\nimport type {\n  History,\n  HoverState,\n  SelectionState,\n  Store,\n  UndoStack,\n  UserSelectActionExpression,\n  ViewportState\n} from '../state';\nimport { Origin } from '../state';\nimport type { LifecycleEvents } from '../lifecycle';\nimport { reviveDates } from '../utils';\nimport { type FormatAdapter, parseAll } from './FormatAdapter';\nimport type { DrawingStyleExpression } from './DrawingStyle';\nimport type { Filter } from './Filter';\n\n/**\n * Base annotator interface\n * @template I - internal core data model\n * @template E - external adapted representation\n */\nexport interface Annotator<I extends Annotation = Annotation, E extends unknown = Annotation> {\n\n  addAnnotation(annotation: Partial<E>): void;\n\n  cancelSelected(): void;\n\n  canRedo(): boolean;\n\n  canUndo(): boolean;\n\n  clearAnnotations(): void;\n\n  destroy(): void;\n\n  getAnnotationById(id: string): E | undefined;\n\n  getAnnotations(): E[];\n\n  getHistory(): History<I>;\n\n  getSelected(): E[];\n\n  getUser(): User;\n\n  loadAnnotations(url: string, replace?: boolean): Promise<E[]>;\n\n  redo(): void;\n\n  removeAnnotation(arg: Partial<E> | string): E | undefined;\n\n  setAnnotations(annotations: Partial<E>[], replace?: boolean): void;\n\n  setFilter(filter: Filter<I> | undefined): void;\n\n  setPresenceProvider?(provider: PresenceProvider): void;\n\n  setSelected(arg?: string | string[], editable?: boolean): void;\n\n  setStyle(style: DrawingStyleExpression<I> | undefined): void;\n\n  setUser(user: User): void;\n\n  setUserSelectAction(action: UserSelectActionExpression<E>): void;\n\n  setVisible(visible: boolean): void;\n\n  undo(): void;\n\n  updateAnnotation(annotation: Partial<E>): E;\n  \n  on<T extends keyof LifecycleEvents<E>>(event: T, callback: LifecycleEvents<E>[T]): void;\n\n  off<T extends keyof LifecycleEvents<E>>(event: T, callback: LifecycleEvents<E>[T]): void;\n\n  state: AnnotatorState<I, E>;\n\n}\n\nexport interface AnnotatorState<I extends Annotation, E extends unknown> {\n\n  store: Store<I>;\n\n  selection: SelectionState<I, E>;\n\n  hover: HoverState<I>;\n\n  viewport: ViewportState;\n\n}\n\nexport const createBaseAnnotator = <I extends Annotation, E extends unknown>(\n  state: AnnotatorState<I, E>, \n  undoStack: UndoStack<I>,\n  adapter?: FormatAdapter<I, E>\n) => {\n\n  const { store, selection } = state;\n\n  const addAnnotation = (annotation: E) => {\n    if (adapter) {\n      const { parsed, error } = adapter.parse(annotation);\n      if (parsed) {\n        store.addAnnotation(parsed, Origin.REMOTE);\n      } else {\n        console.error(error);\n      }\n    } else {\n      store.addAnnotation(reviveDates<I>(annotation), Origin.REMOTE);\n    }\n  }\n\n  const cancelSelected = () => selection.clear();\n\n  const clearAnnotations = () => store.clear();\n\n  const getAnnotationById = (id: string): E | undefined => {\n    const annotation = store.getAnnotation(id);\n    return (adapter && annotation) ?\n      adapter.serialize(annotation) as E : annotation as unknown as E;\n  }\n\n  const getAnnotations = () =>\n    (adapter ? store.all().map(adapter.serialize) : store.all()) as E[];\n\n  const getSelected = () => {\n    const selectedIds = selection.selected?.map(s => s.id) || [];\n\n    const selected = selectedIds.map(id => store.getAnnotation(id)!).filter(Boolean);\n\n    return adapter \n      ? selected.map(adapter.serialize) \n      : selected as unknown as E[];\n  }\n\n  const loadAnnotations = (url: string, replace = true) =>\n    fetch(url)\n      .then((response) => response.json())\n      .then((annotations) => {\n        setAnnotations(annotations, replace);\n        return annotations;\n      });\n\n  const removeAnnotation = (arg: E | string): E | undefined => {\n    if (typeof arg === 'string') {\n      const annotation = store.getAnnotation(arg);\n      store.deleteAnnotation(arg);\n\n      if (annotation)\n        return adapter ? adapter.serialize(annotation) : annotation as unknown as E;\n    } else {\n      const annotation = adapter ? adapter.parse(arg).parsed : (arg as unknown as I);\n\n      if (annotation) {\n        store.deleteAnnotation(annotation);\n        return arg;\n      }\n    }\n  }\n\n  const setAnnotations = (annotations: E[], replace = true) => {\n    if (adapter) {\n      const parseFn = adapter.parseAll || parseAll(adapter);\n      const { parsed, failed } = parseFn(annotations);\n\n      if (failed.length > 0)\n        console.warn(`Discarded ${failed.length} invalid annotations`, failed);\n\n      store.bulkAddAnnotations(parsed, replace, Origin.REMOTE);\n    } else {\n      store.bulkAddAnnotations(annotations.map(reviveDates<I>), replace, Origin.REMOTE);\n    }\n  }\n\n  const setSelected = (arg?: string | string[], editable?: boolean) => {\n    if (arg) {\n      selection.setSelected(arg, editable);\n    } else {\n      selection.clear();\n    }\n  }\n\n  const setUserSelectAction = (action: UserSelectActionExpression<E>) => {\n    selection.setUserSelectAction(action);\n  }\n\n  const updateAnnotation = (updated: E): E => {\n    if (adapter) {\n      const crosswalked = adapter.parse(updated).parsed!;\n      const previous = adapter.serialize(store.getAnnotation(crosswalked.id)!);\n      store.updateAnnotation(crosswalked);\n      return previous;\n    } else {\n      const previous = store.getAnnotation((updated as unknown as I).id);\n      store.updateAnnotation(reviveDates<I>(updated));\n      return previous as unknown as E;\n    }\n  }\n\n  // Note that we don't spread the undoStack - it has a .destroy()\n  // method that would likely get overwritten by other Annotator implementations\n  // if people are not careful.\n  return { \n    addAnnotation,\n    cancelSelected,\n    canRedo: undoStack.canRedo,\n    canUndo: undoStack.canUndo,\n    clearAnnotations,\n    getAnnotationById,\n    getAnnotations,\n    getHistory: undoStack.getHistory,\n    getSelected,\n    loadAnnotations,\n    redo: undoStack.redo,\n    removeAnnotation,\n    setAnnotations,\n    setSelected,\n    setUserSelectAction,\n    undo: undoStack.undo,\n    updateAnnotation\n  }\n\n}\n","import type { Annotation } from \"./Annotation\";\nimport type { AnnotationState } from \"./AnnotationState\";\n\ntype RGB = `rgb(${number}, ${number}, ${number})`;\n\ntype RGBA = `rgba(${number}, ${number}, ${number}, ${number})`;\n\ntype HEX = `#${string}`;\n\nexport type Color = RGB | RGBA | HEX;\n\nexport interface DrawingStyle {\n\n  fill?: Color;\n\n  fillOpacity?: number;\n\n  stroke?: Color;\n\n  strokeOpacity?: number;\n\n  strokeWidth?: number;\n\n}\n\nexport type DrawingStyleExpression<T extends Annotation = Annotation> =\n  DrawingStyle | ((annotation: T, state?: AnnotationState) => DrawingStyle | undefined);\n\n/** Utility functions **/\n\nexport const computeStyle = <T extends Annotation = Annotation>(\n  annotation: T,\n  style: DrawingStyleExpression<T>,\n  state?: AnnotationState\n) => {\n  return typeof style === 'function' ? style(annotation, state) : style;\n};\n\nexport const chainStyles = <T extends Annotation = Annotation>(\n  applyFirst: DrawingStyleExpression<T>,\n  applySecond: DrawingStyleExpression<T>\n) => {\n  if (typeof applyFirst !== 'function' && typeof applySecond !== 'function') {\n    // Simple case: just two objects\n    return {\n      ...(applyFirst || {}),\n      ...(applySecond || {})\n    };\n  } else {\n    // Return a function\n    return (a: T, state: AnnotationState) => {\n      const first = typeof applyFirst === 'function' ? applyFirst(a, state) : applyFirst;\n      const second = typeof applySecond === 'function' ? applySecond(a, state) : applySecond;\n\n      return {\n        ...(first || {}),\n        ...(second || {})\n      }\n    }\n  }\n}\n  \n","export const urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\n","/* @ts-self-types=\"./index.d.ts\" */\nimport { urlAlphabet as scopedUrlAlphabet } from './url-alphabet/index.js'\nexport { urlAlphabet } from './url-alphabet/index.js'\nexport let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\nexport let customRandom = (alphabet, defaultSize, getRandom) => {\n  let mask = (2 << Math.log2(alphabet.length - 1)) - 1\n  let step = -~((1.6 * mask * defaultSize) / alphabet.length)\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      let j = step | 0\n      while (j--) {\n        id += alphabet[bytes[j] & mask] || ''\n        if (id.length >= size) return id\n      }\n    }\n  }\n}\nexport let customAlphabet = (alphabet, size = 21) =>\n  customRandom(alphabet, size | 0, random)\nexport let nanoid = (size = 21) => {\n  let id = ''\n  let bytes = crypto.getRandomValues(new Uint8Array((size |= 0)))\n  while (size--) {\n    id += scopedUrlAlphabet[bytes[size] & 63]\n  }\n  return id\n}\n","import { customAlphabet } from 'nanoid';\n\nexport interface User {\n\n  id: string;\n\n  isGuest?: boolean;\n\n  name?: string;\n\n  avatar?: string;\n\n}\n\nexport const createAnonymousGuest = () => {\n  const nanoid = customAlphabet('1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_', 20);\n  \n  return { isGuest: true, id: nanoid() }\n}","import type { Annotation, AnnotationBody } from './Annotation';\n\nexport interface W3CAnnotation {\n\n  '@context': 'http://www.w3.org/ns/anno.jsonld';\n\n  type: 'Annotation';\n\n  id: string;\n\n  creator?: W3CUser;\n\n  created?: string;\n\n  modified?: string;\n\n  body: W3CAnnotationBody | W3CAnnotationBody[];\n\n  target: W3CAnnotationTarget | W3CAnnotationTarget[];\n\n  [key: string]: any;\n\n}\n\nexport interface W3CUser {\n\n  type?: string;\n\n  id: string;\n\n  name?: string;\n\n}\n\nexport interface W3CAnnotationBody {\n\n  type?: string;\n\n  id?: string;\n\n  format?: string;\n\n  purpose?: string;\n\n  value?: string;\n\n  source?: string;\n\n  creator?: W3CUser;\n\n  created?: string;\n\n  modified?: string;\n\n}\n\nexport interface W3CAnnotationTarget {\n\n  id?: string;\n\n  source: string;\n\n  selector?: AbstractW3CSelector;\n\n}\n\nexport interface AbstractW3CSelector { }\n\n// https://stackoverflow.com/questions/6122571/simple-non-secure-hash-function-for-javascript\nconst hashCode = (obj: Object): string => {\n  const str = JSON.stringify(obj);\n\n  let hash = 0;\n\n  for (let i = 0, len = str.length; i < len; i++) {\n    let chr = str.charCodeAt(i);\n    hash = (hash << 5) - hash + chr;\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return `${hash}`;\n}\n\nexport const parseW3CUser = (user?: any) => user\n  ? typeof user === 'object' ? { ...user } : user : undefined;\n\n/**\n * Helper to crosswalk the W3C annotation body to a list of core AnnotationBody objects.\n */\nexport const parseW3CBodies = (\n  body: W3CAnnotationBody | W3CAnnotationBody[],\n  annotationId: string\n) : AnnotationBody[] => (Array.isArray(body) ? body : [body]).map(body => {\n\n  // Extract properties that conform to the internal model, but keep custom props\n  const { id, type, purpose, value, created, modified, creator, ...rest } = body;\n\n  // The internal model strictly requires IDs. (Because multi-user scenarios\n  // will have problems without them.) In the W3C model, bodys *may* have IDs.\n  // We'll create ad-hoc IDs for bodies without IDs, but want to make sure that\n  // generating the ID is idempotent: the same body should always get the same ID.\n  // This will avoid unexpected results when checking for equality.  \n  return {\n    id: id || `temp-${hashCode(body)}`,\n    annotation: annotationId,\n    type,\n    purpose,\n    value,\n    creator: parseW3CUser(creator),\n    created: created ? new Date(created) : undefined,\n    updated: modified ? new Date(modified) : undefined,\n    ...rest\n  }\n\n});\n\n/** Serialization helper to remove core-specific fields from the annotation body **/\nexport const serializeW3CBodies = (bodies: AnnotationBody[]): W3CAnnotationBody[] =>\n  bodies.map(b => {\n    const { annotation: _a, created, updated, ...bodyRest } = b;\n\n    const w3cBody: W3CAnnotationBody =  {\n      ...bodyRest,\n      created: created?.toISOString(),\n      modified: updated?.toISOString()\n    }\n    if (w3cBody.id?.startsWith('temp-')) {\n      delete w3cBody.id;\n    }\n\n    return w3cBody;\n  });\n\nexport const isW3CAnnotation = (annotation: Annotation | W3CAnnotation): annotation is W3CAnnotation =>\n  '@context' in annotation && 'creator' in annotation && 'body' in annotation;\n","// SEABORN_BRIGHT\nexport const DEFAULT_PALETTE: Palette = [\n  '#ff7c00', // orange\n  '#1ac938', // green\n  '#e8000b', // red\n  '#8b2be2', // purple\n  '#9f4800', // brown\n  '#f14cc1', // pink\n  '#ffc400', // khaki\n  '#00d7ff', // cyan\n  '#023eff'  // blue\n];\n\nexport type Palette = string[];","import type { User } from '../model/User';\nimport type { Appearance } from './Appearance';\nimport type { PresentUser } from './PresentUser';\nimport { DEFAULT_PALETTE } from './ColorPalette';\n\nexport interface AppearanceProvider {\n\n  addUser(presenceKey: string, user: User): Appearance;\n\n  removeUser(user: PresentUser): void;\n\n}\n\nexport const defaultColorProvider = () => {\n\n  const unassignedColors = [...DEFAULT_PALETTE];\n\n  const assignRandomColor = () => {\n    const rnd = Math.floor(Math.random() * unassignedColors.length);\n    const color = unassignedColors[rnd];\n\n    unassignedColors.splice(rnd, 1);\n\n    return color;\n  }\n\n  const releaseColor = (color: string) =>\n    unassignedColors.push(color);\n\n  return { assignRandomColor, releaseColor };\n\n}\n\nexport const createDefaultAppearanceProvider = () => {\n\n  const colorProvider = defaultColorProvider();\n\n  const addUser = (presenceKey: string, user: User): Appearance => {\n    const color = colorProvider.assignRandomColor();\n\n    return {\n      label: user.name || user.id,\n      avatar: user.avatar,\n      color\n    };\n  }\n\n  const removeUser = (user: PresentUser) =>\n    colorProvider.releaseColor(user.appearance.color);\n\n  return { addUser, removeUser }\n  \n}","import { nanoid } from 'nanoid';\nimport { createNanoEvents, type Unsubscribe } from 'nanoevents';\nimport type { User } from '../model/User';\nimport type { PresentUser } from './PresentUser';\nimport type { PresenceEvents } from './PresenceEvents';\nimport { createDefaultAppearanceProvider } from './AppearanceProvider';\nimport type { AppearanceProvider } from './AppearanceProvider';\n\nexport interface PresenceState {\n\n  // Get users currently present to this room\n  getPresentUsers(): PresentUser[];\n\n  // Notify of a given present user's activity on the given annotations\n  notifyActivity(presenceKey: string, annotationIds: string[]): void;\n\n  // Add a listener for the given presence event\n  on<E extends keyof PresenceEvents>(event: E, callback: PresenceEvents[E]): Unsubscribe;\n\n  // Initial sync - which users are present under which keys\n  syncUsers(state: { presenceKey: string, user: User }[]): void;\n\n  // Update the selection state for the given prresent user\n  updateSelection(presenceKey: string, selection: string[] | null): void;\n\n}\n\nconst isListEqual = (listA: any[], listB: any[]) => \n  listA.every(a => listA.includes(a)) && listB.every(b => listA.includes(b));\n\n// This client's presence key\nexport const PRESENCE_KEY = nanoid();\n\nexport const createPresenceState = (\n  appearanceProvider: AppearanceProvider = createDefaultAppearanceProvider()\n): PresenceState => {\n\n  const emitter = createNanoEvents<PresenceEvents>();\n\n  const presentUsers = new Map<string, PresentUser>();\n\n  const selectionStates = new Map<string, string[]>();\n\n  const addUser = (presenceKey: string, user: User) => {\n    if (presentUsers.has(presenceKey)) {\n      console.warn('Attempt to add user that is already present', presenceKey, user);\n      return;    \n    }\n\n    const appearance = appearanceProvider.addUser(presenceKey, user);\n\n    presentUsers.set(presenceKey, { \n      ...user,\n      presenceKey,\n      appearance\n    });\n  }\n\n  const removeUser = (presenceKey: string) => {\n    const user = presentUsers.get(presenceKey);\n    if (!user) {\n      console.warn('Attempt to remove user that is not present', presenceKey);\n      return;\n    }\n\n    appearanceProvider.removeUser(user);\n\n    presentUsers.delete(presenceKey);\n  }\n\n  const syncUsers = (state: { presenceKey: string, user: User }[]) => {\n    // const keys = new Set(others.map(s => s.presenceKey));\n    const keys = new Set(state.map(s => s.presenceKey));\n\n    // These users need to be added to the presentUsers list\n    // const toAdd = others.filter(({ presenceKey }) => !presentUsers.has(presenceKey));\n    const toAdd = state.filter(({ presenceKey }) => !presentUsers.has(presenceKey));\n\n    // These users need to be dropped from the list\n    const toRemove = Array.from(presentUsers.values()).filter(presentUser =>\n      !keys.has(presentUser.presenceKey));\n\n    toAdd.forEach(({ presenceKey, user }) => addUser(presenceKey, user));\n\n    toRemove.forEach(user => {\n      const { presenceKey } = user;\n\n      // If this user has a selection, fire deselect event\n      if (selectionStates.has(presenceKey))\n        emitter.emit('selectionChange', user, null);\n\n      removeUser(presenceKey)\n    });\n\n    if (toAdd.length > 0 || toRemove.length > 0)\n      emitter.emit('presence', getPresentUsers());\n  }\n\n  const notifyActivity = (presenceKey: string, annotationIds: string[]) => {    \n    const user = presentUsers.get(presenceKey);\n    \n    if (!user) {\n      console.warn('Activity notification from user that is not present');\n      return;\n    }\n\n    const currentSelection = selectionStates.get(presenceKey);\n\n    // Was there a selection change we might have missed?\n    if (!currentSelection || !isListEqual(currentSelection, annotationIds)) {\n      selectionStates.set(presenceKey, annotationIds);\n      emitter.emit('selectionChange', user, annotationIds);\n    }\n  }\n\n  const updateSelection = (presenceKey: string, selection: string[] | null) => {\n    const from = presentUsers.get(presenceKey);\n    if (!from) {\n      console.warn('Selection change for user that is not present', presenceKey);\n      return;\n    }\n\n    if (selection)\n      selectionStates.set(presenceKey, selection);\n    else \n      selectionStates.delete(presenceKey);\n\n    emitter.emit('selectionChange', from, selection);\n  }\n\n  const getPresentUsers = () =>\n    [...Array.from(presentUsers.values())];\n    \n  const on = <E extends keyof PresenceEvents>(event: E, callback: PresenceEvents[E]) =>\n    emitter.on(event, callback);\n\n  return {\n    getPresentUsers,\n    notifyActivity,\n    on,\n    syncUsers,\n    updateSelection\n  }\n\n}"],"names":["has","dequal","foo","bar","ctor","len","noop","safe_not_equal","a","b","subscriber_queue","writable","value","start","stop","subscribers","set","new_value","run_queue","subscriber","i","update","fn","subscribe","run","invalidate","createHoverState","store","currentHover","updated","changes","oldValue","UserSelectAction","EMPTY","createSelectionState","defaultSelectionAction","adapter","currentUserSelectAction","currentSelection","clear","isEmpty","_a","isSelected","annotationOrId","id","userSelect","idOrIds","event","annotations","annotation","selected","sel","action","evalSelectAction","setSelected","editable","ids","isEditable","removeFromSelection","setUserSelectAction","onUserSelect","crosswalked","byteToHex","unsafeStringify","arr","offset","getRandomValues","rnds8","rng","randomUUID","native","_v4","options","buf","rnds","v4","getContributors","creator","updatedBy","bodyCollaborators","users","body","u","reviveDates","revive","revived","createBody","payload","created","uuidv4","getAddedBodies","newValue","oldBodyIds","getRemovedBodies","newBodyIds","getChangedBodies","newBody","oldBody","hasTargetChanged","diffAnnotations","bodiesCreated","bodiesDeleted","bodiesUpdated","Ignore","Origin","shouldNotify","observer","_b","origin","ignore","arg","hasBodyChanges","hasTargetChanges","affectedAnnotations","mergeChanges","toMerge","previouslyCreatedIds","previouslyUpdatedIds","createdIds","deletedIds","updatedIds","mergeableUpdates","deleted","sanitize","isAnnotation","createStore","annotationIndex","bodyIndex","observers","observe","onChange","unobserve","idx","emit","addAnnotation","sanitized","updateOneAnnotation","arg1","arg2","oldId","updateAnnotation","arg3","upsertAnnotation","bulkUpdateAnnotations","bulkUpsertAnnotations","toAdd","toUpdate","agg","addBody","all","bulkAddAnnotations","replace","existing","next","deleteOneAnnotation","deleteAnnotation","bulkDeleteAnnotations","annotationsOrIds","deleteOneBody","oldAnnotation","newAnnotation","deleteBody","bulkDeleteBodies","bodies","getAnnotation","getBody","annotationId","updateOneBody","oldBodyId","updateBody","bulkUpdateBodies","updateOneTarget","target","targets","t","toSvelteStore","shim","createNanoEvents","args","callbacks","length","cb","DEBOUNCE","createUndoStack","history","emitter","changeStack","pointer","muteEvents","lastEvent","now","last","undoCreated","redoCreated","undoUpdated","redoUpdated","undoDeleted","redoDeleted","callback","createViewportState","createLifecycleObserver","state","undoStack","autoSave","hover","selection","viewport","initialSelection","idleTimeout","on","off","arg0","serialized0","serialized1","onIdleUpdate","updatedSelected","initial","updatedState","initialIds","selectedIds","relevantUpdates","onUndoOrRedo","undo","serializeAll","parseAll","serialized","result","parsed","error","createBaseAnnotator","cancelSelected","clearAnnotations","getAnnotationById","getAnnotations","getSelected","s","loadAnnotations","url","response","setAnnotations","removeAnnotation","parseFn","failed","previous","computeStyle","style","chainStyles","applyFirst","applySecond","first","second","urlAlphabet","random","bytes","customRandom","alphabet","defaultSize","getRandom","mask","step","size","j","customAlphabet","nanoid","scopedUrlAlphabet","createAnonymousGuest","hashCode","obj","str","hash","chr","parseW3CUser","user","parseW3CBodies","type","purpose","modified","rest","serializeW3CBodies","bodyRest","w3cBody","isW3CAnnotation","DEFAULT_PALETTE","defaultColorProvider","unassignedColors","rnd","color","createDefaultAppearanceProvider","colorProvider","presenceKey","isListEqual","listA","listB","PRESENCE_KEY","createPresenceState","appearanceProvider","presentUsers","selectionStates","addUser","appearance","removeUser","syncUsers","keys","toRemove","presentUser","getPresentUsers","notifyActivity","annotationIds","updateSelection","from"],"mappings":"AAAA,IAAIA,IAAM,OAAO,UAAU;AAEpB,SAASC,EAAOC,GAAKC,GAAK;AAChC,MAAIC,GAAMC;AACV,MAAIH,MAAQC,EAAK,QAAO;AAExB,MAAID,KAAOC,MAAQC,IAAKF,EAAI,iBAAiBC,EAAI,aAAa;AAC7D,QAAIC,MAAS,KAAM,QAAOF,EAAI,QAAO,MAAOC,EAAI,QAAO;AACvD,QAAIC,MAAS,OAAQ,QAAOF,EAAI,SAAQ,MAAOC,EAAI,SAAQ;AAE3D,QAAIC,MAAS,OAAO;AACnB,WAAKC,IAAIH,EAAI,YAAYC,EAAI;AAC5B,eAAOE,OAASJ,EAAOC,EAAIG,CAAG,GAAGF,EAAIE,CAAG,CAAC,IAAE;AAE5C,aAAOA,MAAQ;AAAA,IAChB;AAEA,QAAI,CAACD,KAAQ,OAAOF,KAAQ,UAAU;AACrC,MAAAG,IAAM;AACN,WAAKD,KAAQF;AAEZ,YADIF,EAAI,KAAKE,GAAKE,CAAI,KAAK,EAAEC,KAAO,CAACL,EAAI,KAAKG,GAAKC,CAAI,KACnD,EAAEA,KAAQD,MAAQ,CAACF,EAAOC,EAAIE,CAAI,GAAGD,EAAIC,CAAI,CAAC,EAAG,QAAO;AAE7D,aAAO,OAAO,KAAKD,CAAG,EAAE,WAAWE;AAAA,IACpC;AAAA,EACD;AAEA,SAAOH,MAAQA,KAAOC,MAAQA;AAC/B;AC3BO,SAASG,IAAO;AAAC;AA+DjB,SAASC,EAAeC,GAAGC,GAAG;AACpC,SAAOD,KAAKA,IAAIC,KAAKA,IAAID,MAAMC,KAAMD,KAAK,OAAOA,KAAM,YAAa,OAAOA,KAAM;AAClF;ACzDA,MAAME,IAAmB,CAAA;AA0BlB,SAASC,EAASC,GAAOC,IAAQP,GAAM;AAE7C,MAAIQ;AAEJ,QAAMC,IAAc,oBAAI,IAAG;AAI3B,WAASC,EAAIC,GAAW;AACvB,QAAIV,EAAeK,GAAOK,CAAS,MAClCL,IAAQK,GACJH,IAAM;AAET,YAAMI,IAAY,CAACR,EAAiB;AACpC,iBAAWS,KAAcJ;AACxB,QAAAI,EAAW,CAAC,EAAC,GACbT,EAAiB,KAAKS,GAAYP,CAAK;AAExC,UAAIM,GAAW;AACd,iBAASE,IAAI,GAAGA,IAAIV,EAAiB,QAAQU,KAAK;AACjD,UAAAV,EAAiBU,CAAC,EAAE,CAAC,EAAEV,EAAiBU,IAAI,CAAC,CAAC;AAE/C,QAAAV,EAAiB,SAAS;AAAA,MAC3B;AAAA,IACD;AAAA,EAEF;AAMA,WAASW,EAAOC,GAAI;AACnB,IAAAN,EAAIM,EAAGV,CAAK,CAAC;AAAA,EACd;AAOA,WAASW,EAAUC,GAAKC,IAAanB,GAAM;AAE1C,UAAMa,IAAa,CAACK,GAAKC,CAAU;AACnC,WAAAV,EAAY,IAAII,CAAU,GACtBJ,EAAY,SAAS,MACxBD,IAAOD,EAAMG,GAAKK,CAAM,KAAKf,IAE9BkB,EAAIZ,CAAK,GACF,MAAM;AACZ,MAAAG,EAAY,OAAOI,CAAU,GACzBJ,EAAY,SAAS,KAAKD,MAC7BA,EAAI,GACJA,IAAO;AAAA,IAET;AAAA,EACD;AACA,SAAO,EAAE,KAAAE,GAAK,QAAAK,GAAQ,WAAAE,EAAS;AAChC;ACvFO,MAAMG,KAAmB,CAAuBC,MAAoB;AAEzE,QAAM,EAAE,WAAAJ,GAAW,KAAAP,EAAA,IAAQL,EAAA;AAE3B,MAAIiB;AAEJ,SAAAL,EAAU,CAAAM,MAAWD,IAAeC,CAAO,GAG3CF,EAAM,QAAQ,CAAE,EAAE,SAAAG,QAAc;AAC9B,QAAIF,GAAc;AAEhB,OADmBE,EAAQ,WAAW,CAAA,GAAI,KAAK,CAAAtB,MAAKA,EAAE,OAAOoB,CAAY,KAEvEZ,EAAI,MAAS;AAEf,YAAMa,KAAWC,EAAQ,WAAW,CAAA,GAAI,KAAK,CAAC,EAAE,UAAAC,EAAA,MAAeA,EAAS,OAAOH,CAAY;AAC3F,MAAIC,KACFb,EAAIa,EAAQ,SAAS,EAAE;AAAA,IAC3B;AAAA,EACF,CAAC,GAEM;AAAA,IACL,IAAI,UAAU;AAAE,aAAOD;AAAA,IAAa;AAAA,IACpC,WAAAL;AAAA,IACA,KAAAP;AAAA,EAAA;AAGJ;AClBO,IAAKgB,sBAAAA,OAEVA,EAAA,OAAO,QAEPA,EAAA,SAAS,UAETA,EAAA,OAAO,QANGA,IAAAA,KAAA,CAAA,CAAA;AAYZ,MAAMC,IAAmB,EAAE,UAAU,GAAC,GAEzBC,KAAuB,CAClCP,GACAQ,GACAC,MACG;AACH,QAAM,EAAE,WAAAb,GAAW,KAAAP,MAAQL,EAAoBsB,CAAK;AAEpD,MAAII,IAA0BF,GAE1BG,IAA8BL;AAElC,EAAAV,EAAU,CAAAM,MAAWS,IAAmBT,CAAO;AAE/C,QAAMU,IAAQ,MAAM;AAClB,IAAKtC,EAAOqC,GAAkBL,CAAK,KACjCjB,EAAIiB,CAAK;AAAA,EAEb,GAEMO,IAAU,MAAA;AJhDlB,QAAAC;AIgDwB,aAAAA,IAAAH,EAAiB,aAAjB,gBAAAG,EAA2B,YAAW;AAAA,KAEtDC,IAAa,CAACC,MAA+B;AACjD,QAAIH,EAAA;AACF,aAAO;AAET,UAAMI,IAAK,OAAOD,KAAmB,WAAWA,IAAiBA,EAAe;AAChF,WAAOL,EAAiB,SAAS,KAAK,CAAAlB,MAAKA,EAAE,OAAOwB,CAAE;AAAA,EACxD,GAEMC,IAAa,CAACC,GAA4BC,MAA+B;AAC7E,QAAIC;AAEJ,QAAI,MAAM,QAAQF,CAAO;AAGvB,UAFAE,IAAcF,EAAQ,IAAI,CAAAF,MAAMjB,EAAM,cAAciB,CAAE,CAAE,EAAE,OAAO,OAAO,GAEpEI,EAAY,SAASF,EAAQ,QAAQ;AACvC,gBAAQ,KAAK,wBAAwBA,EAAQ,OAAO,CAAAF,MAAM,CAACI,EAAY,KAAK,CAAAxC,MAAKA,EAAE,OAAOoC,CAAE,CAAC,CAAC;AAC9F;AAAA,MACF;AAAA,WACK;AACL,YAAMK,IAAatB,EAAM,cAAcmB,CAAO;AAC9C,UAAI,CAACG,GAAY;AACf,gBAAQ,KAAK,wBAAwBH,CAAO;AAC5C;AAAA,MACF;AAEA,MAAAE,IAAc,CAACC,CAAU;AAAA,IAC3B;AAEA,UAAMC,IAAWF,EAAY,OAA6C,CAACG,GAAK3C,MAAM;AACpF,YAAM4C,IAASC,EAAiB7C,CAAC;AACjC,aAAI4C,MAAW,SACN,CAAC,GAAGD,GAAK,EAAE,IAAI3C,EAAE,IAAI,UAAU,IAAM,IACrC4C,MAAW,WACX,CAAC,GAAGD,GAAK,EAAE,IAAI3C,EAAE,IAAI,IAErB2C;AAAA,IACX,GAAG,CAAA,CAAE;AAEL,IAAAnC,EAAI,EAAE,UAAAkC,GAAU,OAAAH,GAAO;AAAA,EACzB,GAEMO,IAAc,CAACR,GAA4BS,MAAuB;AACtE,UAAMC,IAAM,MAAM,QAAQV,CAAO,IAAIA,IAAU,CAACA,CAAO,GAGjDE,IAAcQ,EACjB,IAAI,CAAAZ,MAAMjB,EAAM,cAAciB,CAAE,CAAC,EACjC,OAAO,CAACpC,MAAc,EAAQA,CAAE;AAEnC,IAAAQ,EAAI;AAAA,MACF,UAAUgC,EAAY,IAAI,CAAAC,MAAc;AAGtC,cAAMQ,IAAaF,MAAa,SAC5BF,EAAiBJ,CAAU,MAAM,SACjCM;AAEJ,eAAO,EAAE,IAAIN,EAAW,IAAI,UAAUQ,EAAA;AAAA,MACxC,CAAC;AAAA,IAAA,CACF,GAEGT,EAAY,WAAWQ,EAAI,UAC7B,QAAQ,KAAK,qBAAqBV,CAAO;AAAA,EAC7C,GAEMY,IAAsB,CAACF,MAAkB;AAC7C,QAAIhB,EAAA;AACF,aAAO;AAET,UAAM,EAAE,UAAAU,MAAaZ;AAIrB,IADqBY,EAAS,KAAK,CAAC,EAAE,IAAAN,QAASY,EAAI,SAASZ,CAAE,CAAC,KAE7D5B,EAAI,EAAE,UAAUkC,EAAS,OAAO,CAAC,EAAE,IAAAN,EAAA,MAAS,CAACY,EAAI,SAASZ,CAAE,CAAC,GAAG;AAAA,EACpE,GAEMe,IAAsB,CAACP,MAAsD;AACjF,IAAAf,IAA0Be,GAC1BE,EAAYhB,EAAiB,SAAS,IAAI,CAAC,EAAE,IAAAM,EAAA,MAASA,CAAE,CAAC;AAAA,EAC3D,GAGMS,IAAmB,CAACJ,MACxBW,EAAaX,GAAYZ,GAAyBD,CAAO;AAG3D,SAAAT,EAAM;AAAA,IACJ,CAAC,EAAE,SAAAG,EAAA,MAAc4B,GAAqB5B,EAAQ,WAAW,CAAA,GAAI,IAAI,CAAAtB,MAAKA,EAAE,EAAE,CAAC;AAAA,EAAA,GAGtE;AAAA,IACL,IAAI,QAAQ;AACV,aAAO8B,IAAmBA,EAAiB,QAAQ;AAAA,IACrD;AAAA,IACA,IAAI,WAAW;AACb,aAAOA,IAAmB,CAAC,GAAGA,EAAiB,QAAQ,IAAI;AAAA,IAC7D;AAAA,IACA,IAAI,mBAAmB;AACrB,aAAOD;AAAA,IACT;AAAA,IACA,OAAAE;AAAA,IACA,kBAAAc;AAAA,IACA,SAAAb;AAAA,IACA,YAAAE;AAAA,IACA,aAAAY;AAAA,IACA,qBAAAK;AAAA,IACA,WAAApC;AAAA,IACA,YAAAsB;AAAA,EAAA;AAGJ,GAEae,IAAe,CAC1BX,GACAG,GACAhB,MACqB;AACrB,QAAMyB,IAAczB,IAAUA,EAAQ,UAAUa,CAAU,IAAIA;AAC9D,SAAQ,OAAOG,KAAW,aAAcA,EAAOS,CAAW,IAAKT,KAAU;AAC3E,GCzKMU,IAAY,CAAA;AAClB,SAAS1C,IAAI,GAAGA,IAAI,KAAK,EAAEA;AACvB,EAAA0C,EAAU,MAAM1C,IAAI,KAAO,SAAS,EAAE,EAAE,MAAM,CAAC,CAAC;AAE7C,SAAS2C,GAAgBC,GAAKC,IAAS,GAAG;AAC7C,UAAQH,EAAUE,EAAIC,IAAS,CAAC,CAAC,IAC7BH,EAAUE,EAAIC,IAAS,CAAC,CAAC,IACzBH,EAAUE,EAAIC,IAAS,CAAC,CAAC,IACzBH,EAAUE,EAAIC,IAAS,CAAC,CAAC,IACzB,MACAH,EAAUE,EAAIC,IAAS,CAAC,CAAC,IACzBH,EAAUE,EAAIC,IAAS,CAAC,CAAC,IACzB,MACAH,EAAUE,EAAIC,IAAS,CAAC,CAAC,IACzBH,EAAUE,EAAIC,IAAS,CAAC,CAAC,IACzB,MACAH,EAAUE,EAAIC,IAAS,CAAC,CAAC,IACzBH,EAAUE,EAAIC,IAAS,CAAC,CAAC,IACzB,MACAH,EAAUE,EAAIC,IAAS,EAAE,CAAC,IAC1BH,EAAUE,EAAIC,IAAS,EAAE,CAAC,IAC1BH,EAAUE,EAAIC,IAAS,EAAE,CAAC,IAC1BH,EAAUE,EAAIC,IAAS,EAAE,CAAC,IAC1BH,EAAUE,EAAIC,IAAS,EAAE,CAAC,IAC1BH,EAAUE,EAAIC,IAAS,EAAE,CAAC,GAAG,YAAW;AAChD;AC1BA,IAAIC;AACJ,MAAMC,KAAQ,IAAI,WAAW,EAAE;AAChB,SAASC,KAAM;AAC1B,MAAI,CAACF,GAAiB;AAClB,QAAI,OAAO,SAAW,OAAe,CAAC,OAAO;AACzC,YAAM,IAAI,MAAM,0GAA0G;AAE9H,IAAAA,IAAkB,OAAO,gBAAgB,KAAK,MAAM;AAAA,EACxD;AACA,SAAOA,EAAgBC,EAAK;AAChC;ACVA,MAAME,KAAa,OAAO,SAAW,OAAe,OAAO,cAAc,OAAO,WAAW,KAAK,MAAM,GACtGC,IAAe,EAAE,YAAAD,GAAU;ACE3B,SAASE,GAAIC,GAASC,GAAKR,GAAQ;ARHnC,MAAAxB;AQII,EAAA+B,IAAUA,KAAW,CAAA;AACrB,QAAME,IAAOF,EAAQ,YAAU/B,IAAA+B,EAAQ,QAAR,gBAAA/B,EAAA,KAAA+B,OAAmBJ,GAAG;AACrD,MAAIM,EAAK,SAAS;AACd,UAAM,IAAI,MAAM,mCAAmC;AAEvD,SAAAA,EAAK,CAAC,IAAKA,EAAK,CAAC,IAAI,KAAQ,IAC7BA,EAAK,CAAC,IAAKA,EAAK,CAAC,IAAI,KAAQ,KAWtBX,GAAgBW,CAAI;AAC/B;AACA,SAASC,EAAGH,GAASC,GAAKR,GAAQ;AAC9B,SAAIK,EAAO,cAAsB,CAACE,IACvBF,EAAO,WAAU,IAErBC,GAAIC,CAAoB;AACnC;ACpBO,MAAMI,KAAkB,CAAC3B,MAAmC;AACjE,QAAM,EAAE,SAAA4B,GAAS,WAAAC,EAAA,IAAc7B,EAAW,QAEpC8B,IAAoB9B,EAAW,OAAO,OAAO,CAAC+B,GAAOC,MACzD,CAAC,GAAGD,GAAOC,EAAK,SAASA,EAAK,SAAS,EAAE,OAAO,OAAO,GACtD,EAAY;AAEf,SAAO;AAAA,IACLJ;AAAA,IACAC;AAAA,IACA,GAAGC;AAAA,EAAA,EACH,OAAO,CAAAG,MAAKA,CAAC;AACjB,GAQaC,IAAc,CAAoClC,MAAuB;AACpF,QAAMmC,IAAS,CAAoBH,MAAe;AAChD,UAAMI,IAAU,EAAC,GAAGJ,EAAA;AAEpB,WAAIA,EAAK,WAAW,OAAOA,EAAK,WAAY,aAC1CI,EAAQ,UAAU,IAAI,KAAKJ,EAAK,OAAO,IAErCA,EAAK,WAAW,OAAOA,EAAK,WAAY,aAC1CI,EAAQ,UAAU,IAAI,KAAKJ,EAAK,OAAO,IAElCI;AAAA,EACT;AAEA,SAAO;AAAA,IACL,GAAGpC;AAAA,IACH,SAASA,EAAW,UAAU,CAAA,GAAI,IAAImC,CAAM;AAAA,IAC5C,QAAQA,EAAOnC,EAAW,MAAM;AAAA,EAAA;AAEpC,GAKaqC,KAAa,CACxB3C,GACA4C,GACAC,GACAX,OACoB;AAAA,EACpB,IAAIY,EAAA;AAAA,EACJ,YAAY,OAAO9C,KAAmB,WAAWA,IAAiBA,EAAe;AAAA,EACjF,SAAS6C,KAAW,oBAAI,KAAA;AAAA,EACxB,SAAAX;AAAA,EACA,GAAGU;AACL,IC1DMG,KAAiB,CAAC3D,GAAsB4D,MAAyB;AACrE,QAAMC,IAAa,IAAI,IAAI7D,EAAS,OAAO,IAAI,CAAAtB,MAAKA,EAAE,EAAE,CAAC;AACzD,SAAOkF,EAAS,OAAO,OAAO,CAAAlF,MAAK,CAACmF,EAAW,IAAInF,EAAE,EAAE,CAAC;AAC1D,GAEMoF,KAAmB,CAAC9D,GAAsB4D,MAAyB;AACvE,QAAMG,IAAa,IAAI,IAAIH,EAAS,OAAO,IAAI,CAAAlF,MAAKA,EAAE,EAAE,CAAC;AACzD,SAAOsB,EAAS,OAAO,OAAO,CAAAtB,MAAK,CAACqF,EAAW,IAAIrF,EAAE,EAAE,CAAC;AAC1D,GAEMsF,KAAmB,CAAChE,GAAsB4D,MAC9CA,EAAS,OACN,IAAI,CAAAK,MAAW;AACd,QAAMC,IAAUlE,EAAS,OAAO,KAAK,OAAKtB,EAAE,OAAOuF,EAAQ,EAAE;AAC7D,SAAO,EAAE,SAAAA,GAAS,SAASC,KAAW,CAAChG,EAAOgG,GAASD,CAAO,IAAIC,IAAU,OAAA;AAC9E,CAAC,EACA,OAAO,CAAC,EAAE,SAAAA,EAAA,MAAcA,CAAO,EAC/B,IAAI,CAAC,EAAE,SAAAA,GAAS,SAAAD,EAAA,OAAe,EAAE,SAAAC,GAAmB,SAAAD,IAAU,GAE7DE,KAAmB,CAACnE,GAAsB4D,MAC9C,CAAC1F,EAAO8B,EAAS,QAAQ4D,EAAS,MAAM,GAE7BQ,IAAkB,CAAoCpE,GAAa4D,MAA2B;AACzG,QAAMS,IAAgBV,GAAe3D,GAAU4D,CAAQ,GACjDU,IAAgBR,GAAiB9D,GAAU4D,CAAQ,GACnDW,IAAgBP,GAAiBhE,GAAU4D,CAAQ;AAEzD,SAAO;AAAA,IACL,UAAA5D;AAAA,IACA,UAAA4D;AAAA,IACA,eAAeS,EAAc,SAAS,IAAIA,IAAgB;AAAA,IAC1D,eAAeC,EAAc,SAAS,IAAIA,IAAgB;AAAA,IAC1D,eAAeC,EAAc,SAAS,IAAIA,IAAgB;AAAA,IAC1D,eAAeJ,GAAiBnE,GAAU4D,CAAQ,IAAI,EAAE,WAAW5D,EAAS,QAAQ,WAAW4D,EAAS,OAAA,IAAW;AAAA,EAAA;AAEvH;ACyBO,IAAKY,uBAAAA,OAGVA,EAAA,YAAY,aAGZA,EAAA,cAAc,eANJA,IAAAA,MAAA,CAAA,CAAA,GAiBAC,sBAAAA,OAEVA,EAAA,QAAQ,SAERA,EAAA,SAAS,UAETA,EAAA,SAAS,UANCA,IAAAA,KAAA,CAAA,CAAA;AAWL,MAAMC,KAAe,CAAuBC,GAA4B3D,MAA+B;AX5F9G,MAAAN,GAAAkE;AW6FE,QAAM,EAAE,SAAA7E,GAAS,QAAA8E,EAAA,IAAW7D;AAM5B,MAAI,EAJqB2D,EAAS,QAAQ,SACtCA,EAAS,QAAQ,WAAWE,IAC5BA,MAAW;AAGb,WAAO;AAET,MAAIF,EAAS,QAAQ,QAAQ;AAC3B,UAAM,EAAE,QAAAG,MAAWH,EAAS,SAGtB1G,IAAM,CAAC8G,MAA2BA,KAAOA,EAAI,SAAS;AAK5D,QAAI,EAFF9G,EAAI8B,EAAQ,OAAO,KAAK9B,EAAI8B,EAAQ,OAAO,IAElB;AACzB,YAAMiF,KACJtE,IAAAX,EAAQ,YAAR,gBAAAW,EAAiB,KAAK,CAAAyC,MAAKlF,EAAIkF,EAAE,aAAa,KAAKlF,EAAIkF,EAAE,aAAa,KAAKlF,EAAIkF,EAAE,aAAa,IAE1F8B,KACJL,IAAA7E,EAAQ,YAAR,gBAAA6E,EAAiB,KAAK,CAAAzB,MAAKA,EAAE;AAK/B,UAHI2B,MAAW,eAAoBE,KAAkB,CAACC,KAGlDH,MAAW,iBAAsBG,KAAoB,CAACD;AACxD,eAAO;AAAA,IACX;AAAA,EACF;AAEA,MAAIL,EAAS,QAAQ,aAAa;AAEhC,UAAMO,wBAA0B,IAAI;AAAA,MAClC,IAAInF,EAAQ,WAAW,CAAA,GAAI,IAAI,CAAAtB,MAAKA,EAAE,EAAE;AAAA,MACxC,IAAIsB,EAAQ,WAAW,CAAA,GAAI,IAAI,CAAAtB,MAAKA,EAAE,EAAE;AAAA,MACxC,IAAIsB,EAAQ,WAAW,CAAA,GAAI,IAAI,CAAC,EAAE,UAAAC,QAAeA,EAAS,EAAE;AAAA,IAAA,CAC7D;AAKD,WAAO,GAHU,MAAM,QAAQ2E,EAAS,QAAQ,WAAW,IACzDA,EAAS,QAAQ,cAAc,CAAEA,EAAS,QAAQ,WAAY,GAExC,KAAK,CAAA9D,MAAMqE,EAAoB,IAAIrE,CAAE,CAAC;AAAA,EAChE;AACE,WAAO;AAGX,GAEasE,KAAe,CAAuBpF,GAAuBqF,MAA0B;AAClG,QAAMC,IAAuB,IAAI,KAAKtF,EAAQ,WAAW,IAAI,IAAI,CAAA,MAAK,EAAE,EAAE,CAAC,GACrEuF,IAAuB,IAAI,KAAKvF,EAAQ,WAAW,CAAA,GAAI,IAAI,CAAC,EAAE,UAAA6D,EAAA,MAAcA,EAAS,EAAE,CAAC,GAExF2B,IAAa,IAAI,KAAKH,EAAQ,WAAW,IAAI,IAAI,CAAA,MAAK,EAAE,EAAE,CAAC,GAC3DI,IAAa,IAAI,KAAKJ,EAAQ,WAAW,IAAI,IAAI,CAAA,MAAK,EAAE,EAAE,CAAC,GAC3DK,IAAa,IAAI,KAAKL,EAAQ,WAAW,CAAA,GAAI,IAAI,CAAC,EAAE,UAAApF,EAAA,MAAeA,EAAS,EAAE,CAAC,GAG/E0F,IAAmB,IAAI,KAAKN,EAAQ,WAAW,IAClD,OAAO,CAAC,EAAE,UAAApF,QAAeqF,EAAqB,IAAIrF,EAAS,EAAE,KAAKsF,EAAqB,IAAItF,EAAS,EAAE,CAAC,EACvG,IAAI,CAAC,EAAE,UAAAA,EAAA,MAAeA,EAAS,EAAG,CAAC,GAMhCyD,IAAU;AAAA,IACd,IAAI1D,EAAQ,WAAW,CAAA,GACpB,OAAO,CAAA,MAAK,CAACyF,EAAW,IAAI,EAAE,EAAE,CAAC,EACjC,IAAI,CAAA,MAAKC,EAAW,IAAI,EAAE,EAAE,IACzBL,EAAQ,QAAS,KAAK,CAAC,EAAE,UAAApF,EAAA,MAAeA,EAAS,OAAO,EAAE,EAAE,EAAG,WAC/D,CAAC;AAAA,IACP,GAAIoF,EAAQ,WAAW,CAAA;AAAA,EAAC,GAOpBO,IAAU;AAAA,IACd,IAAI5F,EAAQ,WAAW,CAAA,GACpB,OAAO,CAAA,MAAK,CAACwF,EAAW,IAAI,EAAE,EAAE,CAAC;AAAA,IACpC,IAAIH,EAAQ,WAAW,CAAA,GACpB,OAAO,CAAA,MAAK,CAACC,EAAqB,IAAI,EAAE,EAAE,CAAC;AAAA,EAAA,GAO1CvF,IAAU;AAAA,IACd,IAAIC,EAAQ,WAAW,CAAA,GACpB,OAAO,CAAC,EAAE,UAAA6D,EAAA,MAAe,CAAC4B,EAAW,IAAI5B,EAAS,EAAE,CAAC,EACrD,IAAI,CAAAtE,MAAU;AACb,YAAM,EAAE,UAAAU,GAAU,UAAA4D,EAAA,IAAatE;AAC/B,UAAImG,EAAW,IAAI7B,EAAS,EAAE,GAAG;AAC/B,cAAM9D,IAAUsF,EAAQ,QAAS,KAAK,CAAAjC,MAAKA,EAAE,SAAS,OAAOS,EAAS,EAAE,EAAG;AAC3E,eAAOQ,EAAgBpE,GAAUF,CAAO;AAAA,MAC1C;AACE,eAAOR;AAAA,IAEX,CAAC;AAAA,IACH,IAAI8F,EAAQ,WAAW,CAAA,GAAI,OAAO,CAAC,EAAE,UAAApF,EAAA,MAAe,CAAC0F,EAAiB,IAAI1F,EAAS,EAAE,CAAC;AAAA,EAAA;AAGxF,SAAO,EAAE,SAAAyD,GAAS,SAAAkC,GAAS,SAAA7F,EAAA;AAC7B,GChMM8F,IAAW,CAAuBnH,MAAqB;AAC3D,QAAMoC,IAAKpC,EAAE,OAAO,SAAYiF,EAAA,IAAWjF,EAAE;AAE7C,SAAO;AAAA,IACL,GAAGA;AAAA,IACH,IAAAoC;AAAA,IACA,QAAQpC,EAAE,WAAW,SAAY,CAAA,IAAKA,EAAE,OAAO,IAAI,CAAAC,OAAM;AAAA,MACvD,GAAGA;AAAA,MACH,YAAYmC;AAAA,IAAA,EACZ;AAAA,IACF,QAAQ;AAAA,MACN,GAAGpC,EAAE;AAAA,MACL,YAAYoC;AAAA,IAAA;AAAA,EACd;AAEJ,GAIMgF,KAAe,CAAuBd,MAAuBA,EAAI,OAAO,QAEjEe,KAAc,MAA4B;AAErD,QAAMC,wBAAsB,IAAA,GAEtBC,wBAAgB,IAAA,GAEhBC,IAAgC,CAAA,GAEhCC,IAAU,CAACC,GAAkD1D,IAA+B,CAAA,MAAO;AACvG,IAAAwD,EAAU,KAAK,EAAE,UAAAE,GAAU,SAAA1D,EAAA,CAAS;AAAA,EACtC,GAEM2D,IAAY,CAACD,MAAqD;AACtE,UAAME,IAAMJ,EAAU,UAAU,CAAAtB,MAAYA,EAAS,YAAYwB,CAAQ;AACzE,IAAIE,IAAM,MACRJ,EAAU,OAAOI,GAAK,CAAC;AAAA,EAC3B,GAEMC,IAAO,CAACzB,GAAgB9E,MAA0B;AACtD,UAAMiB,IAA6B;AAAA,MACjC,QAAA6D;AAAA,MACA,SAAS;AAAA,QACP,SAAS9E,EAAQ,WAAW,CAAA;AAAA,QAC5B,SAASA,EAAQ,WAAW,CAAA;AAAA,QAC5B,SAASA,EAAQ,WAAW,CAAA;AAAA,MAAC;AAAA,MAE/B,OAAO,CAAC,GAAGgG,EAAgB,QAAQ;AAAA,IAAA;AAGrC,IAAAE,EAAU,QAAQ,CAAAtB,MAAY;AAC5B,MAAID,GAAaC,GAAU3D,CAAK,KAC9B2D,EAAS,SAAS3D,CAAK;AAAA,IAC3B,CAAC;AAAA,EACH,GAEMuF,IAAgB,CAACrF,GAAwB2D,IAASJ,EAAO,UAAU;AAGvE,QAFiBvD,EAAW,MAAM6E,EAAgB,IAAI7E,EAAW,EAAE;AAGjE,YAAM,MAAM,yBAAyBA,EAAW,EAAE,mBAAmB;AAChE;AACL,YAAMsF,IAAYZ,EAAS1E,CAAU;AAErC,MAAA6E,EAAgB,IAAIS,EAAU,IAAIA,CAAS,GAC3CA,EAAU,OAAO,QAAQ,CAAA9H,MAAKsH,EAAU,IAAItH,EAAE,IAAI8H,EAAU,EAAE,CAAC,GAC/DF,EAAKzB,GAAQ,EAAE,SAAS,CAAC2B,CAAS,GAAG;AAAA,IACvC;AAAA,EACF,GAEMC,IAAsB,CAACC,GAA2BC,MAA+B;AACrF,UAAM7G,IAAwC8F,EAA3B,OAAOc,KAAS,WAAoBC,IAA+BD,CAAb,GAEnEE,IAA4B,OAAOF,KAAS,WAAWA,IAAOA,EAAK,IACnE1G,IAAW4G,KAASb,EAAgB,IAAIa,CAAK;AAEnD,QAAI5G,GAAU;AACZ,YAAMV,IAAoB8E,EAAgBpE,GAAUF,CAAO;AAE3D,aAAI8G,MAAU9G,EAAQ,KACpBiG,EAAgB,IAAIa,GAAO9G,CAAO,KAElCiG,EAAgB,OAAOa,CAAK,GAC5Bb,EAAgB,IAAIjG,EAAQ,IAAIA,CAAO,IAGzCE,EAAS,OAAO,QAAQ,CAAAtB,MAAKsH,EAAU,OAAOtH,EAAE,EAAE,CAAC,GACnDoB,EAAQ,OAAO,QAAQ,CAAApB,MAAKsH,EAAU,IAAItH,EAAE,IAAIoB,EAAQ,EAAE,CAAC,GAEpDR;AAAA,IACT;AACE,cAAQ,KAAK,4BAA4BsH,CAAK,mBAAmB;AAAA,EAErE,GAEMC,IAAmB,CAACH,GAAkBC,IAAmBlC,EAAO,OAAOqC,IAAOrC,EAAO,UAAU;AACnG,UAAMI,IAAiBgB,GAAac,CAAI,IAAIG,IAAOH,GAE7CrH,IAASmH,EAAoBC,GAAMC,CAAI;AAC7C,IAAIrH,KACFgH,EAAKzB,GAAQ,EAAE,SAAS,CAACvF,CAAM,GAAG;AAAA,EACtC,GAEMyH,IAAmB,CAAC7F,GAAe2D,IAASJ,EAAO,UAAU;AAEjE,IADe,EAAQsB,EAAgB,IAAI7E,EAAW,EAAE,IAEtD2F,EAAiB3F,GAAY2D,CAAM,IAEnC0B,EAAcrF,GAAY2D,CAAM;AAAA,EAEpC,GAEMmC,IAAwB,CAAC/F,GAAkB4D,IAASJ,EAAO,UAAU;AACzE,UAAM3E,IAAUmB,EAAY,OAAO,CAACnB,GAASoB,MAAe;AAC1D,YAAMiC,IAAIsD,EAAoBvF,CAAU;AACxC,aAAOiC,IAAI,CAAC,GAAGrD,GAASqD,CAAC,IAAIrD;AAAAA,IAC/B,GAAG,CAAA,CAAiB;AAEpB,IAAIA,EAAQ,SAAS,KACnBwG,EAAKzB,GAAQ,EAAE,SAAA/E,GAAS;AAAA,EAC5B,GAEMmH,IAAwB,CAAChG,GAA2B4D,IAASJ,EAAO,UAAU;AAClF,UAAM+B,IAAYvF,EAAY,IAAI2E,CAAQ,GAEpC,EAAE,OAAAsB,GAAO,UAAAC,EAAA,IAAaX,EAAU,OAAsC,CAACY,GAAKlG,MACzD6E,EAAgB,IAAI7E,EAAW,EAAE,IAE/C,EAAC,GAAGkG,GAAK,UAAU,CAAC,GAAGA,EAAI,UAAUlG,CAAU,EAAA,IAE/C,EAAC,GAAGkG,GAAK,OAAO,CAAC,GAAGA,EAAI,OAAOlG,CAAU,EAAA,GAEjD,EAAE,OAAO,CAAA,GAAI,UAAU,CAAA,GAAI,GAExBpB,IAAUqH,EAAS,IAAI,CAAA1I,MAAKgI,EAAoBhI,GAAGoG,CAAM,CAAE,EAAE,OAAO,OAAO;AAEjF,IAAAqC,EAAM,QAAQ,CAAAhG,MAAc;AAC1B,MAAA6E,EAAgB,IAAI7E,EAAW,IAAIA,CAAU,GAC7CA,EAAW,OAAO,QAAQ,CAAAxC,MAAKsH,EAAU,IAAItH,EAAE,IAAIwC,EAAW,EAAE,CAAC;AAAA,IACnE,CAAC,GAEDoF,EAAKzB,GAAQ,EAAE,SAASqC,GAAO,SAAApH,GAAS;AAAA,EAC1C,GAEMuH,IAAU,CAACnE,GAA2B2B,IAASJ,EAAO,UAAU;AACpE,UAAMzE,IAAW+F,EAAgB,IAAI7C,EAAK,UAAU;AACpD,QAAIlD,GAAU;AACZ,YAAM4D,IAAW;AAAA,QACf,GAAG5D;AAAA,QACH,QAAQ,CAAE,GAAGA,EAAS,QAAQkD,CAAK;AAAA,MAAA;AAGrC,MAAA6C,EAAgB,IAAI/F,EAAS,IAAI4D,CAAQ,GAEzCoC,EAAU,IAAI9C,EAAK,IAAIU,EAAS,EAAE,GAMlC0C,EAAKzB,GAAQ,EAAE,SAAS,CAJE;AAAA,QACxB,UAAA7E;AAAA,QAAU,UAAA4D;AAAA,QAAU,eAAe,CAAEV,CAAK;AAAA,MAAA,CAGb,GAAG;AAAA,IACpC;AACE,cAAQ,KAAK,8CAA8CA,EAAK,UAAU,EAAE;AAAA,EAEhF,GAEMoE,IAAM,MAAM,CAAC,GAAGvB,EAAgB,QAAQ,GAExCvF,IAAQ,CAACqE,IAASJ,EAAO,UAAU;AACvC,UAAM6C,IAAM,CAAC,GAAGvB,EAAgB,QAAQ;AAExC,IAAAA,EAAgB,MAAA,GAChBC,EAAU,MAAA,GAEVM,EAAKzB,GAAQ,EAAE,SAASyC,EAAAA,CAAK;AAAA,EAC/B,GAEMC,IAAqB,CAACtG,GAA2BuG,IAAU,IAAM3C,IAASJ,EAAO,UAAU;AAC/F,UAAM+B,IAAYvF,EAAY,IAAI2E,CAAQ;AAE1C,QAAI4B,GAAS;AAEX,YAAM7B,IAAU,CAAC,GAAGI,EAAgB,QAAQ;AAC5C,MAAAA,EAAgB,MAAA,GAChBC,EAAU,MAAA,GAEVQ,EAAU,QAAQ,CAAAtF,MAAc;AAC9B,QAAA6E,EAAgB,IAAI7E,EAAW,IAAIA,CAAU,GAC7CA,EAAW,OAAO,QAAQ,CAAAxC,MAAKsH,EAAU,IAAItH,EAAE,IAAIwC,EAAW,EAAE,CAAC;AAAA,MACnE,CAAC,GAEDoF,EAAKzB,GAAQ,EAAE,SAAS2B,GAAW,SAAAb,GAAS;AAAA,IAC9C,OAAO;AAEL,YAAM8B,IAAWxG,EAAY,OAAO,CAACqG,GAAKI,MAAS;AACjD,cAAMD,IAAWC,EAAK,MAAM3B,EAAgB,IAAI2B,EAAK,EAAE;AACvD,eAAOD,IAAW,CAAC,GAAGH,GAAKG,CAAS,IAAIH;AAAAA,MAC1C,GAAG,CAAA,CAAS;AAEZ,UAAIG,EAAS,SAAS;AACpB,cAAM,MAAM,0DAA0DA,EAAS,IAAI,CAAAhJ,MAAKA,EAAE,EAAE,EAAE,KAAK,IAAI,CAAC,EAAE;AAE5G,MAAA+H,EAAU,QAAQ,CAAAtF,MAAc;AAC9B,QAAA6E,EAAgB,IAAI7E,EAAW,IAAIA,CAAU,GAC7CA,EAAW,OAAO,QAAQ,CAAAxC,MAAKsH,EAAU,IAAItH,EAAE,IAAIwC,EAAW,EAAE,CAAC;AAAA,MACnE,CAAC,GAEDoF,EAAKzB,GAAQ,EAAE,SAAS2B,EAAA,CAAW;AAAA,IACrC;AAAA,EACF,GAEMmB,IAAsB,CAAC/G,MAA+B;AAC1D,UAAMC,IAAK,OAAOD,KAAmB,WAAWA,IAAiBA,EAAe,IAE1E6G,IAAW1B,EAAgB,IAAIlF,CAAE;AACvC,QAAI4G;AACF,aAAA1B,EAAgB,OAAOlF,CAAE,GACzB4G,EAAS,OAAO,QAAQ,CAAA/I,MAAKsH,EAAU,OAAOtH,EAAE,EAAE,CAAC,GAC5C+I;AAEP,YAAQ,KAAK,yCAAyC5G,CAAE,EAAE;AAAA,EAE9D,GAEM+G,IAAmB,CAAChH,GAA4BiE,IAASJ,EAAO,UAAU;AAC9E,UAAMkB,IAAUgC,EAAoB/G,CAAc;AAClD,IAAI+E,KACFW,EAAKzB,GAAQ,EAAE,SAAS,CAAEc,CAAS,GAAE;AAAA,EACzC,GAEMkC,IAAwB,CAACC,GAAkCjD,IAASJ,EAAO,UAAU;AACzF,UAAMkB,IAAUmC,EAAiB,OAAO,CAACnC,GAASZ,MAAQ;AACxD,YAAM0C,IAAWE,EAAoB5C,CAAG;AACxC,aAAO0C,IAAW,CAAC,GAAG9B,GAAS8B,CAAQ,IAAI9B;AAAAA,IAC7C,GAAG,CAAA,CAAS;AAEZ,IAAIA,EAAQ,SAAS,KACnBW,EAAKzB,GAAQ,EAAE,SAAAc,GAAS;AAAA,EAC5B,GAEMoC,IAAgB,CAAC7E,MAAmC;AACxD,UAAM8E,IAAgBjC,EAAgB,IAAI7C,EAAK,UAAU;AAEzD,QAAI8E,GAAe;AACjB,YAAM9D,IAAU8D,EAAc,OAAO,KAAK,OAAKtJ,EAAE,OAAOwE,EAAK,EAAE;AAE/D,UAAIgB,GAAS;AACX,QAAA8B,EAAU,OAAO9B,EAAQ,EAAE;AAE3B,cAAM+D,IAAgB;AAAA,UACpB,GAAGD;AAAA,UACH,QAAQA,EAAc,OAAO,OAAO,OAAKtJ,EAAE,OAAOwE,EAAK,EAAE;AAAA,QAAA;AAG3D,eAAA6C,EAAgB,IAAIiC,EAAc,IAAIC,CAAa,GAEzB;AAAA,UACxB,UAAUD;AAAA,UAAe,UAAUC;AAAA,UAAe,eAAe,CAAC/D,CAAO;AAAA,QAAA;AAAA,MAI7E;AACE,gBAAQ,KAAK,kCAAkChB,EAAK,EAAE,oBAAoBA,EAAK,UAAU,EAAE;AAAA,IAE/F;AACE,cAAQ,KAAK,kDAAkDA,EAAK,UAAU,EAAE;AAAA,EAEpF,GAEMgF,IAAa,CAAChF,GAAgC2B,IAASJ,EAAO,UAAU;AAC5E,UAAM3E,IAAUiI,EAAc7E,CAAI;AAClC,IAAIpD,KACFwG,EAAKzB,GAAQ,EAAE,SAAS,CAAE/E,CAAS,GAAE;AAAA,EACzC,GAEMqI,IAAmB,CAACC,GAAoCvD,IAASJ,EAAO,UAAU;AACtF,UAAM3E,IAAUsI,EACb,IAAI,CAAA1J,MAAKqJ,EAAcrJ,CAAC,CAAE,EAC1B,OAAO,OAAO;AAEjB,IAAIoB,EAAQ,SAAS,KACnBwG,EAAKzB,GAAQ,EAAE,SAAA/E,GAAS;AAAA,EAC5B,GAEMuI,IAAgB,CAACxH,MAA8B;AACnD,UAAMpC,IAAIsH,EAAgB,IAAIlF,CAAE;AAChC,WAAOpC,IAAI,EAAC,GAAGA,EAAA,IAAK;AAAA,EACtB,GAEM6J,IAAU,CAACzH,MAAgD;AAC/D,UAAM0H,IAAevC,EAAU,IAAInF,CAAE;AACrC,QAAI0H,GAAc;AAEhB,YAAMrF,IADamF,EAAcE,CAAY,EACpB,OAAO,KAAK,CAAA7J,MAAKA,EAAE,OAAOmC,CAAE;AACrD,UAAIqC;AACF,eAAOA;AAEP,cAAQ,MAAM,+BAA+BrC,CAAE,kCAAkC;AAAA,IAErF;AACE,cAAQ,KAAK,qCAAqCA,CAAE,EAAE;AAAA,EAE1D,GAEM2H,IAAgB,CAACC,GAAqCxE,MAAiC;AAC3F,QAAIwE,EAAU,eAAexE,EAAQ;AACnC,YAAM;AAER,UAAM+D,IAAgBjC,EAAgB,IAAI0C,EAAU,UAAU;AAC9D,QAAIT,GAAe;AACjB,YAAM9D,IAAU8D,EAAc,OAAO,KAAK,OAAKtJ,EAAE,OAAO+J,EAAU,EAAE,GAE9DR,IAAgB;AAAA,QACpB,GAAGD;AAAA,QACH,QAAQA,EAAc,OAAO,IAAI,CAAAtJ,MAAKA,EAAE,OAAOwF,EAAQ,KAAKD,IAAUvF,CAAC;AAAA,MAAA;AAGzE,aAAAqH,EAAgB,IAAIiC,EAAc,IAAIC,CAAa,GAE/C/D,EAAQ,OAAOD,EAAQ,OACzB+B,EAAU,OAAO9B,EAAQ,EAAE,GAC3B8B,EAAU,IAAI/B,EAAQ,IAAIgE,EAAc,EAAE,IAGrC;AAAA,QACL,UAAUD;AAAA,QACV,UAAUC;AAAA,QACV,eAAe,CAAC,EAAE,SAAA/D,GAAS,SAAAD,GAAS;AAAA,MAAA;AAAA,IAExC;AACE,cAAQ,KAAK,6CAA6CwE,EAAU,UAAU,EAAE;AAAA,EAEpF,GAEMC,IAAa,CAACD,GAAqCxE,GAA8BY,IAASJ,EAAO,UAAU;AAC/G,UAAMnF,IAASkJ,EAAcC,GAAWxE,CAAO;AAC/C,IAAI3E,KACFgH,EAAKzB,GAAQ,EAAE,SAAS,CAAEvF,CAAO,GAAG;AAAA,EACxC,GAEMqJ,IAAmB,CAACP,GAAoCvD,IAASJ,EAAO,UAAU;AACtF,UAAM3E,IAAUsI,EACb,IAAI,CAAA1J,MAAK8J,EAAc,EAAE,IAAI9J,EAAE,IAAI,YAAYA,EAAE,WAAA,GAAcA,CAAC,CAAE,EAClE,OAAO,OAAO;AAEjB,IAAA4H,EAAKzB,GAAQ,EAAE,SAAA/E,GAAS;AAAA,EAC1B,GAEM8I,IAAkB,CAACC,MAA+C;AACtE,UAAM7I,IAAW+F,EAAgB,IAAI8C,EAAO,UAAU;AAEtD,QAAI7I,GAAU;AACZ,YAAM4D,IAAW;AAAA,QACf,GAAG5D;AAAA,QACH,QAAQ;AAAA,UACN,GAAGA,EAAS;AAAA,UACZ,GAAG6I;AAAA,QAAA;AAAA,MACL;AAGF,aAAA9C,EAAgB,IAAI/F,EAAS,IAAI4D,CAAQ,GAElC;AAAA,QACL,UAAA5D;AAAA,QAAU,UAAA4D;AAAA,QAAU,eAAe;AAAA,UACjC,WAAW5D,EAAS;AAAA,UACpB,WAAW6I;AAAA,QAAA;AAAA,MACb;AAAA,IAEJ;AACE,cAAQ,KAAK,mDAAmDA,EAAO,UAAU,EAAE;AAAA,EAEvF;AAeD,SAAO;AAAA,IACJ,eAAAtC;AAAA,IACA,SAAAc;AAAA,IACA,KAAAC;AAAA,IACA,oBAAAC;AAAA,IACA,uBAAAM;AAAA,IACA,kBAAAM;AAAA,IACA,uBAAAnB;AAAA,IACA,kBAAA2B;AAAA,IACA,mBAhBwB,CAACG,GAA6BjE,IAASJ,EAAO,UAAU;AAChF,YAAM3E,IACJgJ,EAAQ,IAAI,CAAAC,MAAKH,EAAgBG,CAAC,CAAE,EAAE,OAAO,OAAO;AACtD,MAAIjJ,EAAQ,SAAS,KACnBwG,EAAKzB,GAAQ,EAAE,SAAA/E,GAAS;AAAA,IAC5B;AAAA,IAYE,uBAAAmH;AAAA,IACA,OAAAzG;AAAA,IACA,kBAAAoH;AAAA,IACA,YAAAM;AAAA,IACA,eAAAG;AAAA,IACA,SAAAC;AAAA,IACA,SAAApC;AAAA,IACA,WAAAE;AAAA,IACA,kBAAAS;AAAA,IACA,YAAA6B;AAAA,IACA,cAjCmB,CAACG,GAAqBhE,IAASJ,EAAO,UAAU;AACnE,YAAMnF,IAASsJ,EAAgBC,CAAM;AACrC,MAAIvJ,KACFgH,EAAKzB,GAAQ,EAAE,SAAS,CAAEvF,CAAO,GAAG;AAAA,IACxC;AAAA,IA8BE,kBAAAyH;AAAA,EAAA;AAGJ,GCpYaiC,KAAgB,CAAoCpJ,OAiBxD;AAAA,EACL,GAAGA;AAAA,EACH,WAjBgB,CAACuG,MAA4B;AAG7C,UAAM8C,IAAO,CAACjI,MAA+BmF,EAASnF,EAAM,KAAK;AACjE,WAAApB,EAAM,QAAQqJ,CAAI,GAKlB9C,EAASvG,EAAM,KAAK,GAGb,MAAMA,EAAM,UAAUqJ,CAAI;AAAA,EACnC;AAIE;AClDG,IAAIC,IAAmB,OAAO;AAAA,EACnC,KAAKlI,MAAUmI,GAAM;AACnB,aACMC,IAAY,KAAK,OAAOpI,CAAK,KAAK,CAAA,GACpC3B,IAAI,GACJgK,IAASD,EAAU,QACrB/J,IAAIgK,GACJhK;AAEA,MAAA+J,EAAU/J,CAAC,EAAE,GAAG8J,CAAI;AAAA,EAExB;AAAA,EACA,QAAQ,CAAA;AAAA,EACR,GAAGnI,GAAOsI,GAAI;AdbhB,QAAA5I;AccK,aAACA,IAAA,KAAK,QAALM,OAAAN,EAAAM,KAAuB,CAAA,IAAI,KAAKsI,CAAE,GAC7B,MAAM;AdfjB,UAAA5I;AcgBM,WAAK,OAAOM,CAAK,KAAIN,IAAA,KAAK,OAAOM,CAAK,MAAjB,gBAAAN,EAAoB,OAAO,CAAArB,MAAKiK,MAAOjK;AAAA,IAC9D;AAAA,EACF;AACF;ACVA,MAAMkK,KAAW,KAoCJC,KAAkB,CAAuB5J,GAAiB6J,MAAuC;AAE5G,QAAMC,IAAUR,EAAA,GAEVS,KAA8BF,KAAA,gBAAAA,EAAS,YAAW,CAAA;AAExD,MAAIG,IAAUH,IAAUA,EAAQ,UAAU,IAEtCI,IAAa,IAEbC,IAAY;AAEhB,QAAM3D,IAAW,CAACnF,MAA+B;AAC/C,QAAI,CAAC6I,GAAY;AACf,YAAM,EAAE,SAAA9J,MAAYiB,GAEd+I,IAAM,YAAY,IAAA;AAExB,UAAIA,IAAMD,IAAYP;AAEpB,QAAAI,EAAY,OAAOC,IAAU,CAAC,GAC9BD,EAAY,KAAK5J,CAAO,GAGxB6J,IAAUD,EAAY,SAAS;AAAA,WAC1B;AAEL,cAAMK,IAAOL,EAAY,SAAS;AAClC,QAAAA,EAAYK,CAAI,IAAI7E,GAAawE,EAAYK,CAAI,GAAGjK,CAAO;AAAA,MAC7D;AAEA,MAAA+J,IAAYC;AAAA,IACd;AAEA,IAAAF,IAAa;AAAA,EACf;AAEA,EAAAjK,EAAM,QAAQuG,GAAU,EAAE,QAAQ1B,EAAO,OAAO;AAEhD,QAAMwF,IAAc,CAACxG,MACnBA,KAAWA,EAAQ,SAAS,KAAK7D,EAAM,sBAAsB6D,CAAO,GAEhEyG,IAAc,CAACzG,MACnBA,KAAWA,EAAQ,SAAS,KAAK7D,EAAM,mBAAmB6D,GAAS,EAAK,GAEpE0G,IAAc,CAACrK,MACnBA,KAAWA,EAAQ,SAAS,KAAKF,EAAM,sBAAsBE,EAAQ,IAAI,CAAC,EAAE,UAAAE,EAAA,MAAeA,CAAQ,CAAC,GAEhGoK,IAAc,CAACtK,MACnBA,KAAWA,EAAQ,SAAS,KAAKF,EAAM,sBAAsBE,EAAQ,IAAI,CAAC,EAAE,UAAA8D,EAAA,MAAeA,CAAQ,CAAC,GAEhGyG,IAAc,CAAC1E,MACnBA,KAAWA,EAAQ,SAAS,KAAK/F,EAAM,mBAAmB+F,GAAS,EAAK,GAEpE2E,IAAc,CAAC3E,MACnBA,KAAWA,EAAQ,SAAS,KAAK/F,EAAM,sBAAsB+F,CAAO;AA6CtE,SAAO;AAAA,IACL,SAVc,MAAMgE,EAAY,SAAS,IAAIC;AAAA,IAW7C,SA7Bc,MAAMA,IAAU;AAAA,IA8B9B,SAVc,MAAMhK,EAAM,UAAUuG,CAAQ;AAAA,IAW5C,YATiB,OAAO,EAAE,SAAS,CAAC,GAAGwD,CAAW,GAAG,SAAAC;IAUrD,IARS,CAAqC5I,GAAUuJ,MACxDb,EAAQ,GAAG1I,GAAOuJ,CAAQ;AAAA,IAQ1B,MA/BW,MAAM;AACjB,UAAIZ,EAAY,SAAS,IAAIC,GAAS;AACpC,QAAAC,IAAa;AAEb,cAAM,EAAE,SAAApG,GAAS,SAAA3D,GAAS,SAAA6F,MAAYgE,EAAYC,IAAU,CAAC;AAE7D,QAAAM,EAAYzG,CAAO,GACnB2G,EAAYtK,CAAO,GACnBwK,EAAY3E,CAAO,GAEnB+D,EAAQ,KAAK,QAAQC,EAAYC,IAAU,CAAC,CAAC,GAE7CA,KAAW;AAAA,MACb;AAAA,IACF;AAAA,IAkBE,MAlDW,MAAM;AACjB,UAAIA,IAAU,IAAI;AAChB,QAAAC,IAAa;AAEb,cAAM,EAAE,SAAApG,GAAS,SAAA3D,GAAS,SAAA6F,EAAA,IAAYgE,EAAYC,CAAO;AAEzD,QAAAK,EAAYxG,CAAO,GACnB0G,EAAYrK,CAAO,GACnBuK,EAAY1E,CAAO,GAEnB+D,EAAQ,KAAK,QAAQC,EAAYC,CAAO,CAAC,GAEzCA,KAAW;AAAA,MACb;AAAA,IACF;AAAA,EAoCE;AAGJ,GCvJaY,KAAsB,MAAM;AAEvC,QAAM,EAAE,WAAAhL,GAAW,KAAAP,MAAQL,EAAmB,CAAA,CAAE;AAEhD,SAAO;AAAA,IACL,WAAAY;AAAA,IACA,KAAAP;AAAA,EAAA;AAGJ,GCJawL,KAA0B,CACrCC,GACAC,GACAtK,GACAuK,MACG;AACH,QAAM,EAAE,OAAAC,GAAO,WAAAC,GAAW,OAAAlL,GAAO,UAAAmL,MAAaL,GAExCzE,wBAAwD,IAAA;AAG9D,MAAI+E,IAAwB,CAAA,GAExBnL,GAEAoL;AAEJ,QAAMC,IAAK,CAAkClK,GAAUuJ,MAAoC;AACzF,IAAItE,EAAU,IAAIjF,CAAK,IACrBiF,EAAU,IAAIjF,CAAK,EAAG,KAAKuJ,CAAQ,IAEnCtE,EAAU,IAAIjF,GAAO,CAACuJ,CAAQ,CAAC;AAAA,EAEnC,GAEMY,IAAM,CAAqCnK,GAAUuJ,MAAoC;AAC7F,UAAMnB,IAAYnD,EAAU,IAAIjF,CAAK;AACrC,QAAIoI,GAAW;AACb,YAAM/C,IAAM+C,EAAU,QAAQmB,CAAQ;AACtC,MAAIlE,MAAQ,MACV+C,EAAU,OAAO/C,GAAK,CAAC;AAAA,IAC3B;AAAA,EACF,GAEMC,IAAO,CAACtF,GAAiCoK,GAAe1E,MAA4B;AACxF,IAAIT,EAAU,IAAIjF,CAAK,KACrB,WAAW,MAAM;AACf,MAAAiF,EAAU,IAAIjF,CAAK,EAAG,QAAQ,CAAAuJ,MAAY;AACxC,YAAIlK,GAAS;AACX,gBAAMgL,IAAc,MAAM,QAAQD,CAAI,IACpCA,EAAK,IAAI,CAAA3M,MAAK4B,EAAQ,UAAU5B,CAAC,CAAC,IAAI4B,EAAQ,UAAU+K,CAAI,GAExDE,IACJ5E,IAAOA,aAAgB,eAAeA,IAAOrG,EAAQ,UAAUqG,CAAI,IAAI;AAEzE,UAAA6D,EAASc,GAAwBC,CAAW;AAAA,QAC9C;AACE,UAAAf,EAASa,GAAiB1E,CAAoB;AAAA,MAElD,CAAC;AAAA,IACH,GAAG,CAAC;AAAA,EAER,GAEM6E,IAAe,MAAM;AACzB,UAAM,EAAE,UAAApK,MAAa2J,GAIfU,KAAmBrK,KAAY,CAAA,GAAI,IAAI,CAAC,EAAE,IAAAN,QAASjB,EAAM,cAAciB,CAAE,CAAE;AAEjF,IAAA2K,EAAgB,QAAQ,CAAA1L,MAAW;AACjC,YAAM2L,IAAUT,EAAiB,KAAK,OAAKvM,EAAE,OAAOqB,EAAQ,EAAE;AAC9D,OAAI,CAAC2L,KAAW,CAACvN,EAAOuN,GAAS3L,CAAO,MACtCwG,EAAK,oBAAoBxG,GAAS2L,CAAO;AAAA,IAE7C,CAAC,GAEDT,IAAmBA,EAAiB,IAAI,CAAAS,MAAW;AACjD,YAAM3L,IAAU0L,EAAgB,KAAK,CAAC,EAAE,IAAA3K,QAASA,MAAO4K,EAAQ,EAAE;AAClE,aAAO3L,KAAoB2L;AAAA,IAC7B,CAAC;AAAA,EACH;AAEA,EAAAX,EAAU,UAAU,CAAC,EAAE,UAAA3J,QAAc;AACnC,QAAI,EAAA6J,EAAiB,WAAW,KAAK7J,EAAS,WAAW,IAGzD;AAAA,UAAI6J,EAAiB,WAAW,KAAK7J,EAAS,SAAS;AAErD,QAAA6J,IAAmB7J,EAAS,IAAI,CAAC,EAAE,IAAAN,QAASjB,EAAM,cAAciB,CAAE,CAAE;AAAA,eAC3DmK,EAAiB,SAAS,KAAK7J,EAAS,WAAW;AAE5D,QAAA6J,EAAiB,QAAQ,CAAAS,MAAW;AAClC,gBAAMC,IAAe9L,EAAM,cAAc6L,EAAQ,EAAE;AAEnD,UAAIC,KAAgB,CAACxN,EAAOwN,GAAcD,CAAO,KAC/CnF,EAAK,oBAAoBoF,GAAcD,CAAO;AAAA,QAElD,CAAC,GAEDT,IAAmB,CAAA;AAAA,WACd;AAEL,cAAMW,IAAa,IAAI,IAAIX,EAAiB,IAAI,CAAAvM,MAAKA,EAAE,EAAE,CAAC,GACpDmN,IAAc,IAAI,IAAIzK,EAAS,IAAI,CAAC,EAAE,IAAAN,QAASA,CAAE,CAAC;AAIxD,QADmBmK,EAAiB,OAAO,CAAAvM,MAAK,CAACmN,EAAY,IAAInN,EAAE,EAAE,CAAC,EAC3D,QAAQ,CAAAgN,MAAW;AAC5B,gBAAMC,IAAe9L,EAAM,cAAc6L,EAAQ,EAAE;AAEnD,UAAIC,KAAgB,CAACxN,EAAOwN,GAAcD,CAAO,KAC/CnF,EAAK,oBAAoBoF,GAAcD,CAAO;AAAA,QAClD,CAAC,GAEDT,IAAmB;AAAA;AAAA,UAEjB,GAAGA,EAAiB,OAAO,CAAAvM,MAAKmN,EAAY,IAAInN,EAAE,EAAE,CAAC;AAAA;AAAA,UAErD,GAAG0C,EACA,OAAO,CAAC,EAAE,IAAAN,EAAA,MAAS,CAAC8K,EAAW,IAAI9K,CAAE,CAAC,EACtC,IAAI,CAAC,EAAE,IAAAA,QAASjB,EAAM,cAAciB,CAAE,CAAE;AAAA,QAAA;AAAA,MAE/C;AAEA,MAAAyF,EAAK,oBAAoB0E,CAAgB;AAAA;AAAA,EAC3C,CAAC,GAEDH,EAAM,UAAU,CAAAhK,MAAM;AACpB,IAAI,CAAChB,KAAgBgB,IACnByF,EAAK,wBAAwB1G,EAAM,cAAciB,CAAE,CAAE,IAC5ChB,KAAgB,CAACgB,IAC1ByF,EAAK,wBAAwB1G,EAAM,cAAcC,CAAY,CAAE,IACtDA,KAAgBgB,MACzByF,EAAK,wBAAwB1G,EAAM,cAAcC,CAAY,CAAE,GAC/DyG,EAAK,wBAAwB1G,EAAM,cAAciB,CAAE,CAAE,IAGvDhB,IAAegB;AAAA,EACjB,CAAC,GAEDkK,KAAA,QAAAA,EAAU,UAAU,CAAAtJ,MAClB6E,EAAK,qBAAqB7E,EAAI,IAAI,CAAAZ,MAAMjB,EAAM,cAAciB,CAAE,CAAE,CAAC,IAEnEjB,EAAM,QAAQ,CAAAoB,MAAS;AAErB,IAAI4J,MACEK,KACF,aAAaA,CAAW,GAE1BA,IAAc,WAAWM,GAAc,GAAI;AAI7C,UAAM,EAAE,SAAA9H,GAAS,SAAAkC,EAAA,IAAY3E,EAAM;AACnC,KAACyC,KAAW,CAAA,GAAI,QAAQ,OAAK6C,EAAK,oBAAoB7H,CAAC,CAAC,IACvDkH,KAAW,CAAA,GAAI,QAAQ,OAAKW,EAAK,oBAAoB7H,CAAC,CAAC,IAG/BuC,EAAM,QAAQ,WAAW,IAAI,OAAO,CAAAmC,MAAK;AAAA,MAChE,GAAIA,EAAE,iBAAiB,CAAA;AAAA,MACvB,GAAIA,EAAE,iBAAiB,CAAA;AAAA,MACvB,GAAIA,EAAE,iBAAiB,CAAA;AAAA,IAAC,EACxB,SAAS,CAAC,EAGI,QAAQ,CAAC,EAAE,UAAAnD,GAAU,UAAA4D,QAAe;AAClD,YAAM6H,IAAUT,EAAiB,KAAK,CAAAvM,MAAKA,EAAE,OAAOuB,EAAS,EAAE,KAAKA;AAGpE,MAAAgL,IAAmBA,EAChB,IAAI,CAAAvM,MAAKA,EAAE,OAAOuB,EAAS,KAAK4D,IAAWnF,CAAC,GAE/C6H,EAAK,oBAAoB1C,GAAU6H,CAAO;AAAA,IAC5C,CAAC;AAAA,EACH,GAAG,EAAE,QAAQhH,EAAO,OAAO,GAG3B7E,EAAM,QAAQ,CAAAoB,MAAS;AACrB,QAAIgK,GAAkB;AACpB,YAAMY,IAAc,IAAI,IAAIZ,EAAiB,IAAI,CAAAvM,MAAKA,EAAE,EAAE,CAAC,GAErDoN,KAAmB7K,EAAM,QAAQ,WAAW,IAC/C,OAAO,CAAC,EAAE,UAAA4C,EAAA,MAAegI,EAAY,IAAIhI,EAAS,EAAE,CAAC,EACrD,IAAI,CAAC,EAAE,UAAAA,EAAA,MAAeA,CAAQ;AAEjC,MAAIiI,EAAgB,SAAS,MAC3Bb,IAAmBA,EAAiB,IAAI,CAAA7J,MAAY;AAClD,cAAMrB,IAAU+L,EAAgB,KAAK,CAAA/L,MAAWA,EAAQ,OAAOqB,EAAS,EAAE;AAC1E,eAAOrB,KAAoBqB;AAAA,MAC7B,CAAC;AAAA,IAEL;AAAA,EACF,GAAG,EAAE,QAAQsD,EAAO,QAAQ;AAE5B,QAAMqH,IAAe,CAACC,MAAkB,CAAChM,MAA0B;AAGjE,UAAM,EAAE,SAAAD,MAAYC;AAEpB,IAAIgM,KACDjM,KAAW,CAAA,GAAI,QAAQ,CAAAiJ,MAAKzC,EAAK,oBAAoByC,EAAE,UAAUA,EAAE,QAAQ,CAAC,KAE5EjJ,KAAW,CAAA,GAAI,QAAQ,CAAAiJ,MAAKzC,EAAK,oBAAoByC,EAAE,UAAUA,EAAE,QAAQ,CAAC;AAAA,EACjF;AAEA,SAAA4B,EAAU,GAAG,QAAQmB,EAAa,EAAI,CAAC,GACvCnB,EAAU,GAAG,QAAQmB,EAAa,EAAK,CAAC,GAEjC,EAAE,IAAAZ,GAAI,KAAAC,GAAK,MAAA7E,EAAA;AAEpB,GC/La0F,KACX,CAA0C3L,MACxC,CAACY,MAAqBA,EAAY,IAAI,CAAAxC,MAAK4B,EAAQ,UAAU5B,CAAC,CAAC,GAEtDwN,KACX,CAA0C5L,MACxC,CAAC6L,MAAoBA,EAAW,OAAO,CAACC,GAAQzE,MAAS;AACvD,QAAM,EAAE,QAAA0E,GAAQ,OAAAC,EAAA,IAAUhM,EAAQ,MAAMqH,CAAI;AAE5C,SAAO2E,IAAQ;AAAA,IACb,QAAQF,EAAO;AAAA,IACf,QAAQ,CAAC,GAAGA,EAAO,QAAQzE,CAAK;AAAA,EAAA,IAC9B0E,IAAS;AAAA,IACX,QAAQ,CAAC,GAAGD,EAAO,QAAQC,CAAO;AAAA,IAClC,QAAQD,EAAO;AAAA,EAAA,IACb;AAAA,IACF,GAAGA;AAAA,EAAA;AAEP,GAAG,EAAE,QAAQ,IAAW,QAAQ,CAAA,GAAU,GCwDjCG,KAAsB,CACjC5B,GACAC,GACAtK,MACG;AAEH,QAAM,EAAE,OAAAT,GAAO,WAAAkL,EAAA,IAAcJ,GAEvBnE,IAAgB,CAACrF,MAAkB;AACvC,QAAIb,GAAS;AACX,YAAM,EAAE,QAAA+L,GAAQ,OAAAC,EAAA,IAAUhM,EAAQ,MAAMa,CAAU;AAClD,MAAIkL,IACFxM,EAAM,cAAcwM,GAAQ3H,EAAO,MAAM,IAEzC,QAAQ,MAAM4H,CAAK;AAAA,IAEvB;AACE,MAAAzM,EAAM,cAAcwD,EAAelC,CAAU,GAAGuD,EAAO,MAAM;AAAA,EAEjE,GAEM8H,IAAiB,MAAMzB,EAAU,MAAA,GAEjC0B,IAAmB,MAAM5M,EAAM,MAAA,GAE/B6M,IAAoB,CAAC5L,MAA8B;AACvD,UAAMK,IAAatB,EAAM,cAAciB,CAAE;AACzC,WAAQR,KAAWa,IACjBb,EAAQ,UAAUa,CAAU,IAASA;AAAA,EACzC,GAEMwL,IAAiB,MACpBrM,IAAUT,EAAM,IAAA,EAAM,IAAIS,EAAQ,SAAS,IAAIT,EAAM,IAAA,GAElD+M,IAAc,MAAM;AnBhI5B,QAAAjM;AmBmII,UAAMS,OAFcT,IAAAoK,EAAU,aAAV,gBAAApK,EAAoB,IAAI,OAAKkM,EAAE,QAAO,CAAA,GAE7B,IAAI,CAAA/L,MAAMjB,EAAM,cAAciB,CAAE,CAAE,EAAE,OAAO,OAAO;AAE/E,WAAOR,IACHc,EAAS,IAAId,EAAQ,SAAS,IAC9Bc;AAAA,EACN,GAEM0L,IAAkB,CAACC,GAAatF,IAAU,OAC9C,MAAMsF,CAAG,EACN,KAAK,CAACC,MAAaA,EAAS,KAAA,CAAM,EAClC,KAAK,CAAC9L,OACL+L,EAAe/L,GAAauG,CAAO,GAC5BvG,EACR,GAECgM,IAAmB,CAAClI,MAAmC;AAC3D,QAAI,OAAOA,KAAQ,UAAU;AAC3B,YAAM7D,IAAatB,EAAM,cAAcmF,CAAG;AAG1C,UAFAnF,EAAM,iBAAiBmF,CAAG,GAEtB7D;AACF,eAAOb,IAAUA,EAAQ,UAAUa,CAAU,IAAIA;AAAA,IACrD,OAAO;AACL,YAAMA,IAAab,IAAUA,EAAQ,MAAM0E,CAAG,EAAE,SAAUA;AAE1D,UAAI7D;AACF,eAAAtB,EAAM,iBAAiBsB,CAAU,GAC1B6D;AAAA,IAEX;AAAA,EACF,GAEMiI,IAAiB,CAAC/L,GAAkBuG,IAAU,OAAS;AAC3D,QAAInH,GAAS;AACX,YAAM6M,IAAU7M,EAAQ,YAAY4L,GAAS5L,CAAO,GAC9C,EAAE,QAAA+L,GAAQ,QAAAe,MAAWD,EAAQjM,CAAW;AAE9C,MAAIkM,EAAO,SAAS,KAClB,QAAQ,KAAK,aAAaA,EAAO,MAAM,wBAAwBA,CAAM,GAEvEvN,EAAM,mBAAmBwM,GAAQ5E,GAAS/C,EAAO,MAAM;AAAA,IACzD;AACE,MAAA7E,EAAM,mBAAmBqB,EAAY,IAAImC,CAAc,GAAGoE,GAAS/C,EAAO,MAAM;AAAA,EAEpF,GAEMlD,IAAc,CAACwD,GAAyBvD,MAAuB;AACnE,IAAIuD,IACF+F,EAAU,YAAY/F,GAAKvD,CAAQ,IAEnCsJ,EAAU,MAAA;AAAA,EAEd,GAEMlJ,IAAsB,CAACP,MAA0C;AACrE,IAAAyJ,EAAU,oBAAoBzJ,CAAM;AAAA,EACtC,GAEMwF,IAAmB,CAAC/G,MAAkB;AAC1C,QAAIO,GAAS;AACX,YAAMyB,IAAczB,EAAQ,MAAMP,CAAO,EAAE,QACrCsN,IAAW/M,EAAQ,UAAUT,EAAM,cAAckC,EAAY,EAAE,CAAE;AACvE,aAAAlC,EAAM,iBAAiBkC,CAAW,GAC3BsL;AAAA,IACT,OAAO;AACL,YAAMA,IAAWxN,EAAM,cAAeE,EAAyB,EAAE;AACjE,aAAAF,EAAM,iBAAiBwD,EAAetD,CAAO,CAAC,GACvCsN;AAAA,IACT;AAAA,EACF;AAKA,SAAO;AAAA,IACL,eAAA7G;AAAA,IACA,gBAAAgG;AAAA,IACA,SAAS5B,EAAU;AAAA,IACnB,SAASA,EAAU;AAAA,IACnB,kBAAA6B;AAAA,IACA,mBAAAC;AAAA,IACA,gBAAAC;AAAA,IACA,YAAY/B,EAAU;AAAA,IACtB,aAAAgC;AAAA,IACA,iBAAAE;AAAA,IACA,MAAMlC,EAAU;AAAA,IAChB,kBAAAsC;AAAA,IACA,gBAAAD;AAAA,IACA,aAAAzL;AAAA,IACA,qBAAAK;AAAA,IACA,MAAM+I,EAAU;AAAA,IAChB,kBAAA9D;AAAA,EAAA;AAGJ,GCnMawG,KAAe,CAC1BnM,GACAoM,GACA5C,MAEO,OAAO4C,KAAU,aAAaA,EAAMpM,GAAYwJ,CAAK,IAAI4C,GAGrDC,KAAc,CACzBC,GACAC,MAEI,OAAOD,KAAe,cAAc,OAAOC,KAAgB,aAEtD;AAAA,EACL,GAAID,KAAc,CAAA;AAAA,EAClB,GAAIC,KAAe,CAAA;AAAC,IAIf,CAAChP,GAAMiM,MAA2B;AACvC,QAAMgD,IAAQ,OAAOF,KAAe,aAAaA,EAAW/O,GAAGiM,CAAK,IAAI8C,GAClEG,IAAS,OAAOF,KAAgB,aAAaA,EAAYhP,GAAGiM,CAAK,IAAI+C;AAE3E,SAAO;AAAA,IACL,GAAIC,KAAS,CAAA;AAAA,IACb,GAAIC,KAAU,CAAA;AAAA,EAAC;AAEnB,GC1DSC,KACX;ACEK,IAAIC,KAAS,CAAAC,MAAS,OAAO,gBAAgB,IAAI,WAAWA,CAAK,CAAC,GAC9DC,KAAe,CAACC,GAAUC,GAAaC,MAAc;AAC9D,MAAIC,KAAQ,KAAK,KAAK,KAAKH,EAAS,SAAS,CAAC,KAAK,GAC/CI,IAAO,CAAC,EAAG,MAAMD,IAAOF,IAAeD,EAAS;AACpD,SAAO,CAACK,IAAOJ,MAAgB;AAC7B,QAAIpN,IAAK;AACT,eAAa;AACX,UAAIiN,IAAQI,EAAUE,CAAI,GACtBE,IAAIF,IAAO;AACf,aAAOE;AAEL,YADAzN,KAAMmN,EAASF,EAAMQ,CAAC,IAAIH,CAAI,KAAK,IAC/BtN,EAAG,UAAUwN,EAAM,QAAOxN;AAAA,IAElC;AAAA,EACF;AACF,GACW0N,KAAiB,CAACP,GAAUK,IAAO,OAC5CN,GAAaC,GAAUK,IAAO,GAAGR,EAAM,GAC9BW,KAAS,CAACH,IAAO,OAAO;AACjC,MAAIxN,IAAK,IACLiN,IAAQ,OAAO,gBAAgB,IAAI,WAAYO,KAAQ,CAAC,CAAE;AAC9D,SAAOA;AACL,IAAAxN,KAAM4N,GAAkBX,EAAMO,CAAI,IAAI,EAAE;AAE1C,SAAOxN;AACT;ACdO,MAAM6N,KAAuB,OAG3B,EAAE,SAAS,IAAM,IAFTH,GAAe,mEAAmE,EAAE,IAEhE,ICoD/BI,KAAW,CAACC,MAAwB;AACxC,QAAMC,IAAM,KAAK,UAAUD,CAAG;AAE9B,MAAIE,IAAO;AAEX,WAASzP,IAAI,GAAGf,IAAMuQ,EAAI,QAAQxP,IAAIf,GAAKe,KAAK;AAC9C,QAAI0P,IAAMF,EAAI,WAAWxP,CAAC;AAC1B,IAAAyP,KAAQA,KAAQ,KAAKA,IAAOC,GAC5BD,KAAQ;AAAA,EACV;AAEA,SAAO,GAAGA,CAAI;AAChB,GAEaE,KAAe,CAACC,MAAeA,IACxC,OAAOA,KAAS,WAAW,EAAE,GAAGA,EAAA,IAASA,IAAO,QAKvCC,KAAiB,CAC5BhM,GACAqF,OACuB,MAAM,QAAQrF,CAAI,IAAIA,IAAO,CAACA,CAAI,GAAG,IAAI,CAAAA,MAAQ;AAGxE,QAAM,EAAE,IAAArC,GAAI,MAAAsO,GAAM,SAAAC,GAAS,OAAAvQ,GAAO,SAAA4E,GAAS,UAAA4L,GAAU,SAAAvM,GAAS,GAAGwM,EAAA,IAASpM;AAO1E,SAAO;AAAA,IACL,IAAIrC,KAAM,QAAQ8N,GAASzL,CAAI,CAAC;AAAA,IAChC,YAAYqF;AAAA,IACZ,MAAA4G;AAAA,IACA,SAAAC;AAAA,IACA,OAAAvQ;AAAA,IACA,SAASmQ,GAAalM,CAAO;AAAA,IAC7B,SAASW,IAAU,IAAI,KAAKA,CAAO,IAAI;AAAA,IACvC,SAAS4L,IAAW,IAAI,KAAKA,CAAQ,IAAI;AAAA,IACzC,GAAGC;AAAA,EAAA;AAGP,CAAC,GAGYC,KAAqB,CAACnH,MACjCA,EAAO,IAAI,CAAA1J,MAAK;AxBtHlB,MAAAgC;AwBuHI,QAAM,EAAE,YAAYA,GAAI,SAAA+C,GAAS,SAAA3D,GAAS,GAAG0P,MAAa9Q,GAEpD+Q,IAA8B;AAAA,IAClC,GAAGD;AAAA,IACH,SAAS/L,KAAA,gBAAAA,EAAS;AAAA,IAClB,UAAU3D,KAAA,gBAAAA,EAAS;AAAA,EAAY;AAEjC,UAAIY,IAAA+O,EAAQ,OAAR,QAAA/O,EAAY,WAAW,YACzB,OAAO+O,EAAQ,IAGVA;AACT,CAAC,GAEUC,KAAkB,CAACxO,MAC9B,cAAcA,KAAc,aAAaA,KAAc,UAAUA,GCrItDyO,KAA2B;AAAA,EACtC;AAAA;AAAA,EACA;AAAA;AAAA,EACA;AAAA;AAAA,EACA;AAAA;AAAA,EACA;AAAA;AAAA,EACA;AAAA;AAAA,EACA;AAAA;AAAA,EACA;AAAA;AAAA,EACA;AAAA;AACF,GCEaC,KAAuB,MAAM;AAExC,QAAMC,IAAmB,CAAC,GAAGF,EAAe;AAc5C,SAAO,EAAE,mBAZiB,MAAM;AAC9B,UAAMG,IAAM,KAAK,MAAM,KAAK,OAAA,IAAWD,EAAiB,MAAM,GACxDE,IAAQF,EAAiBC,CAAG;AAElC,WAAAD,EAAiB,OAAOC,GAAK,CAAC,GAEvBC;AAAA,EACT,GAK4B,cAHP,CAACA,MACpBF,EAAiB,KAAKE,CAAK,EAED;AAE9B,GAEaC,KAAkC,MAAM;AAEnD,QAAMC,IAAgBL,GAAA;AAetB,SAAO,EAAE,SAbO,CAACM,GAAqBjB,MAA2B;AAC/D,UAAMc,IAAQE,EAAc,kBAAA;AAE5B,WAAO;AAAA,MACL,OAAOhB,EAAK,QAAQA,EAAK;AAAA,MACzB,QAAQA,EAAK;AAAA,MACb,OAAAc;AAAA,IAAA;AAAA,EAEJ,GAKkB,YAHC,CAACd,MAClBgB,EAAc,aAAahB,EAAK,WAAW,KAAK,EAEhC;AAEpB,GCzBMkB,KAAc,CAACC,GAAcC,MACjCD,EAAM,MAAM,OAAKA,EAAM,SAAS3R,CAAC,CAAC,KAAK4R,EAAM,MAAM,OAAKD,EAAM,SAAS1R,CAAC,CAAC,GAG9D4R,KAAe9B,GAAA,GAEf+B,KAAsB,CACjCC,IAAyCR,SACvB;AAElB,QAAMtG,IAAUR,EAAA,GAEVuH,wBAAmB,IAAA,GAEnBC,wBAAsB,IAAA,GAEtBC,IAAU,CAACT,GAAqBjB,MAAe;AACnD,QAAIwB,EAAa,IAAIP,CAAW,GAAG;AACjC,cAAQ,KAAK,+CAA+CA,GAAajB,CAAI;AAC7E;AAAA,IACF;AAEA,UAAM2B,IAAaJ,EAAmB,QAAQN,GAAajB,CAAI;AAE/D,IAAAwB,EAAa,IAAIP,GAAa;AAAA,MAC5B,GAAGjB;AAAA,MACH,aAAAiB;AAAA,MACA,YAAAU;AAAA,IAAA,CACD;AAAA,EACH,GAEMC,IAAa,CAACX,MAAwB;AAC1C,UAAMjB,IAAOwB,EAAa,IAAIP,CAAW;AACzC,QAAI,CAACjB,GAAM;AACT,cAAQ,KAAK,8CAA8CiB,CAAW;AACtE;AAAA,IACF;AAEA,IAAAM,EAAmB,WAAWvB,CAAI,GAElCwB,EAAa,OAAOP,CAAW;AAAA,EACjC,GAEMY,IAAY,CAACpG,MAAiD;AAElE,UAAMqG,IAAO,IAAI,IAAIrG,EAAM,IAAI,CAAAkC,MAAKA,EAAE,WAAW,CAAC,GAI5C1F,IAAQwD,EAAM,OAAO,CAAC,EAAE,aAAAwF,EAAA,MAAkB,CAACO,EAAa,IAAIP,CAAW,CAAC,GAGxEc,IAAW,MAAM,KAAKP,EAAa,QAAQ,EAAE,OAAO,CAAAQ,MACxD,CAACF,EAAK,IAAIE,EAAY,WAAW,CAAC;AAEpC,IAAA/J,EAAM,QAAQ,CAAC,EAAE,aAAAgJ,GAAa,MAAAjB,QAAW0B,EAAQT,GAAajB,CAAI,CAAC,GAEnE+B,EAAS,QAAQ,CAAA/B,MAAQ;AACvB,YAAM,EAAE,aAAAiB,MAAgBjB;AAGxB,MAAIyB,EAAgB,IAAIR,CAAW,KACjCxG,EAAQ,KAAK,mBAAmBuF,GAAM,IAAI,GAE5C4B,EAAWX,CAAW;AAAA,IACxB,CAAC,IAEGhJ,EAAM,SAAS,KAAK8J,EAAS,SAAS,MACxCtH,EAAQ,KAAK,YAAYwH,GAAiB;AAAA,EAC9C,GAEMC,IAAiB,CAACjB,GAAqBkB,MAA4B;AACvE,UAAMnC,IAAOwB,EAAa,IAAIP,CAAW;AAEzC,QAAI,CAACjB,GAAM;AACT,cAAQ,KAAK,qDAAqD;AAClE;AAAA,IACF;AAEA,UAAM1O,IAAmBmQ,EAAgB,IAAIR,CAAW;AAGxD,KAAI,CAAC3P,KAAoB,CAAC4P,GAAY5P,GAAkB6Q,CAAa,OACnEV,EAAgB,IAAIR,GAAakB,CAAa,GAC9C1H,EAAQ,KAAK,mBAAmBuF,GAAMmC,CAAa;AAAA,EAEvD,GAEMC,IAAkB,CAACnB,GAAqBpF,MAA+B;AAC3E,UAAMwG,IAAOb,EAAa,IAAIP,CAAW;AACzC,QAAI,CAACoB,GAAM;AACT,cAAQ,KAAK,iDAAiDpB,CAAW;AACzE;AAAA,IACF;AAEA,IAAIpF,IACF4F,EAAgB,IAAIR,GAAapF,CAAS,IAE1C4F,EAAgB,OAAOR,CAAW,GAEpCxG,EAAQ,KAAK,mBAAmB4H,GAAMxG,CAAS;AAAA,EACjD,GAEMoG,IAAkB,MACtB,CAAC,GAAG,MAAM,KAAKT,EAAa,OAAA,CAAQ,CAAC;AAKvC,SAAO;AAAA,IACL,iBAAAS;AAAA,IACA,gBAAAC;AAAA,IACA,IANS,CAAiCnQ,GAAUuJ,MACpDb,EAAQ,GAAG1I,GAAOuJ,CAAQ;AAAA,IAM1B,WAAAuG;AAAA,IACA,iBAAAO;AAAA,EAAA;AAGJ;","x_google_ignoreList":[0,1,2,5,6,7,8,14,21,22]}