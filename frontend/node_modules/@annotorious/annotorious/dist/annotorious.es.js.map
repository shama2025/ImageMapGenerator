{"version":3,"file":"annotorious.es.js","sources":["../../../node_modules/svelte/src/runtime/internal/utils.js","../../../node_modules/svelte/src/runtime/internal/dom.js","../../../node_modules/svelte/src/runtime/internal/lifecycle.js","../../../node_modules/svelte/src/runtime/internal/scheduler.js","../../../node_modules/svelte/src/runtime/internal/transitions.js","../../../node_modules/svelte/src/runtime/internal/each.js","../../../node_modules/svelte/src/runtime/internal/Component.js","../../../node_modules/svelte/src/shared/version.js","../../../node_modules/svelte/src/runtime/internal/disclose-version/index.js","../src/model/core/Shape.ts","../../../node_modules/simplify-js/simplify.js","../src/model/core/shapeUtils.ts","../src/model/core/ellipse/ellipseUtils.ts","../src/model/core/line/lineUtils.ts","../src/model/core/multipolygon/multiPolygonUtils.ts","../src/model/core/polygon/polygonUtils.ts","../src/model/core/polyline/polylineUtils.ts","../src/model/core/rectangle/rectangleUtils.ts","../src/model/core/ImageAnnotation.ts","../src/model/w3c/fragment/FragmentSelector.ts","../src/model/w3c/svg/SVG.ts","../src/model/w3c/svg/pathParser.ts","../src/model/w3c/svg/SVGSelector.ts","../../../node_modules/uuid/dist/stringify.js","../../../node_modules/uuid/dist/rng.js","../../../node_modules/uuid/dist/native.js","../../../node_modules/uuid/dist/v4.js","../../annotorious-core/dist/annotorious-core.es.js","../src/model/w3c/W3CImageFormatAdapter.ts","../../../node_modules/svelte/src/runtime/store/index.js","../src/annotation/utils/responsive.ts","../src/annotation/utils/styling.ts","../src/annotation/utils/svg.ts","../src/annotation/utils/touch.ts","../src/annotation/editors/Editor.svelte","../src/annotation/editors/Handle.svelte","../src/annotation/editors/MidpointHandle.svelte","../src/annotation/editors/polygon/PolygonEditor.svelte","../src/annotation/editors/rectangle/RectangleEditor.svelte","../../../node_modules/dequal/lite/index.mjs","../src/annotation/editors/multipolygon/utils.ts","../src/annotation/editors/multipolygon/MultiPolygonEditor.svelte","../src/annotation/editors/editorsRegistry.ts","../src/annotation/editors/EditorMount.svelte","../src/annotation/tools/ToolMount.svelte","../src/annotation/tools/rectangle/RubberbandRectangle.svelte","../src/annotation/tools/polygon/RubberbandPolygon.svelte","../src/annotation/tools/drawingToolsRegistry.ts","../src/annotation/shapes/Ellipse.svelte","../src/annotation/shapes/Line.svelte","../src/annotation/shapes/MultiPolygon.svelte","../src/annotation/shapes/Polygon.svelte","../src/annotation/shapes/Polyline.svelte","../src/annotation/shapes/Rectangle.svelte","../src/annotation/Transform.ts","../src/annotation/SVGAnnotationLayerPointerEvent.ts","../src/annotation/SVGAnnotationLayer.svelte","../../../node_modules/quickselect/index.js","../../../node_modules/rbush/index.js","../src/state/spatialTree.ts","../src/state/ImageAnnotatorState.ts","../src/themes/smart/setTheme.ts","../src/AnnotoriousOpts.ts","../src/keyboardCommands.ts","../src/Annotorious.ts"],"sourcesContent":["/** @returns {void} */\nexport function noop() {}\n\nexport const identity = (x) => x;\n\n/**\n * @template T\n * @template S\n * @param {T} tar\n * @param {S} src\n * @returns {T & S}\n */\nexport function assign(tar, src) {\n\t// @ts-ignore\n\tfor (const k in src) tar[k] = src[k];\n\treturn /** @type {T & S} */ (tar);\n}\n\n// Adapted from https://github.com/then/is-promise/blob/master/index.js\n// Distributed under MIT License https://github.com/then/is-promise/blob/master/LICENSE\n/**\n * @param {any} value\n * @returns {value is PromiseLike<any>}\n */\nexport function is_promise(value) {\n\treturn (\n\t\t!!value &&\n\t\t(typeof value === 'object' || typeof value === 'function') &&\n\t\ttypeof (/** @type {any} */ (value).then) === 'function'\n\t);\n}\n\n/** @returns {void} */\nexport function add_location(element, file, line, column, char) {\n\telement.__svelte_meta = {\n\t\tloc: { file, line, column, char }\n\t};\n}\n\nexport function run(fn) {\n\treturn fn();\n}\n\nexport function blank_object() {\n\treturn Object.create(null);\n}\n\n/**\n * @param {Function[]} fns\n * @returns {void}\n */\nexport function run_all(fns) {\n\tfns.forEach(run);\n}\n\n/**\n * @param {any} thing\n * @returns {thing is Function}\n */\nexport function is_function(thing) {\n\treturn typeof thing === 'function';\n}\n\n/** @returns {boolean} */\nexport function safe_not_equal(a, b) {\n\treturn a != a ? b == b : a !== b || (a && typeof a === 'object') || typeof a === 'function';\n}\n\nlet src_url_equal_anchor;\n\n/**\n * @param {string} element_src\n * @param {string} url\n * @returns {boolean}\n */\nexport function src_url_equal(element_src, url) {\n\tif (element_src === url) return true;\n\tif (!src_url_equal_anchor) {\n\t\tsrc_url_equal_anchor = document.createElement('a');\n\t}\n\t// This is actually faster than doing URL(..).href\n\tsrc_url_equal_anchor.href = url;\n\treturn element_src === src_url_equal_anchor.href;\n}\n\n/** @param {string} srcset */\nfunction split_srcset(srcset) {\n\treturn srcset.split(',').map((src) => src.trim().split(' ').filter(Boolean));\n}\n\n/**\n * @param {HTMLSourceElement | HTMLImageElement} element_srcset\n * @param {string | undefined | null} srcset\n * @returns {boolean}\n */\nexport function srcset_url_equal(element_srcset, srcset) {\n\tconst element_urls = split_srcset(element_srcset.srcset);\n\tconst urls = split_srcset(srcset || '');\n\n\treturn (\n\t\turls.length === element_urls.length &&\n\t\turls.every(\n\t\t\t([url, width], i) =>\n\t\t\t\twidth === element_urls[i][1] &&\n\t\t\t\t// We need to test both ways because Vite will create an a full URL with\n\t\t\t\t// `new URL(asset, import.meta.url).href` for the client when `base: './'`, and the\n\t\t\t\t// relative URLs inside srcset are not automatically resolved to absolute URLs by\n\t\t\t\t// browsers (in contrast to img.src). This means both SSR and DOM code could\n\t\t\t\t// contain relative or absolute URLs.\n\t\t\t\t(src_url_equal(element_urls[i][0], url) || src_url_equal(url, element_urls[i][0]))\n\t\t)\n\t);\n}\n\n/** @returns {boolean} */\nexport function not_equal(a, b) {\n\treturn a != a ? b == b : a !== b;\n}\n\n/** @returns {boolean} */\nexport function is_empty(obj) {\n\treturn Object.keys(obj).length === 0;\n}\n\n/** @returns {void} */\nexport function validate_store(store, name) {\n\tif (store != null && typeof store.subscribe !== 'function') {\n\t\tthrow new Error(`'${name}' is not a store with a 'subscribe' method`);\n\t}\n}\n\nexport function subscribe(store, ...callbacks) {\n\tif (store == null) {\n\t\tfor (const callback of callbacks) {\n\t\t\tcallback(undefined);\n\t\t}\n\t\treturn noop;\n\t}\n\tconst unsub = store.subscribe(...callbacks);\n\treturn unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\n\n/**\n * Get the current value from a store by subscribing and immediately unsubscribing.\n *\n * https://svelte.dev/docs/svelte-store#get\n * @template T\n * @param {import('../store/public.js').Readable<T>} store\n * @returns {T}\n */\nexport function get_store_value(store) {\n\tlet value;\n\tsubscribe(store, (_) => (value = _))();\n\treturn value;\n}\n\n/** @returns {void} */\nexport function component_subscribe(component, store, callback) {\n\tcomponent.$$.on_destroy.push(subscribe(store, callback));\n}\n\nexport function create_slot(definition, ctx, $$scope, fn) {\n\tif (definition) {\n\t\tconst slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n\t\treturn definition[0](slot_ctx);\n\t}\n}\n\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n\treturn definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\n\nexport function get_slot_changes(definition, $$scope, dirty, fn) {\n\tif (definition[2] && fn) {\n\t\tconst lets = definition[2](fn(dirty));\n\t\tif ($$scope.dirty === undefined) {\n\t\t\treturn lets;\n\t\t}\n\t\tif (typeof lets === 'object') {\n\t\t\tconst merged = [];\n\t\t\tconst len = Math.max($$scope.dirty.length, lets.length);\n\t\t\tfor (let i = 0; i < len; i += 1) {\n\t\t\t\tmerged[i] = $$scope.dirty[i] | lets[i];\n\t\t\t}\n\t\t\treturn merged;\n\t\t}\n\t\treturn $$scope.dirty | lets;\n\t}\n\treturn $$scope.dirty;\n}\n\n/** @returns {void} */\nexport function update_slot_base(\n\tslot,\n\tslot_definition,\n\tctx,\n\t$$scope,\n\tslot_changes,\n\tget_slot_context_fn\n) {\n\tif (slot_changes) {\n\t\tconst slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n\t\tslot.p(slot_context, slot_changes);\n\t}\n}\n\n/** @returns {void} */\nexport function update_slot(\n\tslot,\n\tslot_definition,\n\tctx,\n\t$$scope,\n\tdirty,\n\tget_slot_changes_fn,\n\tget_slot_context_fn\n) {\n\tconst slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n\tupdate_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\n}\n\n/** @returns {any[] | -1} */\nexport function get_all_dirty_from_scope($$scope) {\n\tif ($$scope.ctx.length > 32) {\n\t\tconst dirty = [];\n\t\tconst length = $$scope.ctx.length / 32;\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tdirty[i] = -1;\n\t\t}\n\t\treturn dirty;\n\t}\n\treturn -1;\n}\n\n/** @returns {{}} */\nexport function exclude_internal_props(props) {\n\tconst result = {};\n\tfor (const k in props) if (k[0] !== '$') result[k] = props[k];\n\treturn result;\n}\n\n/** @returns {{}} */\nexport function compute_rest_props(props, keys) {\n\tconst rest = {};\n\tkeys = new Set(keys);\n\tfor (const k in props) if (!keys.has(k) && k[0] !== '$') rest[k] = props[k];\n\treturn rest;\n}\n\n/** @returns {{}} */\nexport function compute_slots(slots) {\n\tconst result = {};\n\tfor (const key in slots) {\n\t\tresult[key] = true;\n\t}\n\treturn result;\n}\n\n/** @returns {(this: any, ...args: any[]) => void} */\nexport function once(fn) {\n\tlet ran = false;\n\treturn function (...args) {\n\t\tif (ran) return;\n\t\tran = true;\n\t\tfn.call(this, ...args);\n\t};\n}\n\nexport function null_to_empty(value) {\n\treturn value == null ? '' : value;\n}\n\nexport function set_store_value(store, ret, value) {\n\tstore.set(value);\n\treturn ret;\n}\n\nexport const has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\n\nexport function action_destroyer(action_result) {\n\treturn action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\n/** @param {number | string} value\n * @returns {[number, string]}\n */\nexport function split_css_unit(value) {\n\tconst split = typeof value === 'string' && value.match(/^\\s*(-?[\\d.]+)([^\\s]*)\\s*$/);\n\treturn split ? [parseFloat(split[1]), split[2] || 'px'] : [/** @type {number} */ (value), 'px'];\n}\n\nexport const contenteditable_truthy_values = ['', true, 1, 'true', 'contenteditable'];\n","import { contenteditable_truthy_values, has_prop } from './utils.js';\n\nimport { ResizeObserverSingleton } from './ResizeObserverSingleton.js';\n\n// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n// at the end of hydration without touching the remaining nodes.\nlet is_hydrating = false;\n\n/**\n * @returns {void}\n */\nexport function start_hydrating() {\n\tis_hydrating = true;\n}\n\n/**\n * @returns {void}\n */\nexport function end_hydrating() {\n\tis_hydrating = false;\n}\n\n/**\n * @param {number} low\n * @param {number} high\n * @param {(index: number) => number} key\n * @param {number} value\n * @returns {number}\n */\nfunction upper_bound(low, high, key, value) {\n\t// Return first index of value larger than input value in the range [low, high)\n\twhile (low < high) {\n\t\tconst mid = low + ((high - low) >> 1);\n\t\tif (key(mid) <= value) {\n\t\t\tlow = mid + 1;\n\t\t} else {\n\t\t\thigh = mid;\n\t\t}\n\t}\n\treturn low;\n}\n\n/**\n * @param {NodeEx} target\n * @returns {void}\n */\nfunction init_hydrate(target) {\n\tif (target.hydrate_init) return;\n\ttarget.hydrate_init = true;\n\t// We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n\n\tlet children = /** @type {ArrayLike<NodeEx2>} */ (target.childNodes);\n\t// If target is <head>, there may be children without claim_order\n\tif (target.nodeName === 'HEAD') {\n\t\tconst my_children = [];\n\t\tfor (let i = 0; i < children.length; i++) {\n\t\t\tconst node = children[i];\n\t\t\tif (node.claim_order !== undefined) {\n\t\t\t\tmy_children.push(node);\n\t\t\t}\n\t\t}\n\t\tchildren = my_children;\n\t}\n\t/*\n\t * Reorder claimed children optimally.\n\t * We can reorder claimed children optimally by finding the longest subsequence of\n\t * nodes that are already claimed in order and only moving the rest. The longest\n\t * subsequence of nodes that are claimed in order can be found by\n\t * computing the longest increasing subsequence of .claim_order values.\n\t *\n\t * This algorithm is optimal in generating the least amount of reorder operations\n\t * possible.\n\t *\n\t * Proof:\n\t * We know that, given a set of reordering operations, the nodes that do not move\n\t * always form an increasing subsequence, since they do not move among each other\n\t * meaning that they must be already ordered among each other. Thus, the maximal\n\t * set of nodes that do not move form a longest increasing subsequence.\n\t */\n\t// Compute longest increasing subsequence\n\t// m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n\tconst m = new Int32Array(children.length + 1);\n\t// Predecessor indices + 1\n\tconst p = new Int32Array(children.length);\n\tm[0] = -1;\n\tlet longest = 0;\n\tfor (let i = 0; i < children.length; i++) {\n\t\tconst current = children[i].claim_order;\n\t\t// Find the largest subsequence length such that it ends in a value less than our current value\n\t\t// upper_bound returns first greater value, so we subtract one\n\t\t// with fast path for when we are on the current longest subsequence\n\t\tconst seq_len =\n\t\t\t(longest > 0 && children[m[longest]].claim_order <= current\n\t\t\t\t? longest + 1\n\t\t\t\t: upper_bound(1, longest, (idx) => children[m[idx]].claim_order, current)) - 1;\n\t\tp[i] = m[seq_len] + 1;\n\t\tconst new_len = seq_len + 1;\n\t\t// We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n\t\tm[new_len] = i;\n\t\tlongest = Math.max(new_len, longest);\n\t}\n\t// The longest increasing subsequence of nodes (initially reversed)\n\n\t/**\n\t * @type {NodeEx2[]}\n\t */\n\tconst lis = [];\n\t// The rest of the nodes, nodes that will be moved\n\n\t/**\n\t * @type {NodeEx2[]}\n\t */\n\tconst to_move = [];\n\tlet last = children.length - 1;\n\tfor (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n\t\tlis.push(children[cur - 1]);\n\t\tfor (; last >= cur; last--) {\n\t\t\tto_move.push(children[last]);\n\t\t}\n\t\tlast--;\n\t}\n\tfor (; last >= 0; last--) {\n\t\tto_move.push(children[last]);\n\t}\n\tlis.reverse();\n\t// We sort the nodes being moved to guarantee that their insertion order matches the claim order\n\tto_move.sort((a, b) => a.claim_order - b.claim_order);\n\t// Finally, we move the nodes\n\tfor (let i = 0, j = 0; i < to_move.length; i++) {\n\t\twhile (j < lis.length && to_move[i].claim_order >= lis[j].claim_order) {\n\t\t\tj++;\n\t\t}\n\t\tconst anchor = j < lis.length ? lis[j] : null;\n\t\ttarget.insertBefore(to_move[i], anchor);\n\t}\n}\n\n/**\n * @param {Node} target\n * @param {Node} node\n * @returns {void}\n */\nexport function append(target, node) {\n\ttarget.appendChild(node);\n}\n\n/**\n * @param {Node} target\n * @param {string} style_sheet_id\n * @param {string} styles\n * @returns {void}\n */\nexport function append_styles(target, style_sheet_id, styles) {\n\tconst append_styles_to = get_root_for_style(target);\n\tif (!append_styles_to.getElementById(style_sheet_id)) {\n\t\tconst style = element('style');\n\t\tstyle.id = style_sheet_id;\n\t\tstyle.textContent = styles;\n\t\tappend_stylesheet(append_styles_to, style);\n\t}\n}\n\n/**\n * @param {Node} node\n * @returns {ShadowRoot | Document}\n */\nexport function get_root_for_style(node) {\n\tif (!node) return document;\n\tconst root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n\tif (root && /** @type {ShadowRoot} */ (root).host) {\n\t\treturn /** @type {ShadowRoot} */ (root);\n\t}\n\treturn node.ownerDocument;\n}\n\n/**\n * @param {Node} node\n * @returns {CSSStyleSheet}\n */\nexport function append_empty_stylesheet(node) {\n\tconst style_element = element('style');\n\t// For transitions to work without 'style-src: unsafe-inline' Content Security Policy,\n\t// these empty tags need to be allowed with a hash as a workaround until we move to the Web Animations API.\n\t// Using the hash for the empty string (for an empty tag) works in all browsers except Safari.\n\t// So as a workaround for the workaround, when we append empty style tags we set their content to /* empty */.\n\t// The hash 'sha256-9OlNO0DNEeaVzHL4RZwCLsBHA8WBQ8toBp/4F5XV2nc=' will then work even in Safari.\n\tstyle_element.textContent = '/* empty */';\n\tappend_stylesheet(get_root_for_style(node), style_element);\n\treturn style_element.sheet;\n}\n\n/**\n * @param {ShadowRoot | Document} node\n * @param {HTMLStyleElement} style\n * @returns {CSSStyleSheet}\n */\nfunction append_stylesheet(node, style) {\n\tappend(/** @type {Document} */ (node).head || node, style);\n\treturn style.sheet;\n}\n\n/**\n * @param {NodeEx} target\n * @param {NodeEx} node\n * @returns {void}\n */\nexport function append_hydration(target, node) {\n\tif (is_hydrating) {\n\t\tinit_hydrate(target);\n\t\tif (\n\t\t\ttarget.actual_end_child === undefined ||\n\t\t\t(target.actual_end_child !== null && target.actual_end_child.parentNode !== target)\n\t\t) {\n\t\t\ttarget.actual_end_child = target.firstChild;\n\t\t}\n\t\t// Skip nodes of undefined ordering\n\t\twhile (target.actual_end_child !== null && target.actual_end_child.claim_order === undefined) {\n\t\t\ttarget.actual_end_child = target.actual_end_child.nextSibling;\n\t\t}\n\t\tif (node !== target.actual_end_child) {\n\t\t\t// We only insert if the ordering of this node should be modified or the parent node is not target\n\t\t\tif (node.claim_order !== undefined || node.parentNode !== target) {\n\t\t\t\ttarget.insertBefore(node, target.actual_end_child);\n\t\t\t}\n\t\t} else {\n\t\t\ttarget.actual_end_child = node.nextSibling;\n\t\t}\n\t} else if (node.parentNode !== target || node.nextSibling !== null) {\n\t\ttarget.appendChild(node);\n\t}\n}\n\n/**\n * @param {Node} target\n * @param {Node} node\n * @param {Node} [anchor]\n * @returns {void}\n */\nexport function insert(target, node, anchor) {\n\ttarget.insertBefore(node, anchor || null);\n}\n\n/**\n * @param {NodeEx} target\n * @param {NodeEx} node\n * @param {NodeEx} [anchor]\n * @returns {void}\n */\nexport function insert_hydration(target, node, anchor) {\n\tif (is_hydrating && !anchor) {\n\t\tappend_hydration(target, node);\n\t} else if (node.parentNode !== target || node.nextSibling != anchor) {\n\t\ttarget.insertBefore(node, anchor || null);\n\t}\n}\n\n/**\n * @param {Node} node\n * @returns {void}\n */\nexport function detach(node) {\n\tif (node.parentNode) {\n\t\tnode.parentNode.removeChild(node);\n\t}\n}\n\n/**\n * @returns {void} */\nexport function destroy_each(iterations, detaching) {\n\tfor (let i = 0; i < iterations.length; i += 1) {\n\t\tif (iterations[i]) iterations[i].d(detaching);\n\t}\n}\n\n/**\n * @template {keyof HTMLElementTagNameMap} K\n * @param {K} name\n * @returns {HTMLElementTagNameMap[K]}\n */\nexport function element(name) {\n\treturn document.createElement(name);\n}\n\n/**\n * @template {keyof HTMLElementTagNameMap} K\n * @param {K} name\n * @param {string} is\n * @returns {HTMLElementTagNameMap[K]}\n */\nexport function element_is(name, is) {\n\treturn document.createElement(name, { is });\n}\n\n/**\n * @template T\n * @template {keyof T} K\n * @param {T} obj\n * @param {K[]} exclude\n * @returns {Pick<T, Exclude<keyof T, K>>}\n */\nexport function object_without_properties(obj, exclude) {\n\tconst target = /** @type {Pick<T, Exclude<keyof T, K>>} */ ({});\n\tfor (const k in obj) {\n\t\tif (\n\t\t\thas_prop(obj, k) &&\n\t\t\t// @ts-ignore\n\t\t\texclude.indexOf(k) === -1\n\t\t) {\n\t\t\t// @ts-ignore\n\t\t\ttarget[k] = obj[k];\n\t\t}\n\t}\n\treturn target;\n}\n\n/**\n * @template {keyof SVGElementTagNameMap} K\n * @param {K} name\n * @returns {SVGElement}\n */\nexport function svg_element(name) {\n\treturn document.createElementNS('http://www.w3.org/2000/svg', name);\n}\n\n/**\n * @param {string} data\n * @returns {Text}\n */\nexport function text(data) {\n\treturn document.createTextNode(data);\n}\n\n/**\n * @returns {Text} */\nexport function space() {\n\treturn text(' ');\n}\n\n/**\n * @returns {Text} */\nexport function empty() {\n\treturn text('');\n}\n\n/**\n * @param {string} content\n * @returns {Comment}\n */\nexport function comment(content) {\n\treturn document.createComment(content);\n}\n\n/**\n * @param {EventTarget} node\n * @param {string} event\n * @param {EventListenerOrEventListenerObject} handler\n * @param {boolean | AddEventListenerOptions | EventListenerOptions} [options]\n * @returns {() => void}\n */\nexport function listen(node, event, handler, options) {\n\tnode.addEventListener(event, handler, options);\n\treturn () => node.removeEventListener(event, handler, options);\n}\n\n/**\n * @returns {(event: any) => any} */\nexport function prevent_default(fn) {\n\treturn function (event) {\n\t\tevent.preventDefault();\n\t\t// @ts-ignore\n\t\treturn fn.call(this, event);\n\t};\n}\n\n/**\n * @returns {(event: any) => any} */\nexport function stop_propagation(fn) {\n\treturn function (event) {\n\t\tevent.stopPropagation();\n\t\t// @ts-ignore\n\t\treturn fn.call(this, event);\n\t};\n}\n\n/**\n * @returns {(event: any) => any} */\nexport function stop_immediate_propagation(fn) {\n\treturn function (event) {\n\t\tevent.stopImmediatePropagation();\n\t\t// @ts-ignore\n\t\treturn fn.call(this, event);\n\t};\n}\n\n/**\n * @returns {(event: any) => void} */\nexport function self(fn) {\n\treturn function (event) {\n\t\t// @ts-ignore\n\t\tif (event.target === this) fn.call(this, event);\n\t};\n}\n\n/**\n * @returns {(event: any) => void} */\nexport function trusted(fn) {\n\treturn function (event) {\n\t\t// @ts-ignore\n\t\tif (event.isTrusted) fn.call(this, event);\n\t};\n}\n\n/**\n * @param {Element} node\n * @param {string} attribute\n * @param {string} [value]\n * @returns {void}\n */\nexport function attr(node, attribute, value) {\n\tif (value == null) node.removeAttribute(attribute);\n\telse if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);\n}\n/**\n * List of attributes that should always be set through the attr method,\n * because updating them through the property setter doesn't work reliably.\n * In the example of `width`/`height`, the problem is that the setter only\n * accepts numeric values, but the attribute can also be set to a string like `50%`.\n * If this list becomes too big, rethink this approach.\n */\nconst always_set_through_set_attribute = ['width', 'height'];\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {{ [x: string]: string }} attributes\n * @returns {void}\n */\nexport function set_attributes(node, attributes) {\n\t// @ts-ignore\n\tconst descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n\tfor (const key in attributes) {\n\t\tif (attributes[key] == null) {\n\t\t\tnode.removeAttribute(key);\n\t\t} else if (key === 'style') {\n\t\t\tnode.style.cssText = attributes[key];\n\t\t} else if (key === '__value') {\n\t\t\t/** @type {any} */ (node).value = node[key] = attributes[key];\n\t\t} else if (\n\t\t\tdescriptors[key] &&\n\t\t\tdescriptors[key].set &&\n\t\t\talways_set_through_set_attribute.indexOf(key) === -1\n\t\t) {\n\t\t\tnode[key] = attributes[key];\n\t\t} else {\n\t\t\tattr(node, key, attributes[key]);\n\t\t}\n\t}\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {{ [x: string]: string }} attributes\n * @returns {void}\n */\nexport function set_svg_attributes(node, attributes) {\n\tfor (const key in attributes) {\n\t\tattr(node, key, attributes[key]);\n\t}\n}\n\n/**\n * @param {Record<string, unknown>} data_map\n * @returns {void}\n */\nexport function set_custom_element_data_map(node, data_map) {\n\tObject.keys(data_map).forEach((key) => {\n\t\tset_custom_element_data(node, key, data_map[key]);\n\t});\n}\n\n/**\n * @returns {void} */\nexport function set_custom_element_data(node, prop, value) {\n\tconst lower = prop.toLowerCase(); // for backwards compatibility with existing behavior we do lowercase first\n\tif (lower in node) {\n\t\tnode[lower] = typeof node[lower] === 'boolean' && value === '' ? true : value;\n\t} else if (prop in node) {\n\t\tnode[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;\n\t} else {\n\t\tattr(node, prop, value);\n\t}\n}\n\n/**\n * @param {string} tag\n */\nexport function set_dynamic_element_data(tag) {\n\treturn /-/.test(tag) ? set_custom_element_data_map : set_attributes;\n}\n\n/**\n * @returns {void}\n */\nexport function xlink_attr(node, attribute, value) {\n\tnode.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\n\n/**\n * @param {HTMLElement} node\n * @returns {string}\n */\nexport function get_svelte_dataset(node) {\n\treturn node.dataset.svelteH;\n}\n\n/**\n * @returns {unknown[]} */\nexport function get_binding_group_value(group, __value, checked) {\n\tconst value = new Set();\n\tfor (let i = 0; i < group.length; i += 1) {\n\t\tif (group[i].checked) value.add(group[i].__value);\n\t}\n\tif (!checked) {\n\t\tvalue.delete(__value);\n\t}\n\treturn Array.from(value);\n}\n\n/**\n * @param {HTMLInputElement[]} group\n * @returns {{ p(...inputs: HTMLInputElement[]): void; r(): void; }}\n */\nexport function init_binding_group(group) {\n\t/**\n\t * @type {HTMLInputElement[]} */\n\tlet _inputs;\n\treturn {\n\t\t/* push */ p(...inputs) {\n\t\t\t_inputs = inputs;\n\t\t\t_inputs.forEach((input) => group.push(input));\n\t\t},\n\t\t/* remove */ r() {\n\t\t\t_inputs.forEach((input) => group.splice(group.indexOf(input), 1));\n\t\t}\n\t};\n}\n\n/**\n * @param {number[]} indexes\n * @returns {{ u(new_indexes: number[]): void; p(...inputs: HTMLInputElement[]): void; r: () => void; }}\n */\nexport function init_binding_group_dynamic(group, indexes) {\n\t/**\n\t * @type {HTMLInputElement[]} */\n\tlet _group = get_binding_group(group);\n\n\t/**\n\t * @type {HTMLInputElement[]} */\n\tlet _inputs;\n\n\tfunction get_binding_group(group) {\n\t\tfor (let i = 0; i < indexes.length; i++) {\n\t\t\tgroup = group[indexes[i]] = group[indexes[i]] || [];\n\t\t}\n\t\treturn group;\n\t}\n\n\t/**\n\t * @returns {void} */\n\tfunction push() {\n\t\t_inputs.forEach((input) => _group.push(input));\n\t}\n\n\t/**\n\t * @returns {void} */\n\tfunction remove() {\n\t\t_inputs.forEach((input) => _group.splice(_group.indexOf(input), 1));\n\t}\n\treturn {\n\t\t/* update */ u(new_indexes) {\n\t\t\tindexes = new_indexes;\n\t\t\tconst new_group = get_binding_group(group);\n\t\t\tif (new_group !== _group) {\n\t\t\t\tremove();\n\t\t\t\t_group = new_group;\n\t\t\t\tpush();\n\t\t\t}\n\t\t},\n\t\t/* push */ p(...inputs) {\n\t\t\t_inputs = inputs;\n\t\t\tpush();\n\t\t},\n\t\t/* remove */ r: remove\n\t};\n}\n\n/** @returns {number} */\nexport function to_number(value) {\n\treturn value === '' ? null : +value;\n}\n\n/** @returns {any[]} */\nexport function time_ranges_to_array(ranges) {\n\tconst array = [];\n\tfor (let i = 0; i < ranges.length; i += 1) {\n\t\tarray.push({ start: ranges.start(i), end: ranges.end(i) });\n\t}\n\treturn array;\n}\n\n/**\n * @param {Element} element\n * @returns {ChildNode[]}\n */\nexport function children(element) {\n\treturn Array.from(element.childNodes);\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @returns {void}\n */\nfunction init_claim_info(nodes) {\n\tif (nodes.claim_info === undefined) {\n\t\tnodes.claim_info = { last_index: 0, total_claimed: 0 };\n\t}\n}\n\n/**\n * @template {ChildNodeEx} R\n * @param {ChildNodeArray} nodes\n * @param {(node: ChildNodeEx) => node is R} predicate\n * @param {(node: ChildNodeEx) => ChildNodeEx | undefined} process_node\n * @param {() => R} create_node\n * @param {boolean} dont_update_last_index\n * @returns {R}\n */\nfunction claim_node(nodes, predicate, process_node, create_node, dont_update_last_index = false) {\n\t// Try to find nodes in an order such that we lengthen the longest increasing subsequence\n\tinit_claim_info(nodes);\n\tconst result_node = (() => {\n\t\t// We first try to find an element after the previous one\n\t\tfor (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n\t\t\tconst node = nodes[i];\n\t\t\tif (predicate(node)) {\n\t\t\t\tconst replacement = process_node(node);\n\t\t\t\tif (replacement === undefined) {\n\t\t\t\t\tnodes.splice(i, 1);\n\t\t\t\t} else {\n\t\t\t\t\tnodes[i] = replacement;\n\t\t\t\t}\n\t\t\t\tif (!dont_update_last_index) {\n\t\t\t\t\tnodes.claim_info.last_index = i;\n\t\t\t\t}\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\t\t// Otherwise, we try to find one before\n\t\t// We iterate in reverse so that we don't go too far back\n\t\tfor (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n\t\t\tconst node = nodes[i];\n\t\t\tif (predicate(node)) {\n\t\t\t\tconst replacement = process_node(node);\n\t\t\t\tif (replacement === undefined) {\n\t\t\t\t\tnodes.splice(i, 1);\n\t\t\t\t} else {\n\t\t\t\t\tnodes[i] = replacement;\n\t\t\t\t}\n\t\t\t\tif (!dont_update_last_index) {\n\t\t\t\t\tnodes.claim_info.last_index = i;\n\t\t\t\t} else if (replacement === undefined) {\n\t\t\t\t\t// Since we spliced before the last_index, we decrease it\n\t\t\t\t\tnodes.claim_info.last_index--;\n\t\t\t\t}\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\t\t// If we can't find any matching node, we create a new one\n\t\treturn create_node();\n\t})();\n\tresult_node.claim_order = nodes.claim_info.total_claimed;\n\tnodes.claim_info.total_claimed += 1;\n\treturn result_node;\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @param {string} name\n * @param {{ [key: string]: boolean }} attributes\n * @param {(name: string) => Element | SVGElement} create_element\n * @returns {Element | SVGElement}\n */\nfunction claim_element_base(nodes, name, attributes, create_element) {\n\treturn claim_node(\n\t\tnodes,\n\t\t/** @returns {node is Element | SVGElement} */\n\t\t(node) => node.nodeName === name,\n\t\t/** @param {Element} node */\n\t\t(node) => {\n\t\t\tconst remove = [];\n\t\t\tfor (let j = 0; j < node.attributes.length; j++) {\n\t\t\t\tconst attribute = node.attributes[j];\n\t\t\t\tif (!attributes[attribute.name]) {\n\t\t\t\t\tremove.push(attribute.name);\n\t\t\t\t}\n\t\t\t}\n\t\t\tremove.forEach((v) => node.removeAttribute(v));\n\t\t\treturn undefined;\n\t\t},\n\t\t() => create_element(name)\n\t);\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @param {string} name\n * @param {{ [key: string]: boolean }} attributes\n * @returns {Element | SVGElement}\n */\nexport function claim_element(nodes, name, attributes) {\n\treturn claim_element_base(nodes, name, attributes, element);\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @param {string} name\n * @param {{ [key: string]: boolean }} attributes\n * @returns {Element | SVGElement}\n */\nexport function claim_svg_element(nodes, name, attributes) {\n\treturn claim_element_base(nodes, name, attributes, svg_element);\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @returns {Text}\n */\nexport function claim_text(nodes, data) {\n\treturn claim_node(\n\t\tnodes,\n\t\t/** @returns {node is Text} */\n\t\t(node) => node.nodeType === 3,\n\t\t/** @param {Text} node */\n\t\t(node) => {\n\t\t\tconst data_str = '' + data;\n\t\t\tif (node.data.startsWith(data_str)) {\n\t\t\t\tif (node.data.length !== data_str.length) {\n\t\t\t\t\treturn node.splitText(data_str.length);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnode.data = data_str;\n\t\t\t}\n\t\t},\n\t\t() => text(data),\n\t\ttrue // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n\t);\n}\n\n/**\n * @returns {Text} */\nexport function claim_space(nodes) {\n\treturn claim_text(nodes, ' ');\n}\n\n/**\n * @param {ChildNodeArray} nodes\n * @returns {Comment}\n */\nexport function claim_comment(nodes, data) {\n\treturn claim_node(\n\t\tnodes,\n\t\t/** @returns {node is Comment} */\n\t\t(node) => node.nodeType === 8,\n\t\t/** @param {Comment} node */\n\t\t(node) => {\n\t\t\tnode.data = '' + data;\n\t\t\treturn undefined;\n\t\t},\n\t\t() => comment(data),\n\t\ttrue\n\t);\n}\n\nfunction get_comment_idx(nodes, text, start) {\n\tfor (let i = start; i < nodes.length; i += 1) {\n\t\tconst node = nodes[i];\n\t\tif (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn -1;\n}\n\n/**\n * @param {boolean} is_svg\n * @returns {HtmlTagHydration}\n */\nexport function claim_html_tag(nodes, is_svg) {\n\t// find html opening tag\n\tconst start_index = get_comment_idx(nodes, 'HTML_TAG_START', 0);\n\tconst end_index = get_comment_idx(nodes, 'HTML_TAG_END', start_index + 1);\n\tif (start_index === -1 || end_index === -1) {\n\t\treturn new HtmlTagHydration(is_svg);\n\t}\n\n\tinit_claim_info(nodes);\n\tconst html_tag_nodes = nodes.splice(start_index, end_index - start_index + 1);\n\tdetach(html_tag_nodes[0]);\n\tdetach(html_tag_nodes[html_tag_nodes.length - 1]);\n\tconst claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);\n\tif (claimed_nodes.length === 0) {\n\t\treturn new HtmlTagHydration(is_svg);\n\t}\n\tfor (const n of claimed_nodes) {\n\t\tn.claim_order = nodes.claim_info.total_claimed;\n\t\tnodes.claim_info.total_claimed += 1;\n\t}\n\treturn new HtmlTagHydration(is_svg, claimed_nodes);\n}\n\n/**\n * @param {Text} text\n * @param {unknown} data\n * @returns {void}\n */\nexport function set_data(text, data) {\n\tdata = '' + data;\n\tif (text.data === data) return;\n\ttext.data = /** @type {string} */ (data);\n}\n\n/**\n * @param {Text} text\n * @param {unknown} data\n * @returns {void}\n */\nexport function set_data_contenteditable(text, data) {\n\tdata = '' + data;\n\tif (text.wholeText === data) return;\n\ttext.data = /** @type {string} */ (data);\n}\n\n/**\n * @param {Text} text\n * @param {unknown} data\n * @param {string} attr_value\n * @returns {void}\n */\nexport function set_data_maybe_contenteditable(text, data, attr_value) {\n\tif (~contenteditable_truthy_values.indexOf(attr_value)) {\n\t\tset_data_contenteditable(text, data);\n\t} else {\n\t\tset_data(text, data);\n\t}\n}\n\n/**\n * @returns {void} */\nexport function set_input_value(input, value) {\n\tinput.value = value == null ? '' : value;\n}\n\n/**\n * @returns {void} */\nexport function set_input_type(input, type) {\n\ttry {\n\t\tinput.type = type;\n\t} catch (e) {\n\t\t// do nothing\n\t}\n}\n\n/**\n * @returns {void} */\nexport function set_style(node, key, value, important) {\n\tif (value == null) {\n\t\tnode.style.removeProperty(key);\n\t} else {\n\t\tnode.style.setProperty(key, value, important ? 'important' : '');\n\t}\n}\n\n/**\n * @returns {void} */\nexport function select_option(select, value, mounting) {\n\tfor (let i = 0; i < select.options.length; i += 1) {\n\t\tconst option = select.options[i];\n\t\tif (option.__value === value) {\n\t\t\toption.selected = true;\n\t\t\treturn;\n\t\t}\n\t}\n\tif (!mounting || value !== undefined) {\n\t\tselect.selectedIndex = -1; // no option should be selected\n\t}\n}\n\n/**\n * @returns {void} */\nexport function select_options(select, value) {\n\tfor (let i = 0; i < select.options.length; i += 1) {\n\t\tconst option = select.options[i];\n\t\toption.selected = ~value.indexOf(option.__value);\n\t}\n}\n\nexport function select_value(select) {\n\tconst selected_option = select.querySelector(':checked');\n\treturn selected_option && selected_option.__value;\n}\n\nexport function select_multiple_value(select) {\n\treturn [].map.call(select.querySelectorAll(':checked'), (option) => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\n\n/**\n * @type {boolean} */\nlet crossorigin;\n\n/**\n * @returns {boolean} */\nexport function is_crossorigin() {\n\tif (crossorigin === undefined) {\n\t\tcrossorigin = false;\n\t\ttry {\n\t\t\tif (typeof window !== 'undefined' && window.parent) {\n\t\t\t\tvoid window.parent.document;\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tcrossorigin = true;\n\t\t}\n\t}\n\treturn crossorigin;\n}\n\n/**\n * @param {HTMLElement} node\n * @param {() => void} fn\n * @returns {() => void}\n */\nexport function add_iframe_resize_listener(node, fn) {\n\tconst computed_style = getComputedStyle(node);\n\tif (computed_style.position === 'static') {\n\t\tnode.style.position = 'relative';\n\t}\n\tconst iframe = element('iframe');\n\tiframe.setAttribute(\n\t\t'style',\n\t\t'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +\n\t\t\t'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;'\n\t);\n\tiframe.setAttribute('aria-hidden', 'true');\n\tiframe.tabIndex = -1;\n\tconst crossorigin = is_crossorigin();\n\n\t/**\n\t * @type {() => void}\n\t */\n\tlet unsubscribe;\n\tif (crossorigin) {\n\t\tiframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>\";\n\t\tunsubscribe = listen(\n\t\t\twindow,\n\t\t\t'message',\n\t\t\t/** @param {MessageEvent} event */ (event) => {\n\t\t\t\tif (event.source === iframe.contentWindow) fn();\n\t\t\t}\n\t\t);\n\t} else {\n\t\tiframe.src = 'about:blank';\n\t\tiframe.onload = () => {\n\t\t\tunsubscribe = listen(iframe.contentWindow, 'resize', fn);\n\t\t\t// make sure an initial resize event is fired _after_ the iframe is loaded (which is asynchronous)\n\t\t\t// see https://github.com/sveltejs/svelte/issues/4233\n\t\t\tfn();\n\t\t};\n\t}\n\tappend(node, iframe);\n\treturn () => {\n\t\tif (crossorigin) {\n\t\t\tunsubscribe();\n\t\t} else if (unsubscribe && iframe.contentWindow) {\n\t\t\tunsubscribe();\n\t\t}\n\t\tdetach(iframe);\n\t};\n}\nexport const resize_observer_content_box = /* @__PURE__ */ new ResizeObserverSingleton({\n\tbox: 'content-box'\n});\nexport const resize_observer_border_box = /* @__PURE__ */ new ResizeObserverSingleton({\n\tbox: 'border-box'\n});\nexport const resize_observer_device_pixel_content_box = /* @__PURE__ */ new ResizeObserverSingleton(\n\t{ box: 'device-pixel-content-box' }\n);\nexport { ResizeObserverSingleton };\n\n/**\n * @returns {void} */\nexport function toggle_class(element, name, toggle) {\n\t// The `!!` is required because an `undefined` flag means flipping the current state.\n\telement.classList.toggle(name, !!toggle);\n}\n\n/**\n * @template T\n * @param {string} type\n * @param {T} [detail]\n * @param {{ bubbles?: boolean, cancelable?: boolean }} [options]\n * @returns {CustomEvent<T>}\n */\nexport function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {\n\treturn new CustomEvent(type, { detail, bubbles, cancelable });\n}\n\n/**\n * @param {string} selector\n * @param {HTMLElement} parent\n * @returns {ChildNodeArray}\n */\nexport function query_selector_all(selector, parent = document.body) {\n\treturn Array.from(parent.querySelectorAll(selector));\n}\n\n/**\n * @param {string} nodeId\n * @param {HTMLElement} head\n * @returns {any[]}\n */\nexport function head_selector(nodeId, head) {\n\tconst result = [];\n\tlet started = 0;\n\tfor (const node of head.childNodes) {\n\t\tif (node.nodeType === 8 /* comment node */) {\n\t\t\tconst comment = node.textContent.trim();\n\t\t\tif (comment === `HEAD_${nodeId}_END`) {\n\t\t\t\tstarted -= 1;\n\t\t\t\tresult.push(node);\n\t\t\t} else if (comment === `HEAD_${nodeId}_START`) {\n\t\t\t\tstarted += 1;\n\t\t\t\tresult.push(node);\n\t\t\t}\n\t\t} else if (started > 0) {\n\t\t\tresult.push(node);\n\t\t}\n\t}\n\treturn result;\n}\n/** */\nexport class HtmlTag {\n\t/**\n\t * @private\n\t * @default false\n\t */\n\tis_svg = false;\n\t/** parent for creating node */\n\te = undefined;\n\t/** html tag nodes */\n\tn = undefined;\n\t/** target */\n\tt = undefined;\n\t/** anchor */\n\ta = undefined;\n\tconstructor(is_svg = false) {\n\t\tthis.is_svg = is_svg;\n\t\tthis.e = this.n = null;\n\t}\n\n\t/**\n\t * @param {string} html\n\t * @returns {void}\n\t */\n\tc(html) {\n\t\tthis.h(html);\n\t}\n\n\t/**\n\t * @param {string} html\n\t * @param {HTMLElement | SVGElement} target\n\t * @param {HTMLElement | SVGElement} anchor\n\t * @returns {void}\n\t */\n\tm(html, target, anchor = null) {\n\t\tif (!this.e) {\n\t\t\tif (this.is_svg)\n\t\t\t\tthis.e = svg_element(/** @type {keyof SVGElementTagNameMap} */ (target.nodeName));\n\t\t\t/** #7364  target for <template> may be provided as #document-fragment(11) */ else\n\t\t\t\tthis.e = element(\n\t\t\t\t\t/** @type {keyof HTMLElementTagNameMap} */ (\n\t\t\t\t\t\ttarget.nodeType === 11 ? 'TEMPLATE' : target.nodeName\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\tthis.t =\n\t\t\t\ttarget.tagName !== 'TEMPLATE'\n\t\t\t\t\t? target\n\t\t\t\t\t: /** @type {HTMLTemplateElement} */ (target).content;\n\t\t\tthis.c(html);\n\t\t}\n\t\tthis.i(anchor);\n\t}\n\n\t/**\n\t * @param {string} html\n\t * @returns {void}\n\t */\n\th(html) {\n\t\tthis.e.innerHTML = html;\n\t\tthis.n = Array.from(\n\t\t\tthis.e.nodeName === 'TEMPLATE' ? this.e.content.childNodes : this.e.childNodes\n\t\t);\n\t}\n\n\t/**\n\t * @returns {void} */\n\ti(anchor) {\n\t\tfor (let i = 0; i < this.n.length; i += 1) {\n\t\t\tinsert(this.t, this.n[i], anchor);\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} html\n\t * @returns {void}\n\t */\n\tp(html) {\n\t\tthis.d();\n\t\tthis.h(html);\n\t\tthis.i(this.a);\n\t}\n\n\t/**\n\t * @returns {void} */\n\td() {\n\t\tthis.n.forEach(detach);\n\t}\n}\n\nexport class HtmlTagHydration extends HtmlTag {\n\t/** @type {Element[]} hydration claimed nodes */\n\tl = undefined;\n\n\tconstructor(is_svg = false, claimed_nodes) {\n\t\tsuper(is_svg);\n\t\tthis.e = this.n = null;\n\t\tthis.l = claimed_nodes;\n\t}\n\n\t/**\n\t * @param {string} html\n\t * @returns {void}\n\t */\n\tc(html) {\n\t\tif (this.l) {\n\t\t\tthis.n = this.l;\n\t\t} else {\n\t\t\tsuper.c(html);\n\t\t}\n\t}\n\n\t/**\n\t * @returns {void} */\n\ti(anchor) {\n\t\tfor (let i = 0; i < this.n.length; i += 1) {\n\t\t\tinsert_hydration(this.t, this.n[i], anchor);\n\t\t}\n\t}\n}\n\n/**\n * @param {NamedNodeMap} attributes\n * @returns {{}}\n */\nexport function attribute_to_object(attributes) {\n\tconst result = {};\n\tfor (const attribute of attributes) {\n\t\tresult[attribute.name] = attribute.value;\n\t}\n\treturn result;\n}\n\nconst escaped = {\n\t'\"': '&quot;',\n\t'&': '&amp;',\n\t'<': '&lt;'\n};\n\nconst regex_attribute_characters_to_escape = /[\"&<]/g;\n\n/**\n * Note that the attribute itself should be surrounded in double quotes\n * @param {any} attribute\n */\nfunction escape_attribute(attribute) {\n\treturn String(attribute).replace(regex_attribute_characters_to_escape, (match) => escaped[match]);\n}\n\n/**\n * @param {Record<string, string>} attributes\n */\nexport function stringify_spread(attributes) {\n\tlet str = ' ';\n\tfor (const key in attributes) {\n\t\tif (attributes[key] != null) {\n\t\t\tstr += `${key}=\"${escape_attribute(attributes[key])}\" `;\n\t\t}\n\t}\n\n\treturn str;\n}\n\n/**\n * @param {HTMLElement} element\n * @returns {{}}\n */\nexport function get_custom_elements_slots(element) {\n\tconst result = {};\n\telement.childNodes.forEach(\n\t\t/** @param {Element} node */ (node) => {\n\t\t\tresult[node.slot || 'default'] = true;\n\t\t}\n\t);\n\treturn result;\n}\n\nexport function construct_svelte_component(component, props) {\n\treturn new component(props);\n}\n\n/**\n * @typedef {Node & {\n * \tclaim_order?: number;\n * \thydrate_init?: true;\n * \tactual_end_child?: NodeEx;\n * \tchildNodes: NodeListOf<NodeEx>;\n * }} NodeEx\n */\n\n/** @typedef {ChildNode & NodeEx} ChildNodeEx */\n\n/** @typedef {NodeEx & { claim_order: number }} NodeEx2 */\n\n/**\n * @typedef {ChildNodeEx[] & {\n * \tclaim_info?: {\n * \t\tlast_index: number;\n * \t\ttotal_claimed: number;\n * \t};\n * }} ChildNodeArray\n */\n","import { custom_event } from './dom.js';\n\nexport let current_component;\n\n/** @returns {void} */\nexport function set_current_component(component) {\n\tcurrent_component = component;\n}\n\nexport function get_current_component() {\n\tif (!current_component) throw new Error('Function called outside component initialization');\n\treturn current_component;\n}\n\n/**\n * Schedules a callback to run immediately before the component is updated after any state change.\n *\n * The first time the callback runs will be before the initial `onMount`\n *\n * https://svelte.dev/docs/svelte#beforeupdate\n * @param {() => any} fn\n * @returns {void}\n */\nexport function beforeUpdate(fn) {\n\tget_current_component().$$.before_update.push(fn);\n}\n\n/**\n * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.\n * It must be called during the component's initialisation (but doesn't need to live *inside* the component;\n * it can be called from an external module).\n *\n * If a function is returned _synchronously_ from `onMount`, it will be called when the component is unmounted.\n *\n * `onMount` does not run inside a [server-side component](https://svelte.dev/docs#run-time-server-side-component-api).\n *\n * https://svelte.dev/docs/svelte#onmount\n * @template T\n * @param {() => import('./private.js').NotFunction<T> | Promise<import('./private.js').NotFunction<T>> | (() => any)} fn\n * @returns {void}\n */\nexport function onMount(fn) {\n\tget_current_component().$$.on_mount.push(fn);\n}\n\n/**\n * Schedules a callback to run immediately after the component has been updated.\n *\n * The first time the callback runs will be after the initial `onMount`\n *\n * https://svelte.dev/docs/svelte#afterupdate\n * @param {() => any} fn\n * @returns {void}\n */\nexport function afterUpdate(fn) {\n\tget_current_component().$$.after_update.push(fn);\n}\n\n/**\n * Schedules a callback to run immediately before the component is unmounted.\n *\n * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the\n * only one that runs inside a server-side component.\n *\n * https://svelte.dev/docs/svelte#ondestroy\n * @param {() => any} fn\n * @returns {void}\n */\nexport function onDestroy(fn) {\n\tget_current_component().$$.on_destroy.push(fn);\n}\n\n/**\n * Creates an event dispatcher that can be used to dispatch [component events](https://svelte.dev/docs#template-syntax-component-directives-on-eventname).\n * Event dispatchers are functions that can take two arguments: `name` and `detail`.\n *\n * Component events created with `createEventDispatcher` create a\n * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).\n * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).\n * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)\n * property and can contain any type of data.\n *\n * The event dispatcher can be typed to narrow the allowed event names and the type of the `detail` argument:\n * ```ts\n * const dispatch = createEventDispatcher<{\n *  loaded: never; // does not take a detail argument\n *  change: string; // takes a detail argument of type string, which is required\n *  optional: number | null; // takes an optional detail argument of type number\n * }>();\n * ```\n *\n * https://svelte.dev/docs/svelte#createeventdispatcher\n * @template {Record<string, any>} [EventMap=any]\n * @returns {import('./public.js').EventDispatcher<EventMap>}\n */\nexport function createEventDispatcher() {\n\tconst component = get_current_component();\n\treturn (type, detail, { cancelable = false } = {}) => {\n\t\tconst callbacks = component.$$.callbacks[type];\n\t\tif (callbacks) {\n\t\t\t// TODO are there situations where events could be dispatched\n\t\t\t// in a server (non-DOM) environment?\n\t\t\tconst event = custom_event(/** @type {string} */ (type), detail, { cancelable });\n\t\t\tcallbacks.slice().forEach((fn) => {\n\t\t\t\tfn.call(component, event);\n\t\t\t});\n\t\t\treturn !event.defaultPrevented;\n\t\t}\n\t\treturn true;\n\t};\n}\n\n/**\n * Associates an arbitrary `context` object with the current component and the specified `key`\n * and returns that object. The context is then available to children of the component\n * (including slotted content) with `getContext`.\n *\n * Like lifecycle functions, this must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#setcontext\n * @template T\n * @param {any} key\n * @param {T} context\n * @returns {T}\n */\nexport function setContext(key, context) {\n\tget_current_component().$$.context.set(key, context);\n\treturn context;\n}\n\n/**\n * Retrieves the context that belongs to the closest parent component with the specified `key`.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#getcontext\n * @template T\n * @param {any} key\n * @returns {T}\n */\nexport function getContext(key) {\n\treturn get_current_component().$$.context.get(key);\n}\n\n/**\n * Retrieves the whole context map that belongs to the closest parent component.\n * Must be called during component initialisation. Useful, for example, if you\n * programmatically create a component and want to pass the existing context to it.\n *\n * https://svelte.dev/docs/svelte#getallcontexts\n * @template {Map<any, any>} [T=Map<any, any>]\n * @returns {T}\n */\nexport function getAllContexts() {\n\treturn get_current_component().$$.context;\n}\n\n/**\n * Checks whether a given `key` has been set in the context of a parent component.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#hascontext\n * @param {any} key\n * @returns {boolean}\n */\nexport function hasContext(key) {\n\treturn get_current_component().$$.context.has(key);\n}\n\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\n/**\n * @param component\n * @param event\n * @returns {void}\n */\nexport function bubble(component, event) {\n\tconst callbacks = component.$$.callbacks[event.type];\n\tif (callbacks) {\n\t\t// @ts-ignore\n\t\tcallbacks.slice().forEach((fn) => fn.call(this, event));\n\t}\n}\n","import { run_all } from './utils.js';\nimport { current_component, set_current_component } from './lifecycle.js';\n\nexport const dirty_components = [];\nexport const intros = { enabled: false };\nexport const binding_callbacks = [];\n\nlet render_callbacks = [];\n\nconst flush_callbacks = [];\n\nconst resolved_promise = /* @__PURE__ */ Promise.resolve();\n\nlet update_scheduled = false;\n\n/** @returns {void} */\nexport function schedule_update() {\n\tif (!update_scheduled) {\n\t\tupdate_scheduled = true;\n\t\tresolved_promise.then(flush);\n\t}\n}\n\n/** @returns {Promise<void>} */\nexport function tick() {\n\tschedule_update();\n\treturn resolved_promise;\n}\n\n/** @returns {void} */\nexport function add_render_callback(fn) {\n\trender_callbacks.push(fn);\n}\n\n/** @returns {void} */\nexport function add_flush_callback(fn) {\n\tflush_callbacks.push(fn);\n}\n\n// flush() calls callbacks in this order:\n// 1. All beforeUpdate callbacks, in order: parents before children\n// 2. All bind:this callbacks, in reverse order: children before parents.\n// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT\n//    for afterUpdates called during the initial onMount, which are called in\n//    reverse order: children before parents.\n// Since callbacks might update component values, which could trigger another\n// call to flush(), the following steps guard against this:\n// 1. During beforeUpdate, any updated components will be added to the\n//    dirty_components array and will cause a reentrant call to flush(). Because\n//    the flush index is kept outside the function, the reentrant call will pick\n//    up where the earlier call left off and go through all dirty components. The\n//    current_component value is saved and restored so that the reentrant call will\n//    not interfere with the \"parent\" flush() call.\n// 2. bind:this callbacks cannot trigger new flush() calls.\n// 3. During afterUpdate, any updated components will NOT have their afterUpdate\n//    callback called a second time; the seen_callbacks set, outside the flush()\n//    function, guarantees this behavior.\nconst seen_callbacks = new Set();\n\nlet flushidx = 0; // Do *not* move this inside the flush() function\n\n/** @returns {void} */\nexport function flush() {\n\t// Do not reenter flush while dirty components are updated, as this can\n\t// result in an infinite loop. Instead, let the inner flush handle it.\n\t// Reentrancy is ok afterwards for bindings etc.\n\tif (flushidx !== 0) {\n\t\treturn;\n\t}\n\tconst saved_component = current_component;\n\tdo {\n\t\t// first, call beforeUpdate functions\n\t\t// and update components\n\t\ttry {\n\t\t\twhile (flushidx < dirty_components.length) {\n\t\t\t\tconst component = dirty_components[flushidx];\n\t\t\t\tflushidx++;\n\t\t\t\tset_current_component(component);\n\t\t\t\tupdate(component.$$);\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t// reset dirty state to not end up in a deadlocked state and then rethrow\n\t\t\tdirty_components.length = 0;\n\t\t\tflushidx = 0;\n\t\t\tthrow e;\n\t\t}\n\t\tset_current_component(null);\n\t\tdirty_components.length = 0;\n\t\tflushidx = 0;\n\t\twhile (binding_callbacks.length) binding_callbacks.pop()();\n\t\t// then, once components are updated, call\n\t\t// afterUpdate functions. This may cause\n\t\t// subsequent updates...\n\t\tfor (let i = 0; i < render_callbacks.length; i += 1) {\n\t\t\tconst callback = render_callbacks[i];\n\t\t\tif (!seen_callbacks.has(callback)) {\n\t\t\t\t// ...so guard against infinite loops\n\t\t\t\tseen_callbacks.add(callback);\n\t\t\t\tcallback();\n\t\t\t}\n\t\t}\n\t\trender_callbacks.length = 0;\n\t} while (dirty_components.length);\n\twhile (flush_callbacks.length) {\n\t\tflush_callbacks.pop()();\n\t}\n\tupdate_scheduled = false;\n\tseen_callbacks.clear();\n\tset_current_component(saved_component);\n}\n\n/** @returns {void} */\nfunction update($$) {\n\tif ($$.fragment !== null) {\n\t\t$$.update();\n\t\trun_all($$.before_update);\n\t\tconst dirty = $$.dirty;\n\t\t$$.dirty = [-1];\n\t\t$$.fragment && $$.fragment.p($$.ctx, dirty);\n\t\t$$.after_update.forEach(add_render_callback);\n\t}\n}\n\n/**\n * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.\n * @param {Function[]} fns\n * @returns {void}\n */\nexport function flush_render_callbacks(fns) {\n\tconst filtered = [];\n\tconst targets = [];\n\trender_callbacks.forEach((c) => (fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c)));\n\ttargets.forEach((c) => c());\n\trender_callbacks = filtered;\n}\n","import { identity as linear, is_function, noop, run_all } from './utils.js';\nimport { now } from './environment.js';\nimport { loop } from './loop.js';\nimport { create_rule, delete_rule } from './style_manager.js';\nimport { custom_event } from './dom.js';\nimport { add_render_callback } from './scheduler.js';\n\n/**\n * @type {Promise<void> | null}\n */\nlet promise;\n\n/**\n * @returns {Promise<void>}\n */\nfunction wait() {\n\tif (!promise) {\n\t\tpromise = Promise.resolve();\n\t\tpromise.then(() => {\n\t\t\tpromise = null;\n\t\t});\n\t}\n\treturn promise;\n}\n\n/**\n * @param {Element} node\n * @param {INTRO | OUTRO | boolean} direction\n * @param {'start' | 'end'} kind\n * @returns {void}\n */\nfunction dispatch(node, direction, kind) {\n\tnode.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\n\nconst outroing = new Set();\n\n/**\n * @type {Outro}\n */\nlet outros;\n\n/**\n * @returns {void} */\nexport function group_outros() {\n\toutros = {\n\t\tr: 0,\n\t\tc: [],\n\t\tp: outros // parent group\n\t};\n}\n\n/**\n * @returns {void} */\nexport function check_outros() {\n\tif (!outros.r) {\n\t\trun_all(outros.c);\n\t}\n\toutros = outros.p;\n}\n\n/**\n * @param {import('./private.js').Fragment} block\n * @param {0 | 1} [local]\n * @returns {void}\n */\nexport function transition_in(block, local) {\n\tif (block && block.i) {\n\t\toutroing.delete(block);\n\t\tblock.i(local);\n\t}\n}\n\n/**\n * @param {import('./private.js').Fragment} block\n * @param {0 | 1} local\n * @param {0 | 1} [detach]\n * @param {() => void} [callback]\n * @returns {void}\n */\nexport function transition_out(block, local, detach, callback) {\n\tif (block && block.o) {\n\t\tif (outroing.has(block)) return;\n\t\toutroing.add(block);\n\t\toutros.c.push(() => {\n\t\t\toutroing.delete(block);\n\t\t\tif (callback) {\n\t\t\t\tif (detach) block.d(1);\n\t\t\t\tcallback();\n\t\t\t}\n\t\t});\n\t\tblock.o(local);\n\t} else if (callback) {\n\t\tcallback();\n\t}\n}\n\n/**\n * @type {import('../transition/public.js').TransitionConfig}\n */\nconst null_transition = { duration: 0 };\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {TransitionFn} fn\n * @param {any} params\n * @returns {{ start(): void; invalidate(): void; end(): void; }}\n */\nexport function create_in_transition(node, fn, params) {\n\t/**\n\t * @type {TransitionOptions} */\n\tconst options = { direction: 'in' };\n\tlet config = fn(node, params, options);\n\tlet running = false;\n\tlet animation_name;\n\tlet task;\n\tlet uid = 0;\n\n\t/**\n\t * @returns {void} */\n\tfunction cleanup() {\n\t\tif (animation_name) delete_rule(node, animation_name);\n\t}\n\n\t/**\n\t * @returns {void} */\n\tfunction go() {\n\t\tconst {\n\t\t\tdelay = 0,\n\t\t\tduration = 300,\n\t\t\teasing = linear,\n\t\t\ttick = noop,\n\t\t\tcss\n\t\t} = config || null_transition;\n\t\tif (css) animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n\t\ttick(0, 1);\n\t\tconst start_time = now() + delay;\n\t\tconst end_time = start_time + duration;\n\t\tif (task) task.abort();\n\t\trunning = true;\n\t\tadd_render_callback(() => dispatch(node, true, 'start'));\n\t\ttask = loop((now) => {\n\t\t\tif (running) {\n\t\t\t\tif (now >= end_time) {\n\t\t\t\t\ttick(1, 0);\n\t\t\t\t\tdispatch(node, true, 'end');\n\t\t\t\t\tcleanup();\n\t\t\t\t\treturn (running = false);\n\t\t\t\t}\n\t\t\t\tif (now >= start_time) {\n\t\t\t\t\tconst t = easing((now - start_time) / duration);\n\t\t\t\t\ttick(t, 1 - t);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn running;\n\t\t});\n\t}\n\tlet started = false;\n\treturn {\n\t\tstart() {\n\t\t\tif (started) return;\n\t\t\tstarted = true;\n\t\t\tdelete_rule(node);\n\t\t\tif (is_function(config)) {\n\t\t\t\tconfig = config(options);\n\t\t\t\twait().then(go);\n\t\t\t} else {\n\t\t\t\tgo();\n\t\t\t}\n\t\t},\n\t\tinvalidate() {\n\t\t\tstarted = false;\n\t\t},\n\t\tend() {\n\t\t\tif (running) {\n\t\t\t\tcleanup();\n\t\t\t\trunning = false;\n\t\t\t}\n\t\t}\n\t};\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {TransitionFn} fn\n * @param {any} params\n * @returns {{ end(reset: any): void; }}\n */\nexport function create_out_transition(node, fn, params) {\n\t/** @type {TransitionOptions} */\n\tconst options = { direction: 'out' };\n\tlet config = fn(node, params, options);\n\tlet running = true;\n\tlet animation_name;\n\tconst group = outros;\n\tgroup.r += 1;\n\t/** @type {boolean} */\n\tlet original_inert_value;\n\n\t/**\n\t * @returns {void} */\n\tfunction go() {\n\t\tconst {\n\t\t\tdelay = 0,\n\t\t\tduration = 300,\n\t\t\teasing = linear,\n\t\t\ttick = noop,\n\t\t\tcss\n\t\t} = config || null_transition;\n\n\t\tif (css) animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n\n\t\tconst start_time = now() + delay;\n\t\tconst end_time = start_time + duration;\n\t\tadd_render_callback(() => dispatch(node, false, 'start'));\n\n\t\tif ('inert' in node) {\n\t\t\toriginal_inert_value = /** @type {HTMLElement} */ (node).inert;\n\t\t\tnode.inert = true;\n\t\t}\n\n\t\tloop((now) => {\n\t\t\tif (running) {\n\t\t\t\tif (now >= end_time) {\n\t\t\t\t\ttick(0, 1);\n\t\t\t\t\tdispatch(node, false, 'end');\n\t\t\t\t\tif (!--group.r) {\n\t\t\t\t\t\t// this will result in `end()` being called,\n\t\t\t\t\t\t// so we don't need to clean up here\n\t\t\t\t\t\trun_all(group.c);\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (now >= start_time) {\n\t\t\t\t\tconst t = easing((now - start_time) / duration);\n\t\t\t\t\ttick(1 - t, t);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn running;\n\t\t});\n\t}\n\n\tif (is_function(config)) {\n\t\twait().then(() => {\n\t\t\t// @ts-ignore\n\t\t\tconfig = config(options);\n\t\t\tgo();\n\t\t});\n\t} else {\n\t\tgo();\n\t}\n\n\treturn {\n\t\tend(reset) {\n\t\t\tif (reset && 'inert' in node) {\n\t\t\t\tnode.inert = original_inert_value;\n\t\t\t}\n\t\t\tif (reset && config.tick) {\n\t\t\t\tconfig.tick(1, 0);\n\t\t\t}\n\t\t\tif (running) {\n\t\t\t\tif (animation_name) delete_rule(node, animation_name);\n\t\t\t\trunning = false;\n\t\t\t}\n\t\t}\n\t};\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} node\n * @param {TransitionFn} fn\n * @param {any} params\n * @param {boolean} intro\n * @returns {{ run(b: 0 | 1): void; end(): void; }}\n */\nexport function create_bidirectional_transition(node, fn, params, intro) {\n\t/**\n\t * @type {TransitionOptions} */\n\tconst options = { direction: 'both' };\n\tlet config = fn(node, params, options);\n\tlet t = intro ? 0 : 1;\n\n\t/**\n\t * @type {Program | null} */\n\tlet running_program = null;\n\n\t/**\n\t * @type {PendingProgram | null} */\n\tlet pending_program = null;\n\tlet animation_name = null;\n\n\t/** @type {boolean} */\n\tlet original_inert_value;\n\n\t/**\n\t * @returns {void} */\n\tfunction clear_animation() {\n\t\tif (animation_name) delete_rule(node, animation_name);\n\t}\n\n\t/**\n\t * @param {PendingProgram} program\n\t * @param {number} duration\n\t * @returns {Program}\n\t */\n\tfunction init(program, duration) {\n\t\tconst d = /** @type {Program['d']} */ (program.b - t);\n\t\tduration *= Math.abs(d);\n\t\treturn {\n\t\t\ta: t,\n\t\t\tb: program.b,\n\t\t\td,\n\t\t\tduration,\n\t\t\tstart: program.start,\n\t\t\tend: program.start + duration,\n\t\t\tgroup: program.group\n\t\t};\n\t}\n\n\t/**\n\t * @param {INTRO | OUTRO} b\n\t * @returns {void}\n\t */\n\tfunction go(b) {\n\t\tconst {\n\t\t\tdelay = 0,\n\t\t\tduration = 300,\n\t\t\teasing = linear,\n\t\t\ttick = noop,\n\t\t\tcss\n\t\t} = config || null_transition;\n\n\t\t/**\n\t\t * @type {PendingProgram} */\n\t\tconst program = {\n\t\t\tstart: now() + delay,\n\t\t\tb\n\t\t};\n\n\t\tif (!b) {\n\t\t\t// @ts-ignore todo: improve typings\n\t\t\tprogram.group = outros;\n\t\t\toutros.r += 1;\n\t\t}\n\n\t\tif ('inert' in node) {\n\t\t\tif (b) {\n\t\t\t\tif (original_inert_value !== undefined) {\n\t\t\t\t\t// aborted/reversed outro  restore previous inert value\n\t\t\t\t\tnode.inert = original_inert_value;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toriginal_inert_value = /** @type {HTMLElement} */ (node).inert;\n\t\t\t\tnode.inert = true;\n\t\t\t}\n\t\t}\n\n\t\tif (running_program || pending_program) {\n\t\t\tpending_program = program;\n\t\t} else {\n\t\t\t// if this is an intro, and there's a delay, we need to do\n\t\t\t// an initial tick and/or apply CSS animation immediately\n\t\t\tif (css) {\n\t\t\t\tclear_animation();\n\t\t\t\tanimation_name = create_rule(node, t, b, duration, delay, easing, css);\n\t\t\t}\n\t\t\tif (b) tick(0, 1);\n\t\t\trunning_program = init(program, duration);\n\t\t\tadd_render_callback(() => dispatch(node, b, 'start'));\n\t\t\tloop((now) => {\n\t\t\t\tif (pending_program && now > pending_program.start) {\n\t\t\t\t\trunning_program = init(pending_program, duration);\n\t\t\t\t\tpending_program = null;\n\t\t\t\t\tdispatch(node, running_program.b, 'start');\n\t\t\t\t\tif (css) {\n\t\t\t\t\t\tclear_animation();\n\t\t\t\t\t\tanimation_name = create_rule(\n\t\t\t\t\t\t\tnode,\n\t\t\t\t\t\t\tt,\n\t\t\t\t\t\t\trunning_program.b,\n\t\t\t\t\t\t\trunning_program.duration,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\teasing,\n\t\t\t\t\t\t\tconfig.css\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (running_program) {\n\t\t\t\t\tif (now >= running_program.end) {\n\t\t\t\t\t\ttick((t = running_program.b), 1 - t);\n\t\t\t\t\t\tdispatch(node, running_program.b, 'end');\n\t\t\t\t\t\tif (!pending_program) {\n\t\t\t\t\t\t\t// we're done\n\t\t\t\t\t\t\tif (running_program.b) {\n\t\t\t\t\t\t\t\t// intro  we can tidy up immediately\n\t\t\t\t\t\t\t\tclear_animation();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// outro  needs to be coordinated\n\t\t\t\t\t\t\t\tif (!--running_program.group.r) run_all(running_program.group.c);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\trunning_program = null;\n\t\t\t\t\t} else if (now >= running_program.start) {\n\t\t\t\t\t\tconst p = now - running_program.start;\n\t\t\t\t\t\tt = running_program.a + running_program.d * easing(p / running_program.duration);\n\t\t\t\t\t\ttick(t, 1 - t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn !!(running_program || pending_program);\n\t\t\t});\n\t\t}\n\t}\n\treturn {\n\t\trun(b) {\n\t\t\tif (is_function(config)) {\n\t\t\t\twait().then(() => {\n\t\t\t\t\tconst opts = { direction: b ? 'in' : 'out' };\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tconfig = config(opts);\n\t\t\t\t\tgo(b);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tgo(b);\n\t\t\t}\n\t\t},\n\t\tend() {\n\t\t\tclear_animation();\n\t\t\trunning_program = pending_program = null;\n\t\t}\n\t};\n}\n\n/** @typedef {1} INTRO */\n/** @typedef {0} OUTRO */\n/** @typedef {{ direction: 'in' | 'out' | 'both' }} TransitionOptions */\n/** @typedef {(node: Element, params: any, options: TransitionOptions) => import('../transition/public.js').TransitionConfig} TransitionFn */\n\n/**\n * @typedef {Object} Outro\n * @property {number} r\n * @property {Function[]} c\n * @property {Object} p\n */\n\n/**\n * @typedef {Object} PendingProgram\n * @property {number} start\n * @property {INTRO|OUTRO} b\n * @property {Outro} [group]\n */\n\n/**\n * @typedef {Object} Program\n * @property {number} a\n * @property {INTRO|OUTRO} b\n * @property {1|-1} d\n * @property {number} duration\n * @property {number} start\n * @property {number} end\n * @property {Outro} [group]\n */\n","import { transition_in, transition_out } from './transitions.js';\nimport { run_all } from './utils.js';\n\n// general each functions:\n\nexport function ensure_array_like(array_like_or_iterator) {\n\treturn array_like_or_iterator?.length !== undefined\n\t\t? array_like_or_iterator\n\t\t: Array.from(array_like_or_iterator);\n}\n\n// keyed each functions:\n\n/** @returns {void} */\nexport function destroy_block(block, lookup) {\n\tblock.d(1);\n\tlookup.delete(block.key);\n}\n\n/** @returns {void} */\nexport function outro_and_destroy_block(block, lookup) {\n\ttransition_out(block, 1, 1, () => {\n\t\tlookup.delete(block.key);\n\t});\n}\n\n/** @returns {void} */\nexport function fix_and_destroy_block(block, lookup) {\n\tblock.f();\n\tdestroy_block(block, lookup);\n}\n\n/** @returns {void} */\nexport function fix_and_outro_and_destroy_block(block, lookup) {\n\tblock.f();\n\toutro_and_destroy_block(block, lookup);\n}\n\n/** @returns {any[]} */\nexport function update_keyed_each(\n\told_blocks,\n\tdirty,\n\tget_key,\n\tdynamic,\n\tctx,\n\tlist,\n\tlookup,\n\tnode,\n\tdestroy,\n\tcreate_each_block,\n\tnext,\n\tget_context\n) {\n\tlet o = old_blocks.length;\n\tlet n = list.length;\n\tlet i = o;\n\tconst old_indexes = {};\n\twhile (i--) old_indexes[old_blocks[i].key] = i;\n\tconst new_blocks = [];\n\tconst new_lookup = new Map();\n\tconst deltas = new Map();\n\tconst updates = [];\n\ti = n;\n\twhile (i--) {\n\t\tconst child_ctx = get_context(ctx, list, i);\n\t\tconst key = get_key(child_ctx);\n\t\tlet block = lookup.get(key);\n\t\tif (!block) {\n\t\t\tblock = create_each_block(key, child_ctx);\n\t\t\tblock.c();\n\t\t} else if (dynamic) {\n\t\t\t// defer updates until all the DOM shuffling is done\n\t\t\tupdates.push(() => block.p(child_ctx, dirty));\n\t\t}\n\t\tnew_lookup.set(key, (new_blocks[i] = block));\n\t\tif (key in old_indexes) deltas.set(key, Math.abs(i - old_indexes[key]));\n\t}\n\tconst will_move = new Set();\n\tconst did_move = new Set();\n\t/** @returns {void} */\n\tfunction insert(block) {\n\t\ttransition_in(block, 1);\n\t\tblock.m(node, next);\n\t\tlookup.set(block.key, block);\n\t\tnext = block.first;\n\t\tn--;\n\t}\n\twhile (o && n) {\n\t\tconst new_block = new_blocks[n - 1];\n\t\tconst old_block = old_blocks[o - 1];\n\t\tconst new_key = new_block.key;\n\t\tconst old_key = old_block.key;\n\t\tif (new_block === old_block) {\n\t\t\t// do nothing\n\t\t\tnext = new_block.first;\n\t\t\to--;\n\t\t\tn--;\n\t\t} else if (!new_lookup.has(old_key)) {\n\t\t\t// remove old block\n\t\t\tdestroy(old_block, lookup);\n\t\t\to--;\n\t\t} else if (!lookup.has(new_key) || will_move.has(new_key)) {\n\t\t\tinsert(new_block);\n\t\t} else if (did_move.has(old_key)) {\n\t\t\to--;\n\t\t} else if (deltas.get(new_key) > deltas.get(old_key)) {\n\t\t\tdid_move.add(new_key);\n\t\t\tinsert(new_block);\n\t\t} else {\n\t\t\twill_move.add(old_key);\n\t\t\to--;\n\t\t}\n\t}\n\twhile (o--) {\n\t\tconst old_block = old_blocks[o];\n\t\tif (!new_lookup.has(old_block.key)) destroy(old_block, lookup);\n\t}\n\twhile (n) insert(new_blocks[n - 1]);\n\trun_all(updates);\n\treturn new_blocks;\n}\n\n/** @returns {void} */\nexport function validate_each_keys(ctx, list, get_context, get_key) {\n\tconst keys = new Map();\n\tfor (let i = 0; i < list.length; i++) {\n\t\tconst key = get_key(get_context(ctx, list, i));\n\t\tif (keys.has(key)) {\n\t\t\tlet value = '';\n\t\t\ttry {\n\t\t\t\tvalue = `with value '${String(key)}' `;\n\t\t\t} catch (e) {\n\t\t\t\t// can't stringify\n\t\t\t}\n\t\t\tthrow new Error(\n\t\t\t\t`Cannot have duplicate keys in a keyed each: Keys at index ${keys.get(\n\t\t\t\t\tkey\n\t\t\t\t)} and ${i} ${value}are duplicates`\n\t\t\t);\n\t\t}\n\t\tkeys.set(key, i);\n\t}\n}\n","import {\n\tadd_render_callback,\n\tflush,\n\tflush_render_callbacks,\n\tschedule_update,\n\tdirty_components\n} from './scheduler.js';\nimport { current_component, set_current_component } from './lifecycle.js';\nimport { blank_object, is_empty, is_function, run, run_all, noop } from './utils.js';\nimport {\n\tchildren,\n\tdetach,\n\tstart_hydrating,\n\tend_hydrating,\n\tget_custom_elements_slots,\n\tinsert,\n\telement,\n\tattr\n} from './dom.js';\nimport { transition_in } from './transitions.js';\n\n/** @returns {void} */\nexport function bind(component, name, callback) {\n\tconst index = component.$$.props[name];\n\tif (index !== undefined) {\n\t\tcomponent.$$.bound[index] = callback;\n\t\tcallback(component.$$.ctx[index]);\n\t}\n}\n\n/** @returns {void} */\nexport function create_component(block) {\n\tblock && block.c();\n}\n\n/** @returns {void} */\nexport function claim_component(block, parent_nodes) {\n\tblock && block.l(parent_nodes);\n}\n\n/** @returns {void} */\nexport function mount_component(component, target, anchor) {\n\tconst { fragment, after_update } = component.$$;\n\tfragment && fragment.m(target, anchor);\n\t// onMount happens before the initial afterUpdate\n\tadd_render_callback(() => {\n\t\tconst new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n\t\t// if the component was destroyed immediately\n\t\t// it will update the `$$.on_destroy` reference to `null`.\n\t\t// the destructured on_destroy may still reference to the old array\n\t\tif (component.$$.on_destroy) {\n\t\t\tcomponent.$$.on_destroy.push(...new_on_destroy);\n\t\t} else {\n\t\t\t// Edge case - component was destroyed immediately,\n\t\t\t// most likely as a result of a binding initialising\n\t\t\trun_all(new_on_destroy);\n\t\t}\n\t\tcomponent.$$.on_mount = [];\n\t});\n\tafter_update.forEach(add_render_callback);\n}\n\n/** @returns {void} */\nexport function destroy_component(component, detaching) {\n\tconst $$ = component.$$;\n\tif ($$.fragment !== null) {\n\t\tflush_render_callbacks($$.after_update);\n\t\trun_all($$.on_destroy);\n\t\t$$.fragment && $$.fragment.d(detaching);\n\t\t// TODO null out other refs, including component.$$ (but need to\n\t\t// preserve final state?)\n\t\t$$.on_destroy = $$.fragment = null;\n\t\t$$.ctx = [];\n\t}\n}\n\n/** @returns {void} */\nfunction make_dirty(component, i) {\n\tif (component.$$.dirty[0] === -1) {\n\t\tdirty_components.push(component);\n\t\tschedule_update();\n\t\tcomponent.$$.dirty.fill(0);\n\t}\n\tcomponent.$$.dirty[(i / 31) | 0] |= 1 << i % 31;\n}\n\n// TODO: Document the other params\n/**\n * @param {SvelteComponent} component\n * @param {import('./public.js').ComponentConstructorOptions} options\n *\n * @param {import('./utils.js')['not_equal']} not_equal Used to compare props and state values.\n * @param {(target: Element | ShadowRoot) => void} [append_styles] Function that appends styles to the DOM when the component is first initialised.\n * This will be the `add_css` function from the compiled component.\n *\n * @returns {void}\n */\nexport function init(\n\tcomponent,\n\toptions,\n\tinstance,\n\tcreate_fragment,\n\tnot_equal,\n\tprops,\n\tappend_styles = null,\n\tdirty = [-1]\n) {\n\tconst parent_component = current_component;\n\tset_current_component(component);\n\t/** @type {import('./private.js').T$$} */\n\tconst $$ = (component.$$ = {\n\t\tfragment: null,\n\t\tctx: [],\n\t\t// state\n\t\tprops,\n\t\tupdate: noop,\n\t\tnot_equal,\n\t\tbound: blank_object(),\n\t\t// lifecycle\n\t\ton_mount: [],\n\t\ton_destroy: [],\n\t\ton_disconnect: [],\n\t\tbefore_update: [],\n\t\tafter_update: [],\n\t\tcontext: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n\t\t// everything else\n\t\tcallbacks: blank_object(),\n\t\tdirty,\n\t\tskip_bound: false,\n\t\troot: options.target || parent_component.$$.root\n\t});\n\tappend_styles && append_styles($$.root);\n\tlet ready = false;\n\t$$.ctx = instance\n\t\t? instance(component, options.props || {}, (i, ret, ...rest) => {\n\t\t\t\tconst value = rest.length ? rest[0] : ret;\n\t\t\t\tif ($$.ctx && not_equal($$.ctx[i], ($$.ctx[i] = value))) {\n\t\t\t\t\tif (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);\n\t\t\t\t\tif (ready) make_dirty(component, i);\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t  })\n\t\t: [];\n\t$$.update();\n\tready = true;\n\trun_all($$.before_update);\n\t// `false` as a special case of no DOM component\n\t$$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n\tif (options.target) {\n\t\tif (options.hydrate) {\n\t\t\tstart_hydrating();\n\t\t\t// TODO: what is the correct type here?\n\t\t\t// @ts-expect-error\n\t\t\tconst nodes = children(options.target);\n\t\t\t$$.fragment && $$.fragment.l(nodes);\n\t\t\tnodes.forEach(detach);\n\t\t} else {\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\t\t\t$$.fragment && $$.fragment.c();\n\t\t}\n\t\tif (options.intro) transition_in(component.$$.fragment);\n\t\tmount_component(component, options.target, options.anchor);\n\t\tend_hydrating();\n\t\tflush();\n\t}\n\tset_current_component(parent_component);\n}\n\nexport let SvelteElement;\n\nif (typeof HTMLElement === 'function') {\n\tSvelteElement = class extends HTMLElement {\n\t\t/** The Svelte component constructor */\n\t\t$$ctor;\n\t\t/** Slots */\n\t\t$$s;\n\t\t/** The Svelte component instance */\n\t\t$$c;\n\t\t/** Whether or not the custom element is connected */\n\t\t$$cn = false;\n\t\t/** Component props data */\n\t\t$$d = {};\n\t\t/** `true` if currently in the process of reflecting component props back to attributes */\n\t\t$$r = false;\n\t\t/** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */\n\t\t$$p_d = {};\n\t\t/** @type {Record<string, Function[]>} Event listeners */\n\t\t$$l = {};\n\t\t/** @type {Map<Function, Function>} Event listener unsubscribe functions */\n\t\t$$l_u = new Map();\n\n\t\tconstructor($$componentCtor, $$slots, use_shadow_dom) {\n\t\t\tsuper();\n\t\t\tthis.$$ctor = $$componentCtor;\n\t\t\tthis.$$s = $$slots;\n\t\t\tif (use_shadow_dom) {\n\t\t\t\tthis.attachShadow({ mode: 'open' });\n\t\t\t}\n\t\t}\n\n\t\taddEventListener(type, listener, options) {\n\t\t\t// We can't determine upfront if the event is a custom event or not, so we have to\n\t\t\t// listen to both. If someone uses a custom event with the same name as a regular\n\t\t\t// browser event, this fires twice - we can't avoid that.\n\t\t\tthis.$$l[type] = this.$$l[type] || [];\n\t\t\tthis.$$l[type].push(listener);\n\t\t\tif (this.$$c) {\n\t\t\t\tconst unsub = this.$$c.$on(type, listener);\n\t\t\t\tthis.$$l_u.set(listener, unsub);\n\t\t\t}\n\t\t\tsuper.addEventListener(type, listener, options);\n\t\t}\n\n\t\tremoveEventListener(type, listener, options) {\n\t\t\tsuper.removeEventListener(type, listener, options);\n\t\t\tif (this.$$c) {\n\t\t\t\tconst unsub = this.$$l_u.get(listener);\n\t\t\t\tif (unsub) {\n\t\t\t\t\tunsub();\n\t\t\t\t\tthis.$$l_u.delete(listener);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.$$l[type]) {\n\t\t\t\tconst idx = this.$$l[type].indexOf(listener);\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\tthis.$$l[type].splice(idx, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tasync connectedCallback() {\n\t\t\tthis.$$cn = true;\n\t\t\tif (!this.$$c) {\n\t\t\t\t// We wait one tick to let possible child slot elements be created/mounted\n\t\t\t\tawait Promise.resolve();\n\t\t\t\tif (!this.$$cn || this.$$c) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tfunction create_slot(name) {\n\t\t\t\t\treturn () => {\n\t\t\t\t\t\tlet node;\n\t\t\t\t\t\tconst obj = {\n\t\t\t\t\t\t\tc: function create() {\n\t\t\t\t\t\t\t\tnode = element('slot');\n\t\t\t\t\t\t\t\tif (name !== 'default') {\n\t\t\t\t\t\t\t\t\tattr(node, 'name', name);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * @param {HTMLElement} target\n\t\t\t\t\t\t\t * @param {HTMLElement} [anchor]\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tm: function mount(target, anchor) {\n\t\t\t\t\t\t\t\tinsert(target, node, anchor);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\td: function destroy(detaching) {\n\t\t\t\t\t\t\t\tif (detaching) {\n\t\t\t\t\t\t\t\t\tdetach(node);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t\treturn obj;\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tconst $$slots = {};\n\t\t\t\tconst existing_slots = get_custom_elements_slots(this);\n\t\t\t\tfor (const name of this.$$s) {\n\t\t\t\t\tif (name in existing_slots) {\n\t\t\t\t\t\t$$slots[name] = [create_slot(name)];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (const attribute of this.attributes) {\n\t\t\t\t\t// this.$$data takes precedence over this.attributes\n\t\t\t\t\tconst name = this.$$g_p(attribute.name);\n\t\t\t\t\tif (!(name in this.$$d)) {\n\t\t\t\t\t\tthis.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, 'toProp');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Port over props that were set programmatically before ce was initialized\n\t\t\t\tfor (const key in this.$$p_d) {\n\t\t\t\t\tif (!(key in this.$$d) && this[key] !== undefined) {\n\t\t\t\t\t\tthis.$$d[key] = this[key]; // don't transform, these were set through JavaScript\n\t\t\t\t\t\tdelete this[key]; // remove the property that shadows the getter/setter\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.$$c = new this.$$ctor({\n\t\t\t\t\ttarget: this.shadowRoot || this,\n\t\t\t\t\tprops: {\n\t\t\t\t\t\t...this.$$d,\n\t\t\t\t\t\t$$slots,\n\t\t\t\t\t\t$$scope: {\n\t\t\t\t\t\t\tctx: []\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// Reflect component props as attributes\n\t\t\t\tconst reflect_attributes = () => {\n\t\t\t\t\tthis.$$r = true;\n\t\t\t\t\tfor (const key in this.$$p_d) {\n\t\t\t\t\t\tthis.$$d[key] = this.$$c.$$.ctx[this.$$c.$$.props[key]];\n\t\t\t\t\t\tif (this.$$p_d[key].reflect) {\n\t\t\t\t\t\t\tconst attribute_value = get_custom_element_value(\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\tthis.$$d[key],\n\t\t\t\t\t\t\t\tthis.$$p_d,\n\t\t\t\t\t\t\t\t'toAttribute'\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (attribute_value == null) {\n\t\t\t\t\t\t\t\tthis.removeAttribute(this.$$p_d[key].attribute || key);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.setAttribute(this.$$p_d[key].attribute || key, attribute_value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis.$$r = false;\n\t\t\t\t};\n\t\t\t\tthis.$$c.$$.after_update.push(reflect_attributes);\n\t\t\t\treflect_attributes(); // once initially because after_update is added too late for first render\n\n\t\t\t\tfor (const type in this.$$l) {\n\t\t\t\t\tfor (const listener of this.$$l[type]) {\n\t\t\t\t\t\tconst unsub = this.$$c.$on(type, listener);\n\t\t\t\t\t\tthis.$$l_u.set(listener, unsub);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.$$l = {};\n\t\t\t}\n\t\t}\n\n\t\t// We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte\n\t\t// and setting attributes through setAttribute etc, this is helpful\n\t\tattributeChangedCallback(attr, _oldValue, newValue) {\n\t\t\tif (this.$$r) return;\n\t\t\tattr = this.$$g_p(attr);\n\t\t\tthis.$$d[attr] = get_custom_element_value(attr, newValue, this.$$p_d, 'toProp');\n\t\t\tthis.$$c?.$set({ [attr]: this.$$d[attr] });\n\t\t}\n\n\t\tdisconnectedCallback() {\n\t\t\tthis.$$cn = false;\n\t\t\t// In a microtask, because this could be a move within the DOM\n\t\t\tPromise.resolve().then(() => {\n\t\t\t\tif (!this.$$cn && this.$$c) {\n\t\t\t\t\tthis.$$c.$destroy();\n\t\t\t\t\tthis.$$c = undefined;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t$$g_p(attribute_name) {\n\t\t\treturn (\n\t\t\t\tObject.keys(this.$$p_d).find(\n\t\t\t\t\t(key) =>\n\t\t\t\t\t\tthis.$$p_d[key].attribute === attribute_name ||\n\t\t\t\t\t\t(!this.$$p_d[key].attribute && key.toLowerCase() === attribute_name)\n\t\t\t\t) || attribute_name\n\t\t\t);\n\t\t}\n\t};\n}\n\n/**\n * @param {string} prop\n * @param {any} value\n * @param {Record<string, CustomElementPropDefinition>} props_definition\n * @param {'toAttribute' | 'toProp'} [transform]\n */\nfunction get_custom_element_value(prop, value, props_definition, transform) {\n\tconst type = props_definition[prop]?.type;\n\tvalue = type === 'Boolean' && typeof value !== 'boolean' ? value != null : value;\n\tif (!transform || !props_definition[prop]) {\n\t\treturn value;\n\t} else if (transform === 'toAttribute') {\n\t\tswitch (type) {\n\t\t\tcase 'Object':\n\t\t\tcase 'Array':\n\t\t\t\treturn value == null ? null : JSON.stringify(value);\n\t\t\tcase 'Boolean':\n\t\t\t\treturn value ? '' : null;\n\t\t\tcase 'Number':\n\t\t\t\treturn value == null ? null : value;\n\t\t\tdefault:\n\t\t\t\treturn value;\n\t\t}\n\t} else {\n\t\tswitch (type) {\n\t\t\tcase 'Object':\n\t\t\tcase 'Array':\n\t\t\t\treturn value && JSON.parse(value);\n\t\t\tcase 'Boolean':\n\t\t\t\treturn value; // conversion already handled above\n\t\t\tcase 'Number':\n\t\t\t\treturn value != null ? +value : value;\n\t\t\tdefault:\n\t\t\t\treturn value;\n\t\t}\n\t}\n}\n\n/**\n * @internal\n *\n * Turn a Svelte component into a custom element.\n * @param {import('./public.js').ComponentType} Component  A Svelte component constructor\n * @param {Record<string, CustomElementPropDefinition>} props_definition  The props to observe\n * @param {string[]} slots  The slots to create\n * @param {string[]} accessors  Other accessors besides the ones for props the component has\n * @param {boolean} use_shadow_dom  Whether to use shadow DOM\n * @param {(ce: new () => HTMLElement) => new () => HTMLElement} [extend]\n */\nexport function create_custom_element(\n\tComponent,\n\tprops_definition,\n\tslots,\n\taccessors,\n\tuse_shadow_dom,\n\textend\n) {\n\tlet Class = class extends SvelteElement {\n\t\tconstructor() {\n\t\t\tsuper(Component, slots, use_shadow_dom);\n\t\t\tthis.$$p_d = props_definition;\n\t\t}\n\t\tstatic get observedAttributes() {\n\t\t\treturn Object.keys(props_definition).map((key) =>\n\t\t\t\t(props_definition[key].attribute || key).toLowerCase()\n\t\t\t);\n\t\t}\n\t};\n\tObject.keys(props_definition).forEach((prop) => {\n\t\tObject.defineProperty(Class.prototype, prop, {\n\t\t\tget() {\n\t\t\t\treturn this.$$c && prop in this.$$c ? this.$$c[prop] : this.$$d[prop];\n\t\t\t},\n\t\t\tset(value) {\n\t\t\t\tvalue = get_custom_element_value(prop, value, props_definition);\n\t\t\t\tthis.$$d[prop] = value;\n\t\t\t\tthis.$$c?.$set({ [prop]: value });\n\t\t\t}\n\t\t});\n\t});\n\taccessors.forEach((accessor) => {\n\t\tObject.defineProperty(Class.prototype, accessor, {\n\t\t\tget() {\n\t\t\t\treturn this.$$c?.[accessor];\n\t\t\t}\n\t\t});\n\t});\n\tif (extend) {\n\t\t// @ts-expect-error - assigning here is fine\n\t\tClass = extend(Class);\n\t}\n\tComponent.element = /** @type {any} */ (Class);\n\treturn Class;\n}\n\n/**\n * Base class for Svelte components. Used when dev=false.\n *\n * @template {Record<string, any>} [Props=any]\n * @template {Record<string, any>} [Events=any]\n */\nexport class SvelteComponent {\n\t/**\n\t * ### PRIVATE API\n\t *\n\t * Do not use, may change at any time\n\t *\n\t * @type {any}\n\t */\n\t$$ = undefined;\n\t/**\n\t * ### PRIVATE API\n\t *\n\t * Do not use, may change at any time\n\t *\n\t * @type {any}\n\t */\n\t$$set = undefined;\n\n\t/** @returns {void} */\n\t$destroy() {\n\t\tdestroy_component(this, 1);\n\t\tthis.$destroy = noop;\n\t}\n\n\t/**\n\t * @template {Extract<keyof Events, string>} K\n\t * @param {K} type\n\t * @param {((e: Events[K]) => void) | null | undefined} callback\n\t * @returns {() => void}\n\t */\n\t$on(type, callback) {\n\t\tif (!is_function(callback)) {\n\t\t\treturn noop;\n\t\t}\n\t\tconst callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n\t\tcallbacks.push(callback);\n\t\treturn () => {\n\t\t\tconst index = callbacks.indexOf(callback);\n\t\t\tif (index !== -1) callbacks.splice(index, 1);\n\t\t};\n\t}\n\n\t/**\n\t * @param {Partial<Props>} props\n\t * @returns {void}\n\t */\n\t$set(props) {\n\t\tif (this.$$set && !is_empty(props)) {\n\t\t\tthis.$$.skip_bound = true;\n\t\t\tthis.$$set(props);\n\t\t\tthis.$$.skip_bound = false;\n\t\t}\n\t}\n}\n\n/**\n * @typedef {Object} CustomElementPropDefinition\n * @property {string} [attribute]\n * @property {boolean} [reflect]\n * @property {'String'|'Boolean'|'Number'|'Array'|'Object'} [type]\n */\n","// generated during release, do not modify\n\n/**\n * The current version, as set in package.json.\n *\n * https://svelte.dev/docs/svelte-compiler#svelte-version\n * @type {string}\n */\nexport const VERSION = '4.2.20';\nexport const PUBLIC_VERSION = '4';\n","import { PUBLIC_VERSION } from '../../../shared/version.js';\n\nif (typeof window !== 'undefined')\n\t// @ts-ignore\n\t(window.__svelte || (window.__svelte = { v: new Set() })).v.add(PUBLIC_VERSION);\n","import type { AbstractSelector } from '@annotorious/core';\n\nexport interface Shape extends AbstractSelector {\n\n  type: ShapeType;\n\n  geometry: Geometry;\n\n}\n\nexport enum ShapeType {\n\n  ELLIPSE = 'ELLIPSE',\n\n  MULTIPOLYGON = 'MULTIPOLYGON',\n\n  POLYGON = 'POLYGON',\n\n  POLYLINE = 'POLYLINE',\n\n  RECTANGLE = 'RECTANGLE',\n\n  LINE = 'LINE'\n\n}\n\nexport interface Geometry {\n\n  bounds: Bounds;\n\n}\n\nexport interface Bounds {\n\n  minX: number;\n\n  minY: number;\n\n  maxX: number;\n\n  maxY: number;\n\n}","/*\n (c) 2017, Vladimir Agafonkin\n Simplify.js, a high-performance JS polyline simplification library\n mourner.github.io/simplify-js\n*/\n\n(function () { 'use strict';\n\n// to suit your point format, run search/replace for '.x' and '.y';\n// for 3D version, see 3d branch (configurability would draw significant performance overhead)\n\n// square distance between 2 points\nfunction getSqDist(p1, p2) {\n\n    var dx = p1.x - p2.x,\n        dy = p1.y - p2.y;\n\n    return dx * dx + dy * dy;\n}\n\n// square distance from a point to a segment\nfunction getSqSegDist(p, p1, p2) {\n\n    var x = p1.x,\n        y = p1.y,\n        dx = p2.x - x,\n        dy = p2.y - y;\n\n    if (dx !== 0 || dy !== 0) {\n\n        var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);\n\n        if (t > 1) {\n            x = p2.x;\n            y = p2.y;\n\n        } else if (t > 0) {\n            x += dx * t;\n            y += dy * t;\n        }\n    }\n\n    dx = p.x - x;\n    dy = p.y - y;\n\n    return dx * dx + dy * dy;\n}\n// rest of the code doesn't care about point format\n\n// basic distance-based simplification\nfunction simplifyRadialDist(points, sqTolerance) {\n\n    var prevPoint = points[0],\n        newPoints = [prevPoint],\n        point;\n\n    for (var i = 1, len = points.length; i < len; i++) {\n        point = points[i];\n\n        if (getSqDist(point, prevPoint) > sqTolerance) {\n            newPoints.push(point);\n            prevPoint = point;\n        }\n    }\n\n    if (prevPoint !== point) newPoints.push(point);\n\n    return newPoints;\n}\n\nfunction simplifyDPStep(points, first, last, sqTolerance, simplified) {\n    var maxSqDist = sqTolerance,\n        index;\n\n    for (var i = first + 1; i < last; i++) {\n        var sqDist = getSqSegDist(points[i], points[first], points[last]);\n\n        if (sqDist > maxSqDist) {\n            index = i;\n            maxSqDist = sqDist;\n        }\n    }\n\n    if (maxSqDist > sqTolerance) {\n        if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);\n        simplified.push(points[index]);\n        if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);\n    }\n}\n\n// simplification using Ramer-Douglas-Peucker algorithm\nfunction simplifyDouglasPeucker(points, sqTolerance) {\n    var last = points.length - 1;\n\n    var simplified = [points[0]];\n    simplifyDPStep(points, 0, last, sqTolerance, simplified);\n    simplified.push(points[last]);\n\n    return simplified;\n}\n\n// both algorithms combined for awesome performance\nfunction simplify(points, tolerance, highestQuality) {\n\n    if (points.length <= 2) return points;\n\n    var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;\n\n    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);\n    points = simplifyDouglasPeucker(points, sqTolerance);\n\n    return points;\n}\n\n// export as AMD module / Node module / browser or worker variable\nif (typeof define === 'function' && define.amd) define(function() { return simplify; });\nelse if (typeof module !== 'undefined') {\n    module.exports = simplify;\n    module.exports.default = simplify;\n} else if (typeof self !== 'undefined') self.simplify = simplify;\nelse window.simplify = simplify;\n\n})();\n","import simplify from 'simplify-js';\nimport type { Bounds, Shape, ShapeType } from './Shape';\n\nexport interface ShapeUtil<T extends Shape> {\n\n  area: (shape: T) => number;\n\n  intersects: (shape: T, x: number, y: number, buffer?: number) => boolean;\n\n}\n\nconst Utils: { [key: string]: ShapeUtil<any> } = {};\n\n/**\n * Registers a new ShapeUtil for a given shape type.\n * @param type the shape type\n * @param util the ShapeUtil implementation for this shape type\n */\nexport const registerShapeUtil = (type: ShapeType | string, util: ShapeUtil<any>) =>\n  (Utils[type] = util);\n\n/**\n * Computes the area of the given shape. Delegates to the corresponding ShapeUtil.\n * @param shape the shape\n */\nexport const computeArea = (shape: Shape) => Utils[shape.type].area(shape);\n\n/**\n * Tests if the given shape intersects the given point. Delegates to\n * the corresponding ShapeUtil.\n * @param shape the shape\n * @param x point x coord\n * @param y point y coord\n * @param buffer optional buffer around the point to consider as intersection\n * @returns true if shape and point intersect\n */\nexport const intersects = (shape: Shape, x: number, y: number, buffer?: number): boolean =>\n  Utils[shape.type].intersects(shape, x, y, buffer);\n\n/**\n * Computes Bounds from a given list of points.\n * @param points the points\n * @returns the Bounds\n */\nexport const boundsFromPoints = (points: Array<[number, number]>): Bounds => {\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n\n  points.forEach(([x, y]) => {\n    minX = Math.min(minX, x);\n    minY = Math.min(minY, y);\n    maxX = Math.max(maxX, x);\n    maxY = Math.max(maxY, y);\n  });\n\n  return { minX, minY, maxX, maxY };\n}\n\nexport const computePolygonArea = (points: [number, number][]) => {\n  let area = 0;\n  let j = points.length - 1;\n\n  for (let i = 0; i < points.length; i++) {\n    area += (points[j][0] + points[i][0]) * (points[j][1] - points[i][1]);\n    j = i;\n  }\n\n  return Math.abs(0.5 * area);\n}\n\nexport const isPointInPolygon = (points: [number, number][], x: number, y: number): boolean => {\n  // Based on https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html/pnpoly.html\n  let inside = false;\n\n  for (let i = 0, j = points.length - 1; i < points.length; j = i++) {\n    const xi = points[i][0],\n      yi = points[i][1];\n    const xj = points[j][0],\n      yj = points[j][1];\n\n    const intersect = yi > y != yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi;\n\n    if (intersect) inside = !inside;\n  }\n\n  return inside;\n}\n\nexport const pointsToPath = (points: [number, number][], close: boolean = true): string => {\n  let d = 'M ';\n\n  points.forEach(([x, y], idx) => {\n    if (idx === 0) {\n      // First point after the M command\n      d += `${x},${y}`;\n    } else {\n      d += ` L ${x},${y}`;\n    }\n  });\n\n  if (close)\n    d += ' Z';\n\n  return d;\n}\n\nexport const simplifyPoints = (points: number[][], tolerance = 1): [number, number][] => {\n  const mapped = points.map(([x, y]) => ({ x, y }));\n  return simplify(mapped, tolerance, true).map(pt => [pt.x, pt.y]);\n}\n\nexport const distance = (a: [number, number], b: [number, number]): number => {\n  const dx = Math.abs(b[0] - a[0]);\n  const dy = Math.abs(b[1] - a[1]);\n\n  return Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n}","import { ShapeType } from '../Shape';\nimport { registerShapeUtil, type ShapeUtil } from '../shapeUtils';\nimport type { Ellipse } from './Ellipse';\n\nconst EllipseUtil: ShapeUtil<Ellipse> = {\n\n  area: (e: Ellipse): number => Math.PI * e.geometry.rx * e.geometry.ry,\n\n  intersects: (e: Ellipse, x: number, y: number): boolean => {\n    const { cx, cy, rx, ry } = e.geometry;\n\n    // For future use\n    const rot = 0;\n\n    const cos = Math.cos(rot);\n    const sin = Math.sin(rot);\n  \n    const dx  = x - cx;\n    const dy  = y - cy;\n  \n    const tdx = cos * dx + sin * dy;\n    const tdy = sin * dx - cos * dy;\n  \n    return (tdx * tdx) / (rx * rx) + (tdy * tdy) / (ry * ry) <= 1;\n  }\n};\n\nregisterShapeUtil(ShapeType.ELLIPSE, EllipseUtil);","import { ShapeType } from '../Shape';\nimport { distance, registerShapeUtil, type ShapeUtil } from '../shapeUtils';\nimport type { Line } from './Line';\n\nconst LineUtil: ShapeUtil<Line> = {\n\n  area: (_: Line): number => 0,\n\n  intersects: (l: Line, x: number, y: number, buffer: number = 2): boolean => {\n    // See https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line#Line_defined_by_two_points\n    const [[x1, y1], [x2, y2]] = l.geometry.points;\n    \n    // Twice the area of the triangle formed by connecting the three points\n    const area = Math.abs(((y2 - y1) * x) - ((x2 - x1) * y) + (x2 * y1) - (y2 * x1));\n  \n    const length = distance([x1, y1], [x2, y2]);\n\n    return area / length <= buffer;\n  }\n  \n};\n\nregisterShapeUtil(ShapeType.LINE, LineUtil);","import { ShapeType } from '../Shape';\nimport type { ShapeUtil } from '../shapeUtils';\nimport { boundsFromPoints, computePolygonArea, isPointInPolygon, pointsToPath, registerShapeUtil, simplifyPoints } from '../shapeUtils';\nimport type { MultiPolygon, MultiPolygonElement, MultiPolygonGeometry, MultiPolygonRing } from './MultiPolygon';\n\nconst MultiPolygonUtil: ShapeUtil<MultiPolygon> = {\n\n  area: (multiPolygon: MultiPolygon): number => {\n    const { polygons } = multiPolygon.geometry;\n    \n    return polygons.reduce<number>((total, element) => {\n      const [exterior, ...holes] = element.rings;\n      \n      const exteriorArea = computePolygonArea(exterior.points);\n      \n      const holesArea = holes.reduce<number>((total, hole) =>\n        total + computePolygonArea(hole.points), 0);\n      \n      // Add this polygon's contribution to total area\n      return total + exteriorArea - holesArea;\n    }, 0);\n  },\n\n  intersects: (multiPolygon: MultiPolygon, x: number, y: number): boolean => {\n    const { polygons } = multiPolygon.geometry;\n\n    for (const element of polygons) {\n      const [exterior, ...holes] = element.rings;\n      \n      if (isPointInPolygon(exterior.points, x, y)) {\n        let insideAnyHole = false;\n        \n        for (const hole of holes) {\n          if (isPointInPolygon(hole.points, x, y)) {\n            insideAnyHole = true;\n            break;\n          }\n        }\n        \n        if (!insideAnyHole) return true;\n      }\n    }\n\n    return false;\n  }\n  \n}\n\nexport const boundsFromMultiPolygonElements = (elements: MultiPolygonElement[]) => {\n  // All outer points, i.e. the points of each outer ring for each element\n  const outerPoints = elements.reduce<[number, number][]>((points, element) => {\n    return [...points, ...element.rings[0].points];\n  }, []);\n\n  return boundsFromPoints(outerPoints);\n}\n\nexport const multipolygonElementToPath = (element: MultiPolygonElement) => {\n  const paths = element.rings.map(ring => pointsToPath(ring.points));\n  return paths.join(' ');\n}\n\nexport const getAllCorners = (geom: MultiPolygonGeometry) => \n  geom.polygons.reduce<[number, number][]>((all, element) => (\n    [\n      ...all, \n      ...element.rings.reduce<[number, number][]>((onThisElement, ring) => (\n        [...onThisElement, ...ring.points]\n      ), [])\n    ]\n  ), []);\n\nexport const simplifyMultiPolygon = (multi: MultiPolygon, tolerance = 1): MultiPolygon => {\n  const polygons = multi.geometry.polygons.map(polygon => {\n    const rings: MultiPolygonRing[] = polygon.rings.map(ring => {\n      const points = simplifyPoints(ring.points, tolerance);\n      return {\n        ...ring,\n        points\n      }\n    });\n\n    const bounds = boundsFromPoints(rings[0].points);\n\n    return {\n      ...polygon,\n      rings,\n      bounds\n    }\n  });\n\n  const bounds = boundsFromMultiPolygonElements(polygons);\n\n  return {\n    ...multi,\n    geometry: {\n      ...multi.geometry,\n      polygons,\n      bounds\n    }\n  }\n}\n\nregisterShapeUtil(ShapeType.MULTIPOLYGON, MultiPolygonUtil);","import { ShapeType } from '../Shape';\nimport type { ShapeUtil } from '../shapeUtils';\nimport { boundsFromPoints, computePolygonArea, isPointInPolygon, registerShapeUtil, simplifyPoints } from '../shapeUtils';\nimport type { Polygon } from './Polygon';\n\nconst PolygonUtil: ShapeUtil<Polygon> = {\n\n  area: (polygon: Polygon): number => {\n    const points = polygon.geometry.points as [number, number][];\n    return computePolygonArea(points);\n  },\n\n  intersects: (polygon: Polygon, x: number, y: number): boolean => {\n    const points = polygon.geometry.points as [number, number][];\n    return isPointInPolygon(points, x, y);\n  }\n  \n};\n\nexport const simplifyPolygon = (polygon: Polygon, tolerance = 1): Polygon => {\n  const points = simplifyPoints(polygon.geometry.points, tolerance);\n  const bounds = boundsFromPoints(points);\n\n  return {\n    ...polygon,\n    geometry: {\n      ...polygon.geometry,\n      bounds,\n      points\n    }\n  }\n}\n\nregisterShapeUtil(ShapeType.POLYGON, PolygonUtil);","import { ShapeType } from '../Shape';\nimport { computePolygonArea, isPointInPolygon, registerShapeUtil, type ShapeUtil } from '../shapeUtils';\nimport type { Polyline, PolylineGeometry, PolylinePoint } from './Polyline';\n\nconst PolylineUtil: ShapeUtil<Polyline> = {\n\n  area: (polyline: Polyline): number => {\n    const geom = polyline.geometry;\n    \n    if (!geom.closed || geom.points.length < 3)\n      return 0;\n\n    const points = approximateAsPolygon(geom.points, geom.closed);\n    return computePolygonArea(points);\n  },\n\n  intersects: (polyline: Polyline, x: number, y: number, buffer: number = 2): boolean => {\n    const geom = polyline.geometry;\n    \n    if (geom.closed) {\n      const points = approximateAsPolygon(geom.points, geom.closed);\n      return isPointInPolygon(points, x, y);\n    } else {\n      return isPointNearPath(geom, [x, y], buffer);\n    }\n  }\n  \n};\n\nexport const approximateAsPolygon = (corners: PolylinePoint[], closed = false): [number, number][] => {\n  const points: [number, number][] = [];\n  \n  for (let i = 0; i < corners.length; i++) {\n    const currentPoint = corners[i];\n    const nextPoint = corners[(i + 1) % corners.length];\n    \n    points.push(currentPoint.point);\n    \n    // If there's a curve to the next point, approximate it\n    if (i < corners.length - 1 || closed) {\n      const hasCurve = currentPoint.type === 'CURVE' || nextPoint.type == 'CURVE';\n      if (hasCurve) {\n        const curvePoints = approximateBezierCurve(\n          currentPoint.point,\n          currentPoint.type === 'CURVE' ? currentPoint.outHandle || currentPoint.point : currentPoint.point,\n          nextPoint.type === 'CURVE' ? nextPoint.inHandle || nextPoint.point : nextPoint.point,\n          nextPoint.point,\n          10 // number of approximation segments\n        );\n        points.push(...curvePoints.slice(1)); // Skip first point (already added)\n      }\n    }\n  }\n  \n  return points;\n}\n\nconst approximateBezierCurve = (\n  p0: [number, number], \n  p1: [number, number], \n  p2: [number, number], \n  p3: [number, number], \n  segments: number = 10\n): [number, number][] => {\n  const points: [number, number][] = [];\n  \n  for (let i = 0; i <= segments; i++) {\n    const t = i / segments;\n    const x = Math.pow(1 - t, 3) * p0[0] + \n              3 * Math.pow(1 - t, 2) * t * p1[0] + \n              3 * (1 - t) * Math.pow(t, 2) * p2[0] + \n              Math.pow(t, 3) * p3[0];\n    const y = Math.pow(1 - t, 3) * p0[1] + \n              3 * Math.pow(1 - t, 2) * t * p1[1] + \n              3 * (1 - t) * Math.pow(t, 2) * p2[1] + \n              Math.pow(t, 3) * p3[1];\n    points.push([x, y]);\n  }\n  \n  return points;\n}\n\nconst isPointNearPath = (geom: PolylineGeometry, point: [number, number], buffer: number): boolean => {  \n  for (let i = 0; i < geom.points.length - 1; i++) {\n    const currentPoint = geom.points[i];\n    const nextPoint = geom.points[i + 1];\n    \n    const hasCurve = currentPoint.type === 'CURVE' || nextPoint.type === 'CURVE';\n    if (hasCurve) {\n      const curvePoints = approximateBezierCurve(\n        currentPoint.point,\n        currentPoint.type === 'CURVE' ? currentPoint.outHandle || currentPoint.point : currentPoint.point,\n        nextPoint.type === 'CURVE' ? nextPoint.inHandle || nextPoint.point : nextPoint.point,\n        nextPoint.point,\n        20 // TODO make configurable? Based on scale factor? Length?\n      );\n      \n      for (let j = 0; j < curvePoints.length - 1; j++) {\n        const distance = distanceToLineSegment(point, curvePoints[j], curvePoints[j + 1]);\n        if (distance <= buffer) return true;\n      }\n    } else {\n      const distance = distanceToLineSegment(point, currentPoint.point, nextPoint.point);\n      if (distance <= buffer) return true;\n    }\n  }\n  \n  return false;\n}\n\nconst distanceToLineSegment = (\n  point: [number, number], \n  lineStart: [number, number], \n  lineEnd: [number, number]\n): number => {\n  const [px, py] = point;\n  const [x1, y1] = lineStart;\n  const [x2, y2] = lineEnd;\n  \n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  const length = Math.sqrt(dx * dx + dy * dy);\n  \n  if (length === 0) {\n    // Line segment is a point\n    return Math.sqrt((px - x1) * (px - x1) + (py - y1) * (py - y1));\n  }\n  \n  // Calculate the projection parameter t to see where the perpendicular falls\n  const t = ((px - x1) * dx + (py - y1) * dy) / (length * length);\n  \n  if (t <= 0) {\n    // Closest point is the start of the segment\n    return Math.sqrt((px - x1) * (px - x1) + (py - y1) * (py - y1));\n  } else if (t >= 1) {\n    // Closest point is the end of the segment\n    return Math.sqrt((px - x2) * (px - x2) + (py - y2) * (py - y2));\n  } else {\n    // Closest point is on the segment - use the exact line distance formula\n    // This is the same formula as your LineUtil.intersects\n    const area = Math.abs(((y2 - y1) * px) - ((x2 - x1) * py) + (x2 * y1) - (y2 * x1));\n    return area / length;\n  }\n};\n\nexport const computeSVGPath = (geom: PolylineGeometry) => {\n  if (!geom.points || geom.points.length === 0)\n    return '';\n\n  const pathCommands: string[] = [];\n\n  const firstPoint = geom.points[0];\n  pathCommands.push(`M ${firstPoint.point[0]} ${firstPoint.point[1]}`);\n\n  for (let i = 1; i < geom.points.length; i++) {\n    const currentPoint = geom.points[i];\n    const previousPoint = geom.points[i - 1];\n    \n    if (currentPoint.type === 'CURVE' || previousPoint.type === 'CURVE') {\n      // Cubic Bzier curve\n      const cp1 = previousPoint.type === 'CURVE' ? previousPoint.outHandle || previousPoint.point : previousPoint.point;\n      const cp2 = currentPoint.type === 'CURVE' ? currentPoint.inHandle || currentPoint.point : currentPoint.point;\n      const endPoint = currentPoint.point;\n      \n      pathCommands.push(`C ${cp1[0]} ${cp1[1]} ${cp2[0]} ${cp2[1]} ${endPoint[0]} ${endPoint[1]}`);\n    } else {\n      // Straight line\n      pathCommands.push(`L ${currentPoint.point[0]} ${currentPoint.point[1]}`);\n    }\n  }\n\n  if (geom.closed) {\n    // Handle curve from last point back to first point\n    const lastPoint = geom.points[geom.points.length - 1];\n    const firstPointRef = geom.points[0];\n    \n    const hasClosingCurve = lastPoint.type === 'CURVE' || firstPointRef.type === 'CURVE';\n    if (hasClosingCurve) {\n      const cp1 = lastPoint.outHandle || lastPoint.point;\n      const cp2 = firstPointRef.inHandle || firstPointRef.point;\n      const endPoint = firstPointRef.point;\n      \n      pathCommands.push(`C ${cp1[0]} ${cp1[1]} ${cp2[0]} ${cp2[1]} ${endPoint[0]} ${endPoint[1]}`);\n    }\n    \n    pathCommands.push('Z');\n  }\n  \n  return pathCommands.join(' ');\n}\n\nregisterShapeUtil(ShapeType.POLYLINE, PolylineUtil);","import { ShapeType } from '../Shape';\nimport type { Rectangle } from './Rectangle';\nimport { registerShapeUtil, type ShapeUtil } from '../shapeUtils';\n\nexport const RectangleUtil: ShapeUtil<Rectangle> = {\n\n  area: (rect: Rectangle): number => rect.geometry.w * rect.geometry.h,\n\n  intersects: (rect: Rectangle, x: number, y: number): boolean =>\n    x >= rect.geometry.x &&\n    x <= rect.geometry.x + rect.geometry.w &&\n    y >= rect.geometry.y &&\n    y <= rect.geometry.y + rect.geometry.h\n    \n};\n\nregisterShapeUtil(ShapeType.RECTANGLE, RectangleUtil);","import type { Annotation, AnnotationTarget } from '@annotorious/core';\nimport type { Shape } from './Shape';\n\nexport interface ImageAnnotation extends Annotation {\n\n  target: ImageAnnotationTarget;\n\n}\n\nexport interface ImageAnnotationTarget extends AnnotationTarget {\n\n  selector: Shape\n\n}\n\nexport const isImageAnnotation = <T extends Annotation>(\n  a: T | ImageAnnotation\n): a is ImageAnnotation =>\n  isImageAnnotationTarget(a.target);\n\n export const isImageAnnotationTarget = <T extends AnnotationTarget>(\n  t: T | ImageAnnotationTarget\n): t is ImageAnnotationTarget =>\n  t?.annotation !== undefined &&\n (t as ImageAnnotationTarget)?.selector?.geometry?.bounds !== undefined;\n","import type { Rectangle, RectangleGeometry } from '../../core';\nimport { ShapeType } from '../../core';\n\nexport interface FragmentSelector {\n\n  type: 'FragmentSelector';\n\n  conformsTo: 'http://www.w3.org/TR/media-frags/',\n\n  value: string;\n\n}\n\nexport const parseFragmentSelector = (\n  fragmentOrSelector: FragmentSelector | string,\n  invertY = false\n): Rectangle => {\n  const fragment =\n    typeof fragmentOrSelector === 'string' ? fragmentOrSelector : fragmentOrSelector.value;\n\n  const regex = /(xywh)=(pixel|percent)?:?(.+?),(.+?),(.+?),(.+)*/g;\n\n  const matches = [...fragment.matchAll(regex)][0];\n  const [_, prefix, unit, a, b, c, d] = matches;\n\n  if (prefix !== 'xywh') throw new Error('Unsupported MediaFragment: ' + fragment);\n\n  if (unit && unit !== 'pixel') throw new Error(`Unsupported MediaFragment unit: ${unit}`);\n\n  const [x, y, w, h] = [a, b, c, d].map(parseFloat);\n\n  return {\n    type: ShapeType.RECTANGLE,\n    geometry: {\n      x,\n      y,\n      w,\n      h,\n      bounds: {\n        minX: x,\n        minY: invertY ? y - h : y,\n        maxX: x + w,\n        maxY: invertY ? y : y + h\n      }\n    }\n  }\n}\n\nexport const serializeFragmentSelector = (geometry: RectangleGeometry): FragmentSelector => {\n  const { x, y, w, h } = geometry;\n  \n  return {\n    type: 'FragmentSelector',\n    conformsTo: 'http://www.w3.org/TR/media-frags/',\n    value: `xywh=pixel:${x},${y},${w},${h}`\n  };\n}\n","export const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n\nexport const sanitize = (doc: Element | Document) => {\n  // Cf. https://github.com/mattkrick/sanitize-svg#readme  \n  // for the basic approach\n  const cleanEl = (el: Element) => {\n    Array.from(el.attributes).forEach(attr => {\n      if (attr.name.startsWith('on'))\n        el.removeAttribute(attr.name)\n    });\n  }\n\n  // Remove script tags\n  const scripts = doc.getElementsByTagName('script');\n\n  Array.from(scripts).reverse().forEach(el => el.parentNode!.removeChild(el));\n\n  Array.from(doc.querySelectorAll('*')).forEach(cleanEl);\n\n  return doc;\n}\n\n/** Helper that forces an un-namespaced node to SVG **/\nexport const insertSVGNamespace = (originalDoc: Document): Element => {\n  // Serialize and parse for the namespace to take effect on every node\n  const serializer = new XMLSerializer();\n  const str = serializer.serializeToString(originalDoc.documentElement);\n\n  // Doesn't seem that there's a clean cross-browser way for this...\n  const namespaced = str.replace('<svg>', `<svg xmlns=\"${SVG_NAMESPACE}\">`);\n\n  const parser = new DOMParser();\n  const namespacedDoc = parser.parseFromString(namespaced, \"image/svg+xml\");\n  return namespacedDoc.documentElement;\n}\n\nexport const parseSVGXML = (value: string): Element => {\n  const parser = new DOMParser();\n\n  const doc = parser.parseFromString(value, 'image/svg+xml');\n\n  // SVG needs a namespace declaration - check if it's set or insert if not\n  const isPrefixDeclared = doc.lookupPrefix(SVG_NAMESPACE); // SVG declared via prefix\n  const isDefaultNamespaceSVG = doc.lookupNamespaceURI(null); // SVG declared as default namespace\n\n  if (isPrefixDeclared || isDefaultNamespaceSVG) {\n    return sanitize(doc).firstChild as Element;\n  } else {\n    return sanitize(insertSVGNamespace(doc)).firstChild as Element;\n  }\n}","import { approximateAsPolygon, boundsFromPoints } from '../../core';\nimport type { MultiPolygonElement, MultiPolygonRing, PolylineGeometry, PolylinePoint } from '../../core';\n\nexport const svgPathToMultiPolygonElement = (d: string): MultiPolygonElement | undefined => {\n  const commands = parsePathCommands(d);\n  \n  const rings: MultiPolygonRing[] = [];\n  let currentRing: [number, number][] = [];\n  let currentPoint: [number, number] = [0, 0];\n  \n  for (const cmd of commands) {\n    switch (cmd.type.toUpperCase()) {\n      case 'M':\n        // Start a new ring\n        if (currentRing.length > 0) {\n          rings.push({ points: currentRing });\n          currentRing = [];\n        }\n        currentPoint = [cmd.args[0], cmd.args[1]];\n        currentRing.push([...currentPoint]);\n        break;\n        \n      case 'L':\n        currentPoint = [cmd.args[0], cmd.args[1]];\n        currentRing.push([...currentPoint]);\n        break;\n        \n      case 'H':\n        currentPoint = [cmd.args[0], currentPoint[1]];\n        currentRing.push([...currentPoint]);\n        break;\n        \n      case 'V':\n        currentPoint = [currentPoint[0], cmd.args[0]];\n        currentRing.push([...currentPoint]);\n        break;\n        \n      case 'C':\n        // For multi-polygon, we only care about the end point\n        currentPoint = [cmd.args[4], cmd.args[5]];\n        currentRing.push([...currentPoint]);\n        break;\n        \n      case 'Z':\n        // Close the current ring (no action needed since we don't track closed state here)\n        break;\n        \n      default:\n        console.warn(`Unsupported SVG path command: ${cmd.type}`);\n        break;\n    }\n  }\n  \n  if (currentRing.length > 2)\n    rings.push({ points: currentRing });\n  \n  if (rings.length > 0) {\n    const bounds = boundsFromPoints(rings[0].points);    \n    return { rings, bounds };\n  }\n}\n\nconst areHandlesSymmetrical = (pt: PolylinePoint) => {\n  // Check if all three points are on a straight line (with a bit of tolerance)\n  const { point, inHandle, outHandle } = pt;\n\n  if (!inHandle || !outHandle) return false;\n\n  const dx1 = inHandle[0] - point[0];\n  const dy1 = inHandle[1] - point[1];\n  const dx2 = outHandle[0] - point[0];\n  const dy2 = outHandle[1] - point[1];\n\n  const cross = dx1 * dy2 - dy1 * dx2;\n\n  return Math.abs(cross) < 0.01;\n}\n\nexport const svgPathToPolyline = (d: string): PolylineGeometry => {\n  const commands = parsePathCommands(d);\n\n  let points: PolylinePoint[] = [];\n\n  let currentPoint: [number, number] = [0, 0];\n  let closed = false;\n\n  for (let i = 0; i < commands.length; i++) {\n    const cmd = commands[i];\n    \n    switch (cmd.type.toUpperCase()) {\n      case 'M':\n        currentPoint = [cmd.args[0], cmd.args[1]];\n        points.push({\n          type: 'CORNER',\n          point: [...currentPoint]\n        });\n        break;\n        \n      case 'L':\n        currentPoint = [cmd.args[0], cmd.args[1]];\n        points.push({\n          type: 'CORNER',\n          point: [...currentPoint]\n        });\n        break;\n        \n      case 'C':\n        const cp1: [number, number] = [cmd.args[0], cmd.args[1]];\n        const cp2: [number, number] = [cmd.args[2], cmd.args[3]];\n        const endPoint: [number, number] = [cmd.args[4], cmd.args[5]];\n        \n        // Set outHandle for the previous point if it doesn't match the point itself\n        if (points.length > 0) {\n          const prevPoint = points[points.length - 1];\n          if (cp1[0] !== prevPoint.point[0] || cp1[1] !== prevPoint.point[1]) {\n            prevPoint.type = 'CURVE';\n            prevPoint.outHandle = cp1;\n          }\n        }\n        \n        // Create the end point with inHandle if it doesn't match the point itself\n        const newPoint: PolylinePoint = {\n          type: cp2[0] !== endPoint[0] || cp2[1] !== endPoint[1] ? 'CURVE' : 'CORNER',\n          point: endPoint\n        };\n        \n        if (newPoint.type === 'CURVE')\n          newPoint.inHandle = cp2;\n        \n        points.push(newPoint);\n        currentPoint = endPoint;\n        break;\n        \n      case 'Z':\n        closed = true;\n        break;\n        \n      default:\n        console.warn(`Unsupported SVG path command: ${cmd.type}`);\n        break;\n    }\n  }\n\n  points = points.map(pt => areHandlesSymmetrical(pt) ? {...pt, locked: true } : pt);\n  const bounds = boundsFromPoints(approximateAsPolygon(points, closed));\n\n  return {\n    points,\n    closed,\n    bounds\n  };\n}\n\ninterface PathCommand {\n\n  type: string;\n\n  args: number[];\n\n}\n\nconst parsePathCommands = (d: string) => {\n  const commands: PathCommand[] = [];\n  const cleanPath = d.replace(/,/g, ' ').trim();\n  \n  // Updated regex to include H and V commands\n  const commandRegex = /([MmLlHhVvCcZz])\\s*([^MmLlHhVvCcZz]*)/g;\n  let match;\n  \n  while ((match = commandRegex.exec(cleanPath)) !== null) {\n    const [, commandLetter, argsString] = match;\n    const args = argsString.trim() === '' ? [] : \n      argsString.trim().split(/\\s+/).map(Number).filter(n => !isNaN(n));\n    \n    commands.push({\n      type: commandLetter,\n      args\n    });\n  }\n  \n  return commands;\n}","import { boundsFromPoints, computeSVGPath, multipolygonElementToPath, ShapeType } from '../../core';\nimport { parseSVGXML } from './SVG';\nimport { svgPathToMultiPolygonElement, svgPathToPolyline } from './pathParser';\nimport type { \n  Ellipse, \n  EllipseGeometry, \n  Line,\n  LineGeometry,\n  MultiPolygon,\n  MultiPolygonGeometry, \n  Polygon, \n  PolygonGeometry, \n  Polyline,\n  PolylineGeometry, \n  Shape \n} from '../../core';\n\nexport interface SVGSelector {\n\n  type: 'SvgSelector';\n\n  value: string;\n\n}\n\nconst parseSVGPolygon = (value: string): Polygon => {\n  const [_, __, str] = value.match(/(<polygon points=[\"|'])([^(\"|')]*)/) || [];\n  const points = str.split(' ').map((p) => p.split(',').map(parseFloat));\n\n  return {\n    type: ShapeType.POLYGON,\n    geometry: {\n      points,\n      bounds: boundsFromPoints(points as [number, number][])\n    }\n  };\n}\n\nconst parseSVGEllipse = (value: string): Ellipse => {\n  const doc = parseSVGXML(value);\n\n  const cx = parseFloat(doc.getAttribute('cx')!);\n  const cy = parseFloat(doc.getAttribute('cy')!);\n  const rx = parseFloat(doc.getAttribute('rx')!);\n  const ry = parseFloat(doc.getAttribute('ry')!);\n\n  const bounds = {\n    minX: cx - rx,\n    minY: cy - ry,\n    maxX: cx + rx,\n    maxY: cy + ry\n  };\n\n  return {\n    type: ShapeType.ELLIPSE,\n    geometry: {\n      cx,\n      cy,\n      rx,\n      ry,\n      bounds\n    }\n  };\n}\n\nconst parseSVGLine = (value: string): Line => {\n  const doc = parseSVGXML(value);\n\n  const x1 = parseFloat(doc.getAttribute(\"x1\")!);\n  const x2 = parseFloat(doc.getAttribute(\"x2\")!);\n  const y1 = parseFloat(doc.getAttribute(\"y1\")!);\n  const y2 = parseFloat(doc.getAttribute(\"y2\")!);\n\n  const bounds = {\n    minX: Math.min(x1, x2),\n    minY: Math.min(y1, y2),\n    maxX: Math.max(x1, x2),\n    maxY: Math.max(y1, y2),\n  };\n\n  return {\n    type: ShapeType.LINE,\n    geometry: {\n      points: [[x1, y1], [x2, y2]],\n      bounds,\n    },\n  };\n}\n\nconst parseSVGPathToPolyline = (value: string): Polyline => {\n  const doc = parseSVGXML(value);\n\n  const path = doc.nodeName === 'path' ? doc : Array.from(doc.querySelectorAll('path'))[0];\n  const d = path?.getAttribute('d');\n\n  if (!d)\n    throw new Error('Could not parse SVG path');\n\n  const polyline = svgPathToPolyline(d);\n\n  if (!polyline)\n    throw new Error('Could not parse SVG path');\n\n  return {\n    type: ShapeType.POLYLINE,\n    geometry: polyline\n  }\n}\n\nconst parseSVGPathToPolygon = (value: string): Polygon | MultiPolygon => {\n  const doc = parseSVGXML(value);\n\n  const paths = doc.nodeName === 'path' ? [doc] : Array.from(doc.querySelectorAll('path'));\n  const d = paths.map(path => path.getAttribute('d') || '');\n\n  const polygons = d.map(d => svgPathToMultiPolygonElement(d)!).filter(Boolean);\n\n  const outerPoints = polygons.reduce<[number, number][]>((points, element) => {\n    return [...points, ...element.rings[0].points]\n  }, []);\n\n  const bounds = boundsFromPoints(outerPoints);\n\n  // No need to create a MultiPolygon if theres only a single element with an outer ring\n  const isSinglePolygon = polygons.length === 1 && polygons[0].rings.length === 1;\n  return isSinglePolygon ? {\n    type: ShapeType.POLYGON,\n    geometry: {\n      points: outerPoints,\n      bounds\n    }\n  } : {\n    type: ShapeType.MULTIPOLYGON,\n    geometry: {\n      polygons,\n      bounds\n    }\n  }\n}\n\nexport const parseSVGSelector = <T extends Shape>(valueOrSelector: SVGSelector | string): T => {\n  const value = typeof valueOrSelector === 'string' ? valueOrSelector : valueOrSelector.value;\n\n  if (value.includes('<polygon points='))\n    return parseSVGPolygon(value) as unknown as T;\n  else if (value.includes('<path ') && (value.includes(' C ') || !value.includes('Z')))\n    return parseSVGPathToPolyline(value) as unknown as T;\n  else if (value.includes('<path '))\n    return parseSVGPathToPolygon(value) as unknown as T;\n  else if (value.includes('<ellipse ')) \n    return parseSVGEllipse(value) as unknown as T;\n  else if (value.includes(\"<line \"))\n    return parseSVGLine(value) as unknown as T;\n  else \n    throw 'Unsupported SVG shape: ' + value;\n}\n\nconst serializeMultiPolygon = (geom: MultiPolygonGeometry) => {\n  const paths = geom.polygons.map(elem =>\n    `<path fill-rule=\"evenodd\" d=\"${multipolygonElementToPath(elem)}\" />`);\n\n  return `<g>${paths.join('')}</g>`\n} \n\nexport const serializeSVGSelector = (shape: Shape): SVGSelector => {\n  let value: string | undefined;\n\n  switch (shape.type) {\n    case ShapeType.POLYGON: {\n      const geom = shape.geometry as PolygonGeometry;\n      const { points } = geom;\n      value = `<svg><polygon points=\"${points.map((xy) => xy.join(',')).join(' ')}\" /></svg>`;\n      break;\n    }\n    case ShapeType.ELLIPSE: {\n      const geom = shape.geometry as EllipseGeometry;\n      value = `<svg><ellipse cx=\"${geom.cx}\" cy=\"${geom.cy}\" rx=\"${geom.rx}\" ry=\"${geom.ry}\" /></svg>`;\n      break;\n    }\n    case ShapeType.MULTIPOLYGON: {\n      const geom = shape.geometry as MultiPolygonGeometry;\n      value = `<svg>${serializeMultiPolygon(geom)}</svg>`;\n      break;\n    }\n    case ShapeType.LINE: {\n      const geom = shape.geometry as LineGeometry;\n      const [[x1, y1], [x2, y2]] = geom.points;\n      value = `<svg><line x1=\"${x1}\" y1=\"${y1}\" x2=\"${x2}\" y2=\"${y2}\" /></svg>`;\n      break;\n    }\n    case ShapeType.POLYLINE: {\n      const d = computeSVGPath(shape.geometry as PolylineGeometry);\n      value = `<svg><path d=\"${d}\" /></svg>`;\n    }\n  }\n\n  if (value) {\n    return { type: 'SvgSelector', value };\n  } else {\n    throw `Unsupported shape type: ${shape.type}`;\n  }\n}\n","import validate from './validate.js';\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n    byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nexport function unsafeStringify(arr, offset = 0) {\n    return (byteToHex[arr[offset + 0]] +\n        byteToHex[arr[offset + 1]] +\n        byteToHex[arr[offset + 2]] +\n        byteToHex[arr[offset + 3]] +\n        '-' +\n        byteToHex[arr[offset + 4]] +\n        byteToHex[arr[offset + 5]] +\n        '-' +\n        byteToHex[arr[offset + 6]] +\n        byteToHex[arr[offset + 7]] +\n        '-' +\n        byteToHex[arr[offset + 8]] +\n        byteToHex[arr[offset + 9]] +\n        '-' +\n        byteToHex[arr[offset + 10]] +\n        byteToHex[arr[offset + 11]] +\n        byteToHex[arr[offset + 12]] +\n        byteToHex[arr[offset + 13]] +\n        byteToHex[arr[offset + 14]] +\n        byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n    const uuid = unsafeStringify(arr, offset);\n    if (!validate(uuid)) {\n        throw TypeError('Stringified UUID is invalid');\n    }\n    return uuid;\n}\nexport default stringify;\n","let getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n    if (!getRandomValues) {\n        if (typeof crypto === 'undefined' || !crypto.getRandomValues) {\n            throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n        }\n        getRandomValues = crypto.getRandomValues.bind(crypto);\n    }\n    return getRandomValues(rnds8);\n}\n","const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default { randomUUID };\n","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\nfunction _v4(options, buf, offset) {\n    options = options || {};\n    const rnds = options.random ?? options.rng?.() ?? rng();\n    if (rnds.length < 16) {\n        throw new Error('Random bytes length must be >= 16');\n    }\n    rnds[6] = (rnds[6] & 0x0f) | 0x40;\n    rnds[8] = (rnds[8] & 0x3f) | 0x80;\n    if (buf) {\n        offset = offset || 0;\n        if (offset < 0 || offset + 16 > buf.length) {\n            throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);\n        }\n        for (let i = 0; i < 16; ++i) {\n            buf[offset + i] = rnds[i];\n        }\n        return buf;\n    }\n    return unsafeStringify(rnds);\n}\nfunction v4(options, buf, offset) {\n    if (native.randomUUID && !buf && !options) {\n        return native.randomUUID();\n    }\n    return _v4(options, buf, offset);\n}\nexport default v4;\n","var M = Object.prototype.hasOwnProperty;\nfunction N(e, t) {\n  var n, o;\n  if (e === t) return !0;\n  if (e && t && (n = e.constructor) === t.constructor) {\n    if (n === Date) return e.getTime() === t.getTime();\n    if (n === RegExp) return e.toString() === t.toString();\n    if (n === Array) {\n      if ((o = e.length) === t.length)\n        for (; o-- && N(e[o], t[o]); ) ;\n      return o === -1;\n    }\n    if (!n || typeof e == \"object\") {\n      o = 0;\n      for (n in e)\n        if (M.call(e, n) && ++o && !M.call(t, n) || !(n in t) || !N(e[n], t[n])) return !1;\n      return Object.keys(t).length === o;\n    }\n  }\n  return e !== e && t !== t;\n}\nfunction V() {\n}\nfunction Z(e, t) {\n  return e != e ? t == t : e !== t || e && typeof e == \"object\" || typeof e == \"function\";\n}\nconst z = [];\nfunction P(e, t = V) {\n  let n;\n  const o = /* @__PURE__ */ new Set();\n  function s(v) {\n    if (Z(e, v) && (e = v, n)) {\n      const E = !z.length;\n      for (const h of o)\n        h[1](), z.push(h, e);\n      if (E) {\n        for (let h = 0; h < z.length; h += 2)\n          z[h][0](z[h + 1]);\n        z.length = 0;\n      }\n    }\n  }\n  function g(v) {\n    s(v(e));\n  }\n  function m(v, E = V) {\n    const h = [v, E];\n    return o.add(h), o.size === 1 && (n = t(s, g) || V), v(e), () => {\n      o.delete(h), o.size === 0 && n && (n(), n = null);\n    };\n  }\n  return { set: s, update: g, subscribe: m };\n}\nconst De = (e) => {\n  const { subscribe: t, set: n } = P();\n  let o;\n  return t((s) => o = s), e.observe(({ changes: s }) => {\n    if (o) {\n      (s.deleted || []).some((v) => v.id === o) && n(void 0);\n      const m = (s.updated || []).find(({ oldValue: v }) => v.id === o);\n      m && n(m.newValue.id);\n    }\n  }), {\n    get current() {\n      return o;\n    },\n    subscribe: t,\n    set: n\n  };\n};\nvar F = /* @__PURE__ */ ((e) => (e.EDIT = \"EDIT\", e.SELECT = \"SELECT\", e.NONE = \"NONE\", e))(F || {});\nconst $ = { selected: [] }, Be = (e, t, n) => {\n  const { subscribe: o, set: s } = P($);\n  let g = t, m = $;\n  o((A) => m = A);\n  const v = () => {\n    N(m, $) || s($);\n  }, E = () => {\n    var A;\n    return ((A = m.selected) == null ? void 0 : A.length) === 0;\n  }, h = (A) => {\n    if (E())\n      return !1;\n    const L = typeof A == \"string\" ? A : A.id;\n    return m.selected.some((c) => c.id === L);\n  }, T = (A, L) => {\n    let c;\n    if (Array.isArray(A)) {\n      if (c = A.map((f) => e.getAnnotation(f)).filter(Boolean), c.length < A.length) {\n        console.warn(\"Invalid selection: \" + A.filter((f) => !c.some((b) => b.id === f)));\n        return;\n      }\n    } else {\n      const f = e.getAnnotation(A);\n      if (!f) {\n        console.warn(\"Invalid selection: \" + A);\n        return;\n      }\n      c = [f];\n    }\n    const u = c.reduce((f, b) => {\n      const d = C(b);\n      return d === \"EDIT\" ? [...f, { id: b.id, editable: !0 }] : d === \"SELECT\" ? [...f, { id: b.id }] : f;\n    }, []);\n    s({ selected: u, event: L });\n  }, a = (A, L) => {\n    const c = Array.isArray(A) ? A : [A], u = c.map((f) => e.getAnnotation(f)).filter((f) => !!f);\n    s({\n      selected: u.map((f) => {\n        const b = L === void 0 ? C(f) === \"EDIT\" : L;\n        return { id: f.id, editable: b };\n      })\n    }), u.length !== c.length && console.warn(\"Invalid selection\", A);\n  }, w = (A) => {\n    if (E())\n      return !1;\n    const { selected: L } = m;\n    L.some(({ id: u }) => A.includes(u)) && s({ selected: L.filter(({ id: u }) => !A.includes(u)) });\n  }, D = (A) => {\n    g = A, a(m.selected.map(({ id: L }) => L));\n  }, C = (A) => K(A, g, n);\n  return e.observe(\n    ({ changes: A }) => w((A.deleted || []).map((L) => L.id))\n  ), {\n    get event() {\n      return m ? m.event : null;\n    },\n    get selected() {\n      return m ? [...m.selected] : null;\n    },\n    get userSelectAction() {\n      return g;\n    },\n    clear: v,\n    evalSelectAction: C,\n    isEmpty: E,\n    isSelected: h,\n    setSelected: a,\n    setUserSelectAction: D,\n    subscribe: o,\n    userSelect: T\n  };\n}, K = (e, t, n) => {\n  const o = n ? n.serialize(e) : e;\n  return typeof t == \"function\" ? t(o) : t || \"EDIT\";\n}, R = [];\nfor (let e = 0; e < 256; ++e)\n  R.push((e + 256).toString(16).slice(1));\nfunction ee(e, t = 0) {\n  return (R[e[t + 0]] + R[e[t + 1]] + R[e[t + 2]] + R[e[t + 3]] + \"-\" + R[e[t + 4]] + R[e[t + 5]] + \"-\" + R[e[t + 6]] + R[e[t + 7]] + \"-\" + R[e[t + 8]] + R[e[t + 9]] + \"-\" + R[e[t + 10]] + R[e[t + 11]] + R[e[t + 12]] + R[e[t + 13]] + R[e[t + 14]] + R[e[t + 15]]).toLowerCase();\n}\nlet Y;\nconst te = new Uint8Array(16);\nfunction ne() {\n  if (!Y) {\n    if (typeof crypto > \"u\" || !crypto.getRandomValues)\n      throw new Error(\"crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported\");\n    Y = crypto.getRandomValues.bind(crypto);\n  }\n  return Y(te);\n}\nconst oe = typeof crypto < \"u\" && crypto.randomUUID && crypto.randomUUID.bind(crypto), W = { randomUUID: oe };\nfunction se(e, t, n) {\n  var s;\n  e = e || {};\n  const o = e.random ?? ((s = e.rng) == null ? void 0 : s.call(e)) ?? ne();\n  if (o.length < 16)\n    throw new Error(\"Random bytes length must be >= 16\");\n  return o[6] = o[6] & 15 | 64, o[8] = o[8] & 63 | 128, ee(o);\n}\nfunction q(e, t, n) {\n  return W.randomUUID && !e ? W.randomUUID() : se(e);\n}\nconst Re = (e) => {\n  const { creator: t, updatedBy: n } = e.target, o = e.bodies.reduce((s, g) => [...s, g.creator, g.updatedBy].filter(Boolean), []);\n  return [\n    t,\n    n,\n    ...o\n  ].filter((s) => s);\n}, j = (e) => {\n  const t = (n) => {\n    const o = { ...n };\n    return n.created && typeof n.created == \"string\" && (o.created = new Date(n.created)), n.updated && typeof n.updated == \"string\" && (o.updated = new Date(n.updated)), o;\n  };\n  return {\n    ...e,\n    bodies: (e.bodies || []).map(t),\n    target: t(e.target)\n  };\n}, xe = (e, t, n, o) => ({\n  id: q(),\n  annotation: typeof e == \"string\" ? e : e.id,\n  created: n || /* @__PURE__ */ new Date(),\n  creator: o,\n  ...t\n}), ie = (e, t) => {\n  const n = new Set(e.bodies.map((o) => o.id));\n  return t.bodies.filter((o) => !n.has(o.id));\n}, de = (e, t) => {\n  const n = new Set(t.bodies.map((o) => o.id));\n  return e.bodies.filter((o) => !n.has(o.id));\n}, re = (e, t) => t.bodies.map((n) => {\n  const o = e.bodies.find((s) => s.id === n.id);\n  return { newBody: n, oldBody: o && !N(o, n) ? o : void 0 };\n}).filter(({ oldBody: n }) => n).map(({ oldBody: n, newBody: o }) => ({ oldBody: n, newBody: o })), ce = (e, t) => !N(e.target, t.target), G = (e, t) => {\n  const n = ie(e, t), o = de(e, t), s = re(e, t);\n  return {\n    oldValue: e,\n    newValue: t,\n    bodiesCreated: n.length > 0 ? n : void 0,\n    bodiesDeleted: o.length > 0 ? o : void 0,\n    bodiesUpdated: s.length > 0 ? s : void 0,\n    targetUpdated: ce(e, t) ? { oldTarget: e.target, newTarget: t.target } : void 0\n  };\n};\nvar ae = /* @__PURE__ */ ((e) => (e.BODY_ONLY = \"BODY_ONLY\", e.TARGET_ONLY = \"TARGET_ONLY\", e))(ae || {}), O = /* @__PURE__ */ ((e) => (e.LOCAL = \"LOCAL\", e.REMOTE = \"REMOTE\", e.SILENT = \"SILENT\", e))(O || {});\nconst le = (e, t) => {\n  var g, m;\n  const { changes: n, origin: o } = t;\n  if (!(e.options.origin ? e.options.origin === o : o !== \"SILENT\"))\n    return !1;\n  if (e.options.ignore) {\n    const { ignore: v } = e.options, E = (T) => T && T.length > 0;\n    if (!(E(n.created) || E(n.deleted))) {\n      const T = (g = n.updated) == null ? void 0 : g.some((w) => E(w.bodiesCreated) || E(w.bodiesDeleted) || E(w.bodiesUpdated)), a = (m = n.updated) == null ? void 0 : m.some((w) => w.targetUpdated);\n      if (v === \"BODY_ONLY\" && T && !a || v === \"TARGET_ONLY\" && a && !T)\n        return !1;\n    }\n  }\n  if (e.options.annotations) {\n    const v = /* @__PURE__ */ new Set([\n      ...(n.created || []).map((h) => h.id),\n      ...(n.deleted || []).map((h) => h.id),\n      ...(n.updated || []).map(({ oldValue: h }) => h.id)\n    ]);\n    return !!(Array.isArray(e.options.annotations) ? e.options.annotations : [e.options.annotations]).find((h) => v.has(h));\n  } else\n    return !0;\n}, ue = (e, t) => {\n  const n = new Set((e.created || []).map((a) => a.id)), o = new Set((e.updated || []).map(({ newValue: a }) => a.id)), s = new Set((t.created || []).map((a) => a.id)), g = new Set((t.deleted || []).map((a) => a.id)), m = new Set((t.updated || []).map(({ oldValue: a }) => a.id)), v = new Set((t.updated || []).filter(({ oldValue: a }) => n.has(a.id) || o.has(a.id)).map(({ oldValue: a }) => a.id)), E = [\n    ...(e.created || []).filter((a) => !g.has(a.id)).map((a) => m.has(a.id) ? t.updated.find(({ oldValue: w }) => w.id === a.id).newValue : a),\n    ...t.created || []\n  ], h = [\n    ...(e.deleted || []).filter((a) => !s.has(a.id)),\n    ...(t.deleted || []).filter((a) => !n.has(a.id))\n  ], T = [\n    ...(e.updated || []).filter(({ newValue: a }) => !g.has(a.id)).map((a) => {\n      const { oldValue: w, newValue: D } = a;\n      if (m.has(D.id)) {\n        const C = t.updated.find((A) => A.oldValue.id === D.id).newValue;\n        return G(w, C);\n      } else\n        return a;\n    }),\n    ...(t.updated || []).filter(({ oldValue: a }) => !v.has(a.id))\n  ];\n  return { created: E, deleted: h, updated: T };\n}, _ = (e) => {\n  const t = e.id === void 0 ? q() : e.id;\n  return {\n    ...e,\n    id: t,\n    bodies: e.bodies === void 0 ? [] : e.bodies.map((n) => ({\n      ...n,\n      annotation: t\n    })),\n    target: {\n      ...e.target,\n      annotation: t\n    }\n  };\n}, fe = (e) => e.id !== void 0, ke = () => {\n  const e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Map(), n = [], o = (i, r = {}) => {\n    n.push({ onChange: i, options: r });\n  }, s = (i) => {\n    const r = n.findIndex((l) => l.onChange == i);\n    r > -1 && n.splice(r, 1);\n  }, g = (i, r) => {\n    const l = {\n      origin: i,\n      changes: {\n        created: r.created || [],\n        updated: r.updated || [],\n        deleted: r.deleted || []\n      },\n      state: [...e.values()]\n    };\n    n.forEach((p) => {\n      le(p, l) && p.onChange(l);\n    });\n  }, m = (i, r = O.LOCAL) => {\n    if (i.id && e.get(i.id))\n      throw Error(`Cannot add annotation ${i.id} - exists already`);\n    {\n      const p = _(i);\n      e.set(p.id, p), p.bodies.forEach((U) => t.set(U.id, p.id)), g(r, { created: [p] });\n    }\n  }, v = (i, r) => {\n    const l = _(typeof i == \"string\" ? r : i), p = typeof i == \"string\" ? i : i.id, U = p && e.get(p);\n    if (U) {\n      const y = G(U, l);\n      return p === l.id ? e.set(p, l) : (e.delete(p), e.set(l.id, l)), U.bodies.forEach((B) => t.delete(B.id)), l.bodies.forEach((B) => t.set(B.id, l.id)), y;\n    } else\n      console.warn(`Cannot update annotation ${p} - does not exist`);\n  }, E = (i, r = O.LOCAL, l = O.LOCAL) => {\n    const p = fe(r) ? l : r, U = v(i, r);\n    U && g(p, { updated: [U] });\n  }, h = (i, r = O.LOCAL) => {\n    !!e.get(i.id) ? E(i, r) : m(i, r);\n  }, T = (i, r = O.LOCAL) => {\n    const l = i.reduce((p, U) => {\n      const y = v(U);\n      return y ? [...p, y] : p;\n    }, []);\n    l.length > 0 && g(r, { updated: l });\n  }, a = (i, r = O.LOCAL) => {\n    const l = i.map(_), { toAdd: p, toUpdate: U } = l.reduce((B, I) => e.get(I.id) ? { ...B, toUpdate: [...B.toUpdate, I] } : { ...B, toAdd: [...B.toAdd, I] }, { toAdd: [], toUpdate: [] }), y = U.map((B) => v(B, r)).filter(Boolean);\n    p.forEach((B) => {\n      e.set(B.id, B), B.bodies.forEach((I) => t.set(I.id, B.id));\n    }), g(r, { created: p, updated: y });\n  }, w = (i, r = O.LOCAL) => {\n    const l = e.get(i.annotation);\n    if (l) {\n      const p = {\n        ...l,\n        bodies: [...l.bodies, i]\n      };\n      e.set(l.id, p), t.set(i.id, p.id), g(r, { updated: [{\n        oldValue: l,\n        newValue: p,\n        bodiesCreated: [i]\n      }] });\n    } else\n      console.warn(`Attempt to add body to missing annotation: ${i.annotation}`);\n  }, D = () => [...e.values()], C = (i = O.LOCAL) => {\n    const r = [...e.values()];\n    e.clear(), t.clear(), g(i, { deleted: r });\n  }, A = (i, r = !0, l = O.LOCAL) => {\n    const p = i.map(_);\n    if (r) {\n      const U = [...e.values()];\n      e.clear(), t.clear(), p.forEach((y) => {\n        e.set(y.id, y), y.bodies.forEach((B) => t.set(B.id, y.id));\n      }), g(l, { created: p, deleted: U });\n    } else {\n      const U = i.reduce((y, B) => {\n        const I = B.id && e.get(B.id);\n        return I ? [...y, I] : y;\n      }, []);\n      if (U.length > 0)\n        throw Error(`Bulk insert would overwrite the following annotations: ${U.map((y) => y.id).join(\", \")}`);\n      p.forEach((y) => {\n        e.set(y.id, y), y.bodies.forEach((B) => t.set(B.id, y.id));\n      }), g(l, { created: p });\n    }\n  }, L = (i) => {\n    const r = typeof i == \"string\" ? i : i.id, l = e.get(r);\n    if (l)\n      return e.delete(r), l.bodies.forEach((p) => t.delete(p.id)), l;\n    console.warn(`Attempt to delete missing annotation: ${r}`);\n  }, c = (i, r = O.LOCAL) => {\n    const l = L(i);\n    l && g(r, { deleted: [l] });\n  }, u = (i, r = O.LOCAL) => {\n    const l = i.reduce((p, U) => {\n      const y = L(U);\n      return y ? [...p, y] : p;\n    }, []);\n    l.length > 0 && g(r, { deleted: l });\n  }, f = (i) => {\n    const r = e.get(i.annotation);\n    if (r) {\n      const l = r.bodies.find((p) => p.id === i.id);\n      if (l) {\n        t.delete(l.id);\n        const p = {\n          ...r,\n          bodies: r.bodies.filter((y) => y.id !== i.id)\n        };\n        return e.set(r.id, p), {\n          oldValue: r,\n          newValue: p,\n          bodiesDeleted: [l]\n        };\n      } else\n        console.warn(`Attempt to delete missing body ${i.id} from annotation ${i.annotation}`);\n    } else\n      console.warn(`Attempt to delete body from missing annotation ${i.annotation}`);\n  }, b = (i, r = O.LOCAL) => {\n    const l = f(i);\n    l && g(r, { updated: [l] });\n  }, d = (i, r = O.LOCAL) => {\n    const l = i.map((p) => f(p)).filter(Boolean);\n    l.length > 0 && g(r, { updated: l });\n  }, S = (i) => {\n    const r = e.get(i);\n    return r ? { ...r } : void 0;\n  }, x = (i) => {\n    const r = t.get(i);\n    if (r) {\n      const p = S(r).bodies.find((U) => U.id === i);\n      if (p)\n        return p;\n      console.error(`Store integrity error: body ${i} in index, but not in annotation`);\n    } else\n      console.warn(`Attempt to retrieve missing body: ${i}`);\n  }, k = (i, r) => {\n    if (i.annotation !== r.annotation)\n      throw \"Annotation integrity violation: annotation ID must be the same when updating bodies\";\n    const l = e.get(i.annotation);\n    if (l) {\n      const p = l.bodies.find((y) => y.id === i.id), U = {\n        ...l,\n        bodies: l.bodies.map((y) => y.id === p.id ? r : y)\n      };\n      return e.set(l.id, U), p.id !== r.id && (t.delete(p.id), t.set(r.id, U.id)), {\n        oldValue: l,\n        newValue: U,\n        bodiesUpdated: [{ oldBody: p, newBody: r }]\n      };\n    } else\n      console.warn(`Attempt to add body to missing annotation ${i.annotation}`);\n  }, Q = (i, r, l = O.LOCAL) => {\n    const p = k(i, r);\n    p && g(l, { updated: [p] });\n  }, X = (i, r = O.LOCAL) => {\n    const l = i.map((p) => k({ id: p.id, annotation: p.annotation }, p)).filter(Boolean);\n    g(r, { updated: l });\n  }, H = (i) => {\n    const r = e.get(i.annotation);\n    if (r) {\n      const l = {\n        ...r,\n        target: {\n          ...r.target,\n          ...i\n        }\n      };\n      return e.set(r.id, l), {\n        oldValue: r,\n        newValue: l,\n        targetUpdated: {\n          oldTarget: r.target,\n          newTarget: i\n        }\n      };\n    } else\n      console.warn(`Attempt to update target on missing annotation: ${i.annotation}`);\n  };\n  return {\n    addAnnotation: m,\n    addBody: w,\n    all: D,\n    bulkAddAnnotations: A,\n    bulkDeleteAnnotations: u,\n    bulkDeleteBodies: d,\n    bulkUpdateAnnotations: T,\n    bulkUpdateBodies: X,\n    bulkUpdateTargets: (i, r = O.LOCAL) => {\n      const l = i.map((p) => H(p)).filter(Boolean);\n      l.length > 0 && g(r, { updated: l });\n    },\n    bulkUpsertAnnotations: a,\n    clear: C,\n    deleteAnnotation: c,\n    deleteBody: b,\n    getAnnotation: S,\n    getBody: x,\n    observe: o,\n    unobserve: s,\n    updateAnnotation: E,\n    updateBody: Q,\n    updateTarget: (i, r = O.LOCAL) => {\n      const l = H(i);\n      l && g(r, { updated: [l] });\n    },\n    upsertAnnotation: h\n  };\n}, Ie = (e) => ({\n  ...e,\n  subscribe: (n) => {\n    const o = (s) => n(s.state);\n    return e.observe(o), n(e.all()), () => e.unobserve(o);\n  }\n});\nlet J = () => ({\n  emit(e, ...t) {\n    for (let n = this.events[e] || [], o = 0, s = n.length; o < s; o++)\n      n[o](...t);\n  },\n  events: {},\n  on(e, t) {\n    var n;\n    return ((n = this.events)[e] || (n[e] = [])).push(t), () => {\n      var o;\n      this.events[e] = (o = this.events[e]) == null ? void 0 : o.filter((s) => t !== s);\n    };\n  }\n});\nconst pe = 250, Ne = (e, t) => {\n  const n = J(), o = (t == null ? void 0 : t.changes) || [];\n  let s = t ? t.pointer : -1, g = !1, m = 0;\n  const v = (d) => {\n    if (!g) {\n      const { changes: S } = d, x = performance.now();\n      if (x - m > pe)\n        o.splice(s + 1), o.push(S), s = o.length - 1;\n      else {\n        const k = o.length - 1;\n        o[k] = ue(o[k], S);\n      }\n      m = x;\n    }\n    g = !1;\n  };\n  e.observe(v, { origin: O.LOCAL });\n  const E = (d) => d && d.length > 0 && e.bulkDeleteAnnotations(d), h = (d) => d && d.length > 0 && e.bulkAddAnnotations(d, !1), T = (d) => d && d.length > 0 && e.bulkUpdateAnnotations(d.map(({ oldValue: S }) => S)), a = (d) => d && d.length > 0 && e.bulkUpdateAnnotations(d.map(({ newValue: S }) => S)), w = (d) => d && d.length > 0 && e.bulkAddAnnotations(d, !1), D = (d) => d && d.length > 0 && e.bulkDeleteAnnotations(d);\n  return {\n    canRedo: () => o.length - 1 > s,\n    canUndo: () => s > -1,\n    destroy: () => e.unobserve(v),\n    getHistory: () => ({ changes: [...o], pointer: s }),\n    on: (d, S) => n.on(d, S),\n    redo: () => {\n      if (o.length - 1 > s) {\n        g = !0;\n        const { created: d, updated: S, deleted: x } = o[s + 1];\n        h(d), a(S), D(x), n.emit(\"redo\", o[s + 1]), s += 1;\n      }\n    },\n    undo: () => {\n      if (s > -1) {\n        g = !0;\n        const { created: d, updated: S, deleted: x } = o[s];\n        E(d), T(S), w(x), n.emit(\"undo\", o[s]), s -= 1;\n      }\n    }\n  };\n}, ze = () => {\n  const { subscribe: e, set: t } = P([]);\n  return {\n    subscribe: e,\n    set: t\n  };\n}, _e = (e, t, n, o) => {\n  const { hover: s, selection: g, store: m, viewport: v } = e, E = /* @__PURE__ */ new Map();\n  let h = [], T, a;\n  const w = (c, u) => {\n    E.has(c) ? E.get(c).push(u) : E.set(c, [u]);\n  }, D = (c, u) => {\n    const f = E.get(c);\n    if (f) {\n      const b = f.indexOf(u);\n      b !== -1 && f.splice(b, 1);\n    }\n  }, C = (c, u, f) => {\n    E.has(c) && setTimeout(() => {\n      E.get(c).forEach((b) => {\n        if (n) {\n          const d = Array.isArray(u) ? u.map((x) => n.serialize(x)) : n.serialize(u), S = f ? f instanceof PointerEvent ? f : n.serialize(f) : void 0;\n          b(d, S);\n        } else\n          b(u, f);\n      });\n    }, 1);\n  }, A = () => {\n    const { selected: c } = g, u = (c || []).map(({ id: f }) => m.getAnnotation(f));\n    u.forEach((f) => {\n      const b = h.find((d) => d.id === f.id);\n      (!b || !N(b, f)) && C(\"updateAnnotation\", f, b);\n    }), h = h.map((f) => {\n      const b = u.find(({ id: d }) => d === f.id);\n      return b || f;\n    });\n  };\n  g.subscribe(({ selected: c }) => {\n    if (!(h.length === 0 && c.length === 0)) {\n      if (h.length === 0 && c.length > 0)\n        h = c.map(({ id: u }) => m.getAnnotation(u));\n      else if (h.length > 0 && c.length === 0)\n        h.forEach((u) => {\n          const f = m.getAnnotation(u.id);\n          f && !N(f, u) && C(\"updateAnnotation\", f, u);\n        }), h = [];\n      else {\n        const u = new Set(h.map((d) => d.id)), f = new Set(c.map(({ id: d }) => d));\n        h.filter((d) => !f.has(d.id)).forEach((d) => {\n          const S = m.getAnnotation(d.id);\n          S && !N(S, d) && C(\"updateAnnotation\", S, d);\n        }), h = [\n          // Remove annotations that were deselected\n          ...h.filter((d) => f.has(d.id)),\n          // Add editable annotations that were selected\n          ...c.filter(({ id: d }) => !u.has(d)).map(({ id: d }) => m.getAnnotation(d))\n        ];\n      }\n      C(\"selectionChanged\", h);\n    }\n  }), s.subscribe((c) => {\n    !T && c ? C(\"mouseEnterAnnotation\", m.getAnnotation(c)) : T && !c ? C(\"mouseLeaveAnnotation\", m.getAnnotation(T)) : T && c && (C(\"mouseLeaveAnnotation\", m.getAnnotation(T)), C(\"mouseEnterAnnotation\", m.getAnnotation(c))), T = c;\n  }), v == null || v.subscribe((c) => C(\"viewportIntersect\", c.map((u) => m.getAnnotation(u)))), m.observe((c) => {\n    o && (a && clearTimeout(a), a = setTimeout(A, 1e3));\n    const { created: u, deleted: f } = c.changes;\n    (u || []).forEach((d) => C(\"createAnnotation\", d)), (f || []).forEach((d) => C(\"deleteAnnotation\", d)), (c.changes.updated || []).filter((d) => [\n      ...d.bodiesCreated || [],\n      ...d.bodiesDeleted || [],\n      ...d.bodiesUpdated || []\n    ].length > 0).forEach(({ oldValue: d, newValue: S }) => {\n      const x = h.find((k) => k.id === d.id) || d;\n      h = h.map((k) => k.id === d.id ? S : k), C(\"updateAnnotation\", S, x);\n    });\n  }, { origin: O.LOCAL }), m.observe((c) => {\n    if (h) {\n      const u = new Set(h.map((b) => b.id)), f = (c.changes.updated || []).filter(({ newValue: b }) => u.has(b.id)).map(({ newValue: b }) => b);\n      f.length > 0 && (h = h.map((b) => {\n        const d = f.find((S) => S.id === b.id);\n        return d || b;\n      }));\n    }\n  }, { origin: O.REMOTE });\n  const L = (c) => (u) => {\n    const { updated: f } = u;\n    c ? (f || []).forEach((b) => C(\"updateAnnotation\", b.oldValue, b.newValue)) : (f || []).forEach((b) => C(\"updateAnnotation\", b.newValue, b.oldValue));\n  };\n  return t.on(\"undo\", L(!0)), t.on(\"redo\", L(!1)), { on: w, off: D, emit: C };\n}, $e = (e) => (t) => t.map((n) => e.serialize(n)), ge = (e) => (t) => t.reduce((n, o) => {\n  const { parsed: s, error: g } = e.parse(o);\n  return g ? {\n    parsed: n.parsed,\n    failed: [...n.failed, o]\n  } : s ? {\n    parsed: [...n.parsed, s],\n    failed: n.failed\n  } : {\n    ...n\n  };\n}, { parsed: [], failed: [] }), Ve = (e, t, n) => {\n  const { store: o, selection: s } = e, g = (c) => {\n    if (n) {\n      const { parsed: u, error: f } = n.parse(c);\n      u ? o.addAnnotation(u, O.REMOTE) : console.error(f);\n    } else\n      o.addAnnotation(j(c), O.REMOTE);\n  }, m = () => s.clear(), v = () => o.clear(), E = (c) => {\n    const u = o.getAnnotation(c);\n    return n && u ? n.serialize(u) : u;\n  }, h = () => n ? o.all().map(n.serialize) : o.all(), T = () => {\n    var f;\n    const u = (((f = s.selected) == null ? void 0 : f.map((b) => b.id)) || []).map((b) => o.getAnnotation(b)).filter(Boolean);\n    return n ? u.map(n.serialize) : u;\n  }, a = (c, u = !0) => fetch(c).then((f) => f.json()).then((f) => (D(f, u), f)), w = (c) => {\n    if (typeof c == \"string\") {\n      const u = o.getAnnotation(c);\n      if (o.deleteAnnotation(c), u)\n        return n ? n.serialize(u) : u;\n    } else {\n      const u = n ? n.parse(c).parsed : c;\n      if (u)\n        return o.deleteAnnotation(u), c;\n    }\n  }, D = (c, u = !0) => {\n    if (n) {\n      const f = n.parseAll || ge(n), { parsed: b, failed: d } = f(c);\n      d.length > 0 && console.warn(`Discarded ${d.length} invalid annotations`, d), o.bulkAddAnnotations(b, u, O.REMOTE);\n    } else\n      o.bulkAddAnnotations(c.map(j), u, O.REMOTE);\n  }, C = (c, u) => {\n    c ? s.setSelected(c, u) : s.clear();\n  }, A = (c) => {\n    s.setUserSelectAction(c);\n  }, L = (c) => {\n    if (n) {\n      const u = n.parse(c).parsed, f = n.serialize(o.getAnnotation(u.id));\n      return o.updateAnnotation(u), f;\n    } else {\n      const u = o.getAnnotation(c.id);\n      return o.updateAnnotation(j(c)), u;\n    }\n  };\n  return {\n    addAnnotation: g,\n    cancelSelected: m,\n    canRedo: t.canRedo,\n    canUndo: t.canUndo,\n    clearAnnotations: v,\n    getAnnotationById: E,\n    getAnnotations: h,\n    getHistory: t.getHistory,\n    getSelected: T,\n    loadAnnotations: a,\n    redo: t.redo,\n    removeAnnotation: w,\n    setAnnotations: D,\n    setSelected: C,\n    setUserSelectAction: A,\n    undo: t.undo,\n    updateAnnotation: L\n  };\n}, Ye = (e, t, n) => typeof t == \"function\" ? t(e, n) : t, je = (e, t) => typeof e != \"function\" && typeof t != \"function\" ? {\n  ...e || {},\n  ...t || {}\n} : (n, o) => {\n  const s = typeof e == \"function\" ? e(n, o) : e, g = typeof t == \"function\" ? t(n, o) : t;\n  return {\n    ...s || {},\n    ...g || {}\n  };\n}, he = \"useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict\";\nlet me = (e) => crypto.getRandomValues(new Uint8Array(e)), Ae = (e, t, n) => {\n  let o = (2 << Math.log2(e.length - 1)) - 1, s = -~(1.6 * o * t / e.length);\n  return (g = t) => {\n    let m = \"\";\n    for (; ; ) {\n      let v = n(s), E = s | 0;\n      for (; E--; )\n        if (m += e[v[E] & o] || \"\", m.length >= g) return m;\n    }\n  };\n}, be = (e, t = 21) => Ae(e, t | 0, me), ve = (e = 21) => {\n  let t = \"\", n = crypto.getRandomValues(new Uint8Array(e |= 0));\n  for (; e--; )\n    t += he[n[e] & 63];\n  return t;\n};\nconst Pe = () => ({ isGuest: !0, id: be(\"1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_\", 20)() }), Ee = (e) => {\n  const t = JSON.stringify(e);\n  let n = 0;\n  for (let o = 0, s = t.length; o < s; o++) {\n    let g = t.charCodeAt(o);\n    n = (n << 5) - n + g, n |= 0;\n  }\n  return `${n}`;\n}, we = (e) => e ? typeof e == \"object\" ? { ...e } : e : void 0, He = (e, t) => (Array.isArray(e) ? e : [e]).map((n) => {\n  const { id: o, type: s, purpose: g, value: m, created: v, modified: E, creator: h, ...T } = n;\n  return {\n    id: o || `temp-${Ee(n)}`,\n    annotation: t,\n    type: s,\n    purpose: g,\n    value: m,\n    creator: we(h),\n    created: v ? new Date(v) : void 0,\n    updated: E ? new Date(E) : void 0,\n    ...T\n  };\n}), Me = (e) => e.map((t) => {\n  var v;\n  const { annotation: n, created: o, updated: s, ...g } = t, m = {\n    ...g,\n    created: o == null ? void 0 : o.toISOString(),\n    modified: s == null ? void 0 : s.toISOString()\n  };\n  return (v = m.id) != null && v.startsWith(\"temp-\") && delete m.id, m;\n}), We = (e) => \"@context\" in e && \"creator\" in e && \"body\" in e, Ce = [\n  \"#ff7c00\",\n  // orange\n  \"#1ac938\",\n  // green\n  \"#e8000b\",\n  // red\n  \"#8b2be2\",\n  // purple\n  \"#9f4800\",\n  // brown\n  \"#f14cc1\",\n  // pink\n  \"#ffc400\",\n  // khaki\n  \"#00d7ff\",\n  // cyan\n  \"#023eff\"\n  // blue\n], ye = () => {\n  const e = [...Ce];\n  return { assignRandomColor: () => {\n    const o = Math.floor(Math.random() * e.length), s = e[o];\n    return e.splice(o, 1), s;\n  }, releaseColor: (o) => e.push(o) };\n}, Le = () => {\n  const e = ye();\n  return { addUser: (o, s) => {\n    const g = e.assignRandomColor();\n    return {\n      label: s.name || s.id,\n      avatar: s.avatar,\n      color: g\n    };\n  }, removeUser: (o) => e.releaseColor(o.appearance.color) };\n}, Ue = (e, t) => e.every((n) => e.includes(n)) && t.every((n) => e.includes(n)), qe = ve(), Ge = (e = Le()) => {\n  const t = J(), n = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map(), s = (a, w) => {\n    if (n.has(a)) {\n      console.warn(\"Attempt to add user that is already present\", a, w);\n      return;\n    }\n    const D = e.addUser(a, w);\n    n.set(a, {\n      ...w,\n      presenceKey: a,\n      appearance: D\n    });\n  }, g = (a) => {\n    const w = n.get(a);\n    if (!w) {\n      console.warn(\"Attempt to remove user that is not present\", a);\n      return;\n    }\n    e.removeUser(w), n.delete(a);\n  }, m = (a) => {\n    const w = new Set(a.map((A) => A.presenceKey)), D = a.filter(({ presenceKey: A }) => !n.has(A)), C = Array.from(n.values()).filter((A) => !w.has(A.presenceKey));\n    D.forEach(({ presenceKey: A, user: L }) => s(A, L)), C.forEach((A) => {\n      const { presenceKey: L } = A;\n      o.has(L) && t.emit(\"selectionChange\", A, null), g(L);\n    }), (D.length > 0 || C.length > 0) && t.emit(\"presence\", h());\n  }, v = (a, w) => {\n    const D = n.get(a);\n    if (!D) {\n      console.warn(\"Activity notification from user that is not present\");\n      return;\n    }\n    const C = o.get(a);\n    (!C || !Ue(C, w)) && (o.set(a, w), t.emit(\"selectionChange\", D, w));\n  }, E = (a, w) => {\n    const D = n.get(a);\n    if (!D) {\n      console.warn(\"Selection change for user that is not present\", a);\n      return;\n    }\n    w ? o.set(a, w) : o.delete(a), t.emit(\"selectionChange\", D, w);\n  }, h = () => [...Array.from(n.values())];\n  return {\n    getPresentUsers: h,\n    notifyActivity: v,\n    on: (a, w) => t.on(a, w),\n    syncUsers: m,\n    updateSelection: E\n  };\n};\nexport {\n  ae as Ignore,\n  O as Origin,\n  qe as PRESENCE_KEY,\n  F as UserSelectAction,\n  je as chainStyles,\n  Ye as computeStyle,\n  Pe as createAnonymousGuest,\n  Ve as createBaseAnnotator,\n  xe as createBody,\n  Le as createDefaultAppearanceProvider,\n  De as createHoverState,\n  _e as createLifecycleObserver,\n  Ge as createPresenceState,\n  Be as createSelectionState,\n  ke as createStore,\n  Ne as createUndoStack,\n  ze as createViewportState,\n  ye as defaultColorProvider,\n  G as diffAnnotations,\n  Re as getContributors,\n  We as isW3CAnnotation,\n  ue as mergeChanges,\n  K as onUserSelect,\n  ge as parseAll,\n  He as parseW3CBodies,\n  we as parseW3CUser,\n  j as reviveDates,\n  $e as serializeAll,\n  Me as serializeW3CBodies,\n  le as shouldNotify,\n  Ie as toSvelteStore\n};\n//# sourceMappingURL=annotorious-core.es.js.map\n","import { v4 as uuidv4 } from 'uuid';\nimport { parseW3CUser, parseW3CBodies, serializeW3CBodies } from '@annotorious/core';\nimport type { FormatAdapter, ParseResult, W3CAnnotation } from '@annotorious/core';\nimport { ShapeType } from '../core';\nimport type { ImageAnnotation, RectangleGeometry } from '../core';\nimport type {FragmentSelector } from './fragment';\nimport { parseFragmentSelector, serializeFragmentSelector } from './fragment';\nimport type { SVGSelector } from './svg';\nimport { parseSVGSelector, serializeSVGSelector } from './svg';\nimport type { W3CImageAnnotation } from './W3CImageAnnotation';\n\nexport type W3CImageFormatAdapter = FormatAdapter<ImageAnnotation, W3CImageAnnotation>;\n\nexport interface W3CImageFormatAdapterOpts {\n\n  strict: boolean;\n\n  invertY: boolean;\n\n}\n\nexport const W3CImageFormat = (\n  source: string,\n  opts: W3CImageFormatAdapterOpts = { strict: true, invertY: false }\n): W3CImageFormatAdapter => {\n\n  const parse = (serialized: W3CAnnotation) =>\n    parseW3CImageAnnotation(serialized, opts);\n\n  const serialize = (annotation: ImageAnnotation) =>\n    serializeW3CImageAnnotation(annotation, source, opts);\n\n  return { parse, serialize }\n}\n\nexport const parseW3CImageAnnotation = (\n  annotation: W3CAnnotation, \n  opts: W3CImageFormatAdapterOpts = { strict: true, invertY: false }\n): ParseResult<ImageAnnotation> => {\n  const annotationId = annotation.id || uuidv4();\n\n  const { \n    creator,\n    created,\n    modified,\n    body, \n    ...rest \n  } = annotation;\n\n  const bodies = parseW3CBodies(body || [], annotationId);\n\n  const w3cTarget = Array.isArray(annotation.target) \n    ? annotation.target[0] : annotation.target;\n\n  const w3cSelector = \n    typeof w3cTarget === 'string' ? w3cTarget :\n      Array.isArray(w3cTarget.selector) \n        ? w3cTarget.selector[0] : w3cTarget.selector;\n\n  const selector = \n    typeof w3cSelector === 'string' || w3cSelector?.type === 'FragmentSelector' ?\n      parseFragmentSelector(w3cSelector as FragmentSelector, opts.invertY) :\n    w3cSelector?.type === 'SvgSelector' ?\n      parseSVGSelector(w3cSelector as SVGSelector) : undefined;\n\n  const target = \n    Array.isArray(rest.target) ? rest.target[0] : rest.targret;\n\n  return (selector || !opts.strict) ? { \n    parsed: {\n      ...rest,\n      id: annotationId,\n      bodies,\n      target: {\n        created: created ? new Date(created) : undefined,\n        creator: parseW3CUser(creator),\n        updated: modified ? new Date(modified) : undefined,\n        // Note the target can be a string and we don't want to spread the characters...\n        ...(typeof target === 'string' ? {} : target),\n        annotation: annotationId,\n        selector: selector || w3cSelector\n      }\n    }\n  } : {\n    error: Error(`Invalid selector: ${JSON.stringify(w3cSelector)}`)\n  };\n}\n\nexport const serializeW3CImageAnnotation = (\n  annotation: ImageAnnotation, \n  source: string,\n  opts: W3CImageFormatAdapterOpts = { strict: true, invertY: false }\n): W3CImageAnnotation => {\n  const { \n    selector, \n    creator, \n    created, \n    updated,\n    updatedBy, // Excluded from serialization\n    ...rest \n  } = annotation.target;\n\n  let w3cSelector: FragmentSelector | SVGSelector | unknown;\n\n  try {\n    w3cSelector = selector.type == ShapeType.RECTANGLE ?\n      serializeFragmentSelector(selector.geometry as RectangleGeometry) :\n      serializeSVGSelector(selector);\n  } catch (error) {\n    if (opts.strict)\n      throw error;\n    else \n     w3cSelector = selector;\n  }\n\n  const serialized = {\n    ...annotation,\n    '@context': 'http://www.w3.org/ns/anno.jsonld',\n    id: annotation.id,\n    type: 'Annotation',\n    body: serializeW3CBodies(annotation.bodies),\n    created: created?.toISOString(),\n    creator,\n    modified: updated?.toISOString(),\n    target: {\n      ...rest,\n      source,\n      type: 'SpecificResource',\n      selector: w3cSelector\n    }\n  } as W3CImageAnnotation;\n\n  // Remove core properties that should not appear in the W3C annotation\n  delete serialized.bodies;\n  \n  if ('annotation' in serialized.target)\n    delete serialized.target.annotation;\n\n  return serialized;\n}\n","import {\n\trun_all,\n\tsubscribe,\n\tnoop,\n\tsafe_not_equal,\n\tis_function,\n\tget_store_value\n} from '../internal/index.js';\n\nconst subscriber_queue = [];\n\n/**\n * Creates a `Readable` store that allows reading by subscription.\n *\n * https://svelte.dev/docs/svelte-store#readable\n * @template T\n * @param {T} [value] initial value\n * @param {import('./public.js').StartStopNotifier<T>} [start]\n * @returns {import('./public.js').Readable<T>}\n */\nexport function readable(value, start) {\n\treturn {\n\t\tsubscribe: writable(value, start).subscribe\n\t};\n}\n\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n *\n * https://svelte.dev/docs/svelte-store#writable\n * @template T\n * @param {T} [value] initial value\n * @param {import('./public.js').StartStopNotifier<T>} [start]\n * @returns {import('./public.js').Writable<T>}\n */\nexport function writable(value, start = noop) {\n\t/** @type {import('./public.js').Unsubscriber} */\n\tlet stop;\n\t/** @type {Set<import('./private.js').SubscribeInvalidateTuple<T>>} */\n\tconst subscribers = new Set();\n\t/** @param {T} new_value\n\t * @returns {void}\n\t */\n\tfunction set(new_value) {\n\t\tif (safe_not_equal(value, new_value)) {\n\t\t\tvalue = new_value;\n\t\t\tif (stop) {\n\t\t\t\t// store is ready\n\t\t\t\tconst run_queue = !subscriber_queue.length;\n\t\t\t\tfor (const subscriber of subscribers) {\n\t\t\t\t\tsubscriber[1]();\n\t\t\t\t\tsubscriber_queue.push(subscriber, value);\n\t\t\t\t}\n\t\t\t\tif (run_queue) {\n\t\t\t\t\tfor (let i = 0; i < subscriber_queue.length; i += 2) {\n\t\t\t\t\t\tsubscriber_queue[i][0](subscriber_queue[i + 1]);\n\t\t\t\t\t}\n\t\t\t\t\tsubscriber_queue.length = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {import('./public.js').Updater<T>} fn\n\t * @returns {void}\n\t */\n\tfunction update(fn) {\n\t\tset(fn(value));\n\t}\n\n\t/**\n\t * @param {import('./public.js').Subscriber<T>} run\n\t * @param {import('./private.js').Invalidator<T>} [invalidate]\n\t * @returns {import('./public.js').Unsubscriber}\n\t */\n\tfunction subscribe(run, invalidate = noop) {\n\t\t/** @type {import('./private.js').SubscribeInvalidateTuple<T>} */\n\t\tconst subscriber = [run, invalidate];\n\t\tsubscribers.add(subscriber);\n\t\tif (subscribers.size === 1) {\n\t\t\tstop = start(set, update) || noop;\n\t\t}\n\t\trun(value);\n\t\treturn () => {\n\t\t\tsubscribers.delete(subscriber);\n\t\t\tif (subscribers.size === 0 && stop) {\n\t\t\t\tstop();\n\t\t\t\tstop = null;\n\t\t\t}\n\t\t};\n\t}\n\treturn { set, update, subscribe };\n}\n\n/**\n * Derived value store by synchronizing one or more readable stores and\n * applying an aggregation function over its input values.\n *\n * https://svelte.dev/docs/svelte-store#derived\n * @template {import('./private.js').Stores} S\n * @template T\n * @overload\n * @param {S} stores - input stores\n * @param {(values: import('./private.js').StoresValues<S>, set: (value: T) => void, update: (fn: import('./public.js').Updater<T>) => void) => import('./public.js').Unsubscriber | void} fn - function callback that aggregates the values\n * @param {T} [initial_value] - initial value\n * @returns {import('./public.js').Readable<T>}\n */\n\n/**\n * Derived value store by synchronizing one or more readable stores and\n * applying an aggregation function over its input values.\n *\n * https://svelte.dev/docs/svelte-store#derived\n * @template {import('./private.js').Stores} S\n * @template T\n * @overload\n * @param {S} stores - input stores\n * @param {(values: import('./private.js').StoresValues<S>) => T} fn - function callback that aggregates the values\n * @param {T} [initial_value] - initial value\n * @returns {import('./public.js').Readable<T>}\n */\n\n/**\n * @template {import('./private.js').Stores} S\n * @template T\n * @param {S} stores\n * @param {Function} fn\n * @param {T} [initial_value]\n * @returns {import('./public.js').Readable<T>}\n */\nexport function derived(stores, fn, initial_value) {\n\tconst single = !Array.isArray(stores);\n\t/** @type {Array<import('./public.js').Readable<any>>} */\n\tconst stores_array = single ? [stores] : stores;\n\tif (!stores_array.every(Boolean)) {\n\t\tthrow new Error('derived() expects stores as input, got a falsy value');\n\t}\n\tconst auto = fn.length < 2;\n\treturn readable(initial_value, (set, update) => {\n\t\tlet started = false;\n\t\tconst values = [];\n\t\tlet pending = 0;\n\t\tlet cleanup = noop;\n\t\tconst sync = () => {\n\t\t\tif (pending) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcleanup();\n\t\t\tconst result = fn(single ? values[0] : values, set, update);\n\t\t\tif (auto) {\n\t\t\t\tset(result);\n\t\t\t} else {\n\t\t\t\tcleanup = is_function(result) ? result : noop;\n\t\t\t}\n\t\t};\n\t\tconst unsubscribers = stores_array.map((store, i) =>\n\t\t\tsubscribe(\n\t\t\t\tstore,\n\t\t\t\t(value) => {\n\t\t\t\t\tvalues[i] = value;\n\t\t\t\t\tpending &= ~(1 << i);\n\t\t\t\t\tif (started) {\n\t\t\t\t\t\tsync();\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t() => {\n\t\t\t\t\tpending |= 1 << i;\n\t\t\t\t}\n\t\t\t)\n\t\t);\n\t\tstarted = true;\n\t\tsync();\n\t\treturn function stop() {\n\t\t\trun_all(unsubscribers);\n\t\t\tcleanup();\n\t\t\t// We need to set this to false because callbacks can still happen despite having unsubscribed:\n\t\t\t// Callbacks might already be placed in the queue which doesn't know it should no longer\n\t\t\t// invoke this derived store.\n\t\t\tstarted = false;\n\t\t};\n\t});\n}\n\n/**\n * Takes a store and returns a new one derived from the old one that is readable.\n *\n * https://svelte.dev/docs/svelte-store#readonly\n * @template T\n * @param {import('./public.js').Readable<T>} store  - store to make readonly\n * @returns {import('./public.js').Readable<T>}\n */\nexport function readonly(store) {\n\treturn {\n\t\tsubscribe: store.subscribe.bind(store)\n\t};\n}\n\nexport { get_store_value as get };\n","import { writable } from 'svelte/store';\n\nconst setSize = (image: HTMLImageElement | HTMLCanvasElement, svg: SVGElement) => {\n  const { naturalWidth, naturalHeight } = (image as HTMLImageElement);\n\n  if (!naturalWidth && !naturalHeight) {\n    // Might be because a) the image has not loaded yet, or b) because it's not \n    // an image element (but maybe a CANVAS etc.)! Allow for both possibilities.\n    const { width, height } = image;\n\n    svg.setAttribute('viewBox', `0 0 ${width} ${height}`);\n\n    image.addEventListener('load', event => {\n      const img = event.target as HTMLImageElement;\n      svg.setAttribute('viewBox', `0 0 ${img.naturalWidth} ${img.naturalHeight}`);\n    });\n  } else {\n    svg.setAttribute('viewBox', `0 0 ${naturalWidth} ${naturalHeight}`);\n  }\n\n}\n\nexport const enableResponsive = (image: HTMLImageElement | HTMLCanvasElement, svg: SVGSVGElement) => {\n\n  setSize(image, svg);\n\n  const { subscribe, set } = writable(1);\n\n  let resizeObserver: ResizeObserver;\n\n  if (window.ResizeObserver) {\n    resizeObserver = new ResizeObserver(() => {\n      const svgBounds = svg.getBoundingClientRect();\n\n      const { width, height } = svg.viewBox.baseVal;\n  \n      const scale = Math.max(\n        svgBounds.width / width,\n        svgBounds.height / height\n      );\n  \n      set(scale);\n    });\n  \n    resizeObserver.observe(svg.parentElement!);\n  }\n\n  const destroy = () => {\n    if (resizeObserver)\n      resizeObserver.disconnect();\n  }\n\n  return { destroy, subscribe };\n\n}\n\n","import type { DrawingStyleExpression } from '@annotorious/core';\nimport type { ImageAnnotation } from '../../model';\n\nexport const computeStyle = (\n  annotation: ImageAnnotation,\n  style?: DrawingStyleExpression<ImageAnnotation>\n) => {\n  const computed = typeof style === 'function' ? style(annotation) : style;\n\n  if (computed) {\n    const { fill, fillOpacity, stroke, strokeWidth, strokeOpacity } = computed;\n\n    let css = '';\n\n    if (fill)\n      css += `fill:${fill};`;\n\n    if (fillOpacity || fillOpacity === 0) {\n      css += `fill-opacity:${fillOpacity};`;\n    } else if (fill) {\n      // If we have no fill opacity, but a fill, set default opacity\n      css += 'fill-opacity:0.25;';\n    }\n\n    if (stroke) {\n      css += `stroke:${stroke};`;\n      css += `stroke-width:${strokeWidth || '1'};`;\n      css += `stroke-opacity:${strokeOpacity || '1'};`;\n    }\n\n    return css;\n  }\n};\n","import type { Bounds } from '../../model';\n\nexport const getMaskDimensions = (bounds: Bounds, buffer: number = 0) => {\n  const { minX, minY, maxX, maxY } = bounds;\n  return {\n    x: minX - buffer,\n    y: minY - buffer,\n    w: maxX - minX + 2 * buffer,\n    h: maxY - minY + 2 * buffer\n  }\n}","export const isTouch = (() => {\n  if (typeof window === 'undefined' || typeof navigator === 'undefined')\n    return false;\n  \n  return 'ontouchstart' in window || \n         navigator.maxTouchPoints > 0 || \n         // @ts-ignore\n         navigator.msMaxTouchPoints > 0;\n})();\n","<script lang=\"ts\">\n  import { createEventDispatcher } from 'svelte';\n  import type { Shape } from '../../model';\n  import type { Transform } from '../Transform';\n\n  const dispatch = createEventDispatcher<{ grab: PointerEvent, release: PointerEvent, change: Shape }>();\n\n  /** Props */\n  export let shape: Shape;\n  export let editor: (shape: Shape, handle: string, delta: [number, number]) => Shape;\n  export let transform: Transform;\n  export let svgEl: SVGSVGElement;\n\n  let grabbedHandle: string | undefined;\n\n  let origin: [number, number];\n\n  let initialShape: Shape | undefined;\n\n  const onGrab = (handle: string) => (evt: PointerEvent) => {\n    grabbedHandle = handle;\n\n    // For legacy compatibility: offsetX and offsetY are not\n    // available on synthetic events, currently used by the\n    // new PolygonEditor. Old versions of Annotorious, however, \n    // won't yet forward the svgEl prop!\n    if (svgEl) {\n      const { left, top } = svgEl.getBoundingClientRect();\n      const offsetX = evt.clientX - left;\n      const offsetY = evt.clientY - top;\n\n      origin = transform.elementToImage(offsetX, offsetY);\n    } else {\n      const { offsetX, offsetY } = evt;\n      origin = transform.elementToImage(offsetX, offsetY);\n    }\n\n    initialShape = shape;\n\n    const target = evt.target as Element;\n    target.setPointerCapture(evt.pointerId);\n\n    dispatch('grab', evt);\n  }\n\n  const onPointerMove = (evt: PointerEvent) => {\n    if (grabbedHandle) {\n      const [x, y] = transform.elementToImage(evt.offsetX, evt.offsetY);\n\n      const delta: [number, number] = [x - origin[0], y - origin[1]];\n\n      shape = editor(initialShape!, grabbedHandle, delta);\n      \n      dispatch('change', shape);\n    }\n  }\n\n  const onRelease = (evt: PointerEvent) => {    \n    const target = evt.target as Element;\n    target.releasePointerCapture(evt.pointerId);\n\n    grabbedHandle = undefined;\n\n    initialShape = shape;\n    \n    dispatch('release', evt);\n  }\n</script>\n\n<g\n  class=\"a9s-annotation selected\"\n  on:pointerup={onRelease}\n  on:pointermove={onPointerMove}>\n\n  <slot grab={onGrab} />\n</g>","<script lang=\"ts\">\n  import { isTouch } from '../utils';\n\n  /** props **/\n  export let x: number;\n  export let y: number;\n  export let scale: number;\n  export let selected: Boolean | undefined = undefined;\n\n  let touched = false;\n\n  const onPointerDown = (evt: PointerEvent) => {\n    if (evt.pointerType === 'touch')\n      touched = true;\n  }\n\n  const onPointerUp = () =>\n    touched = false;\n\n  $: handleRadius = 4 / scale;\n</script>\n\n{#if isTouch}\n  <g class=\"a9s-touch-handle\">\n    <circle \n      cx={x} \n      cy={y} \n      r={handleRadius * 10}\n      class=\"a9s-touch-halo\"\n      class:touched={touched} />\n   \n    <circle \n      cx={x}\n      cy={y} \n      r={handleRadius + 10 / scale}\n      class=\"a9s-handle-buffer\"\n      role=\"button\"\n      tabindex=\"0\"\n      on:dblclick\n      on:pointerdown\n      on:pointerdown={onPointerDown} \n      on:pointerup\n      on:pointerup={onPointerUp} /> \n\n    <circle \n      class=\"a9s-handle-dot\"\n      cx={x}\n      cy={y}\n      r={handleRadius + 2 / scale} />\n  </g>\n{:else}\n  <g class={`a9s-handle ${$$props.class || ''}`.trim()}>\n    <circle \n      class=\"a9s-handle-buffer\"\n      cx={x}\n      cy={y}\n      r={handleRadius + (6 / scale)} \n      role=\"button\"\n      tabindex=\"0\"\n      on:dblclick\n      on:pointerenter\n      on:pointerleave\n      on:pointerdown\n      on:pointerdown={onPointerDown}\n      on:pointerup\n      on:pointerup={onPointerUp} />\n\n    {#if selected}\n      <circle \n        class=\"a9s-handle-selected\"\n        cx={x} \n        cy={y} \n        r={handleRadius + (8 / scale)} />\n    {/if}\n\n    <circle \n      class={`a9s-handle-dot${selected ? ' selected': ''}`}\n      cx={x}\n      cy={y}\n      r={handleRadius} />\n  </g>\n{/if}\n\n<style>\n  circle.a9s-handle-buffer:focus {\n    outline: none;\n  }\n\n  circle.a9s-handle-buffer:focus-visible {\n    stroke: rgba(255, 255, 255, 0.8);\n    stroke-width: 3px;\n  }\n</style>","<script lang=\"ts\">\n  import { isTouch } from '../utils';\n\n  /** props **/\n  export let x: number;\n  export let y: number;\n  export let scale: number;\n\n  let touched = false;\n\n  const onPointerDown = (evt: PointerEvent) => {\n    if (evt.pointerType === 'touch')\n      touched = true;\n  }\n\n  const onPointerUp = () =>\n    touched = false;\n\n  $: handleRadius = 4 / scale;\n</script>\n\n{#if isTouch}\n  <circle \n    cx={x}\n    cy={y}\n    r={handleRadius} />\n{:else}\n  <g class=\"a9s-polygon-midpoint\">\n    <circle \n      class=\"a9s-polygon-midpoint-buffer\"\n      cx={x}\n      cy={y}\n      r={1.75 * handleRadius} \n      on:pointerdown\n      on:pointerdown={onPointerDown} />\n\n    <circle \n      class=\"a9s-polygon-midpoint-outer\"\n      cx={x} \n      cy={y} \n      r={handleRadius} />\n\n    <circle \n      class=\"a9s-polygon-midpoint-inner\"\n      cx={x} \n      cy={y} \n      r={handleRadius} />\n  </g>\n{/if}\n\n<style>\n  .a9s-polygon-midpoint {\n    cursor: crosshair;\n  }\n  \n  .a9s-polygon-midpoint-buffer {\n    fill: transparent;\n  }\n\n  .a9s-polygon-midpoint-outer {\n    display: none;\n    fill: transparent;\n    pointer-events: none;\n    stroke: rgba(0, 0, 0, 0.35);\n    stroke-width: 1.5px;\n    vector-effect: non-scaling-stroke;\n  }\n\n  .a9s-polygon-midpoint-inner {\n    fill: rgba(0, 0, 0, 0.25);\n    pointer-events: none;\n    stroke: #fff;\n    stroke-width: 1px;  \n    vector-effect: non-scaling-stroke;\n  }\n</style>","<script lang=\"ts\">\n  import { createEventDispatcher, onMount, tick } from 'svelte';\n  import { boundsFromPoints } from '../../../model';\n  import type { Polygon, PolygonGeometry, Shape } from '../../../model';\n  import { getMaskDimensions, isTouch } from '../../utils';\n  import type { Transform } from '../../Transform';\n  import Editor from '../Editor.svelte';\n  import Handle from '../Handle.svelte';\n  import MidpointHandle from '../MidpointHandle.svelte';\n\n  const dispatch = createEventDispatcher<{ change: Polygon }>();\n\n  /** Time difference (milliseconds) required for registering a click/tap **/\n  const CLICK_THRESHOLD = 250;\n\n  /** Minimum distance (px) to shape required for midpoints to show */\n  const MIN_HOVER_DISTANCE = 1000;\n\n  /** Minimum distance (px) between corners required for midpoints to show **/\n  const MIN_CORNER_DISTANCE = 12;\n\n  /** Needed for the <mask> element **/\n  const MIDPOINT_SIZE = 4.5;\n\n  /** Props */\n  export let shape: Polygon;\n  export let computedStyle: string | undefined;\n  export let transform: Transform;\n  export let viewportScale: number = 1;\n  export let svgEl: SVGSVGElement;\n\n  /** Drawing tool layer **/\n  let visibleMidpoint: number | undefined;\n  let isHandleHovered = false;\n  let lastHandleClick: number | undefined;\n  let selectedCorners: number[] = [];\n\n  $: geom = shape.geometry;\n\n  // No support yet for adding or removing points in mobile!\n  $: midpoints = isTouch ? [] : geom.points.map((thisCorner, idx) => {\n    const nextCorner = idx === geom.points.length - 1 ? geom.points[0] : geom.points[idx + 1];\n    \n    const x = (thisCorner[0] + nextCorner[0]) / 2;\n    const y = (thisCorner[1] + nextCorner[1]) / 2;\n\n    const dist = Math.sqrt( \n      Math.pow(nextCorner[0] - x, 2) + Math.pow(nextCorner[1] - y, 2));\n\n    // Don't show if the distance between the corners is too small\n    const visible = dist > MIN_CORNER_DISTANCE / viewportScale;\n\n    return { point: [x, y], visible };\n  });\n\n  /** Handle hover state **/\n  const onEnterHandle = () => isHandleHovered = true;\n  const onLeaveHandle = () => isHandleHovered = false;\n\n  /** Determine visible midpoint, if any **/\n  const onPointerMove = (evt: PointerEvent) => {\n    if (selectedCorners.length > 0 || !midpoints.some(m => m.visible)) {\n      visibleMidpoint = undefined;\n      return;\n    }\n    \n    const [px, py] = transform.elementToImage(evt.offsetX, evt.offsetY);\n\n    const getDistSq = (pt: number[]) =>\n      Math.pow(pt[0] - px, 2) + Math.pow(pt[1] - py, 2);\n\n    const closestCorner = geom.points.reduce((closest, corner) =>\n      getDistSq(corner) < getDistSq(closest) ? corner : closest);\n\n    const closestVisibleMidpoint = midpoints\n      .filter(m => m.visible)\n      .reduce((closest, midpoint) =>\n        getDistSq(midpoint.point) < getDistSq(closest.point) ? midpoint : closest);\n\n    // Show midpoint if the mouse is at least within THRESHOLD distance\n    // of the midpoint or the closest corner. (Basically a poor man's shape buffering).\n    const threshold = Math.pow(MIN_HOVER_DISTANCE / viewportScale, 2);\n\n    const shouldShow = \n      getDistSq(closestCorner) < threshold ||\n      getDistSq(closestVisibleMidpoint.point) < threshold;\n\n    if (shouldShow)\n      visibleMidpoint = midpoints.indexOf(closestVisibleMidpoint);\n    else\n      visibleMidpoint = undefined;\n  }\n\n  /** \n   * SVG element keeps loosing focus when interacting with \n   * shapesthis function refocuses.\n   */\n  const reclaimFocus = () => {\n    if (document.activeElement !== svgEl)\n      svgEl.focus();\n  }\n\n  /**\n   * De-selects all corners and reclaims focus.\n   */\n  const onShapePointerUp = () => {\n    selectedCorners = [];\n    reclaimFocus();\n  }\n\n  /**\n   * Updates state, waiting for potential click.\n   */\n  const onHandlePointerDown = (evt: PointerEvent) => {\n    isHandleHovered = true;\n\n    evt.preventDefault();\n    evt.stopPropagation();\n\n    lastHandleClick = performance.now();\n  }\n\n  /** Selection handling logic **/\n  const onHandlePointerUp = (idx: number) => (evt: PointerEvent) => {\n    if (!lastHandleClick || isTouch) return;\n\n    // Drag, not click\n    if (performance.now() - lastHandleClick > CLICK_THRESHOLD) return;\n\n    const isSelected = selectedCorners.includes(idx);\n\n    if (evt.metaKey || evt.ctrlKey || evt.shiftKey) {\n      // Add to or remove from selection\n      if (isSelected)\n        selectedCorners = selectedCorners.filter(i => i !== idx);\n      else\n        selectedCorners = [...selectedCorners, idx];\n    } else {\n      if (isSelected && selectedCorners.length > 1)\n        // Keep selected, de-select others\n        selectedCorners = [idx]\n      else if (isSelected)\n        // De-select\n        selectedCorners = [];\n      else\n        selectedCorners = [idx];\n    }\n\n    reclaimFocus();\n  }\n\n  const editor = (polygon: Shape, handle: string, delta: [number, number]) => {\n    reclaimFocus();\n    \n    let points: [number, number][];\n\n    const geom = (polygon.geometry) as PolygonGeometry;\n\n    if (selectedCorners.length > 1) {\n      points = geom.points.map(([x, y], idx) =>\n          selectedCorners.includes(idx) ? [x + delta[0], y + delta[1]] : [x, y]);\n    } else if (handle === 'SHAPE') {\n      points = geom.points.map(([x, y]) => [x + delta[0], y + delta[1]]);\n    } else {\n      points = geom.points.map(([x, y], idx) =>\n        handle === `HANDLE-${idx}` ? [x + delta[0], y + delta[1]] : [x, y]);\n    }\n\n    const bounds = boundsFromPoints(points);\n    return {\n      ...polygon,\n      geometry: { points, bounds }\n    }\n  }\n\n  const onAddPoint = (midpointIdx: number) => async (evt: PointerEvent) => {\n    evt.stopPropagation();\n\n    const points = [\n      ...geom.points.slice(0, midpointIdx + 1),\n      midpoints[midpointIdx].point,\n      ...geom.points.slice(midpointIdx + 1)\n    ] as [number, number][];\n\n    const bounds = boundsFromPoints(points);\n\n    dispatch('change', {\n      ...shape,\n      geometry: { points, bounds }\n    });\n\n    await tick();\n\n    // Find the newly inserted handle and dispatch grab event\n    const newHandle = [...document.querySelectorAll(`.a9s-handle`)][midpointIdx + 1];\n    if (newHandle?.firstChild) {\n      const newEvent = new PointerEvent('pointerdown', {\n        bubbles: true,\n        cancelable: true,\n        clientX: evt.clientX,\n        clientY: evt.clientY,\n        pointerId: evt.pointerId,\n        pointerType: evt.pointerType,\n        isPrimary: evt.isPrimary,\n        buttons: evt.buttons\n      });\n\n      newHandle.firstChild.dispatchEvent(newEvent);\n    }\n  }\n\n  const onDeleteSelected = () => {\n    // Polygon needs 3 points min\n    if (geom.points.length - selectedCorners.length < 3) return;\n\n    const points = geom.points.filter((_, i) => !selectedCorners.includes(i)) as [number, number][];\n    const bounds = boundsFromPoints(points);\n\n    dispatch('change', {\n      ...shape,\n      geometry: { points, bounds }\n    });\n\n    selectedCorners = [];\n  }\n\n  onMount(() => {\n    if (isTouch) return;\n\n    const onKeydown = (evt: KeyboardEvent) => {\n      if (evt.key === 'Delete' || evt.key === 'Backspace') {\n        evt.preventDefault();\n        onDeleteSelected();\n      }\n    };\n\n    svgEl.addEventListener('pointermove', onPointerMove);\n    svgEl.addEventListener('keydown', onKeydown);\n\n    return () => {\n      svgEl.removeEventListener('pointermove', onPointerMove);\n      svgEl.removeEventListener('keydown', onKeydown);\n    }\n  });\n\n  $: mask = getMaskDimensions(geom.bounds, MIDPOINT_SIZE / viewportScale);\n\n  const maskId = `polygon-mask-${Math.random().toString(36).substring(2, 12)}`;\n</script>\n\n<Editor\n  shape={shape}\n  transform={transform}\n  editor={editor}\n  svgEl={svgEl}\n  on:change \n  on:grab\n  on:release\n  let:grab={grab}>\n  \n  <defs>\n    <mask id={`${maskId}-outer`} class=\"a9s-polygon-editor-mask\">\n      <rect x={mask.x} y={mask.y} width={mask.w} height={mask.h} />\n      <polygon points={geom.points.map(xy => xy.join(',')).join(' ')} />   \n      \n      {#if (visibleMidpoint !== undefined && !isHandleHovered)}\n        {@const { point } = midpoints[visibleMidpoint]}\n        <circle cx={point[0]} cy={point[1]} r={MIDPOINT_SIZE / viewportScale} />\n      {/if}  \n    </mask>\n\n    {#if (visibleMidpoint !== undefined && !isHandleHovered)}\n      {@const { point } = midpoints[visibleMidpoint]}\n      <mask id={`${maskId}-inner`}  class=\"a9s-polygon-editor-mask\">\n        <rect x={mask.x} y={mask.y} width={mask.w} height={mask.h} /> \n        <circle cx={point[0]} cy={point[1]} r={MIDPOINT_SIZE / viewportScale} />\n      </mask>\n    {/if}\n  </defs>\n\n  <polygon\n    class=\"a9s-outer\"\n    mask={`url(#${maskId}-outer)`}\n    on:pointerup={onShapePointerUp}\n    on:pointerdown={grab('SHAPE')}\n    points={geom.points.map(xy => xy.join(',')).join(' ')} />\n\n  <polygon\n    class=\"a9s-inner a9s-shape-handle\"\n    mask={`url(#${maskId}-inner)`}\n    style={computedStyle}\n    on:pointermove={onPointerMove}\n    on:pointerup={onShapePointerUp}\n    on:pointerdown={grab('SHAPE')}\n    points={geom.points.map(xy => xy.join(',')).join(' ')} />\n\n  {#each geom.points as point, idx}\n    <Handle \n      class=\"a9s-corner-handle\"\n      x={point[0]}\n      y={point[1]}\n      scale={viewportScale}\n      selected={selectedCorners.includes(idx)}\n      on:pointerenter={onEnterHandle}\n      on:pointerleave={onLeaveHandle}\n      on:pointerdown={onHandlePointerDown}\n      on:pointerdown={grab(`HANDLE-${idx}`)}\n      on:pointerup={onHandlePointerUp(idx)} />\n  {/each}\n\n  {#if (visibleMidpoint !== undefined && !isHandleHovered)}\n    {@const { point } = midpoints[visibleMidpoint]}\n    <MidpointHandle \n      x={point[0]}\n      y={point[1]}\n      scale={viewportScale}\n      on:pointerdown={onAddPoint(visibleMidpoint)} />\n  {/if}\n</Editor>\n\n<style>\n  mask.a9s-polygon-editor-mask > rect {\n    fill: #fff;\n  }\n\n  mask.a9s-polygon-editor-mask > circle,\n  mask.a9s-polygon-editor-mask > polygon {\n    fill: #000;\n  }\n</style>","<script lang=\"ts\">\n  import Handle from '../Handle.svelte';\n  import { getMaskDimensions } from '../../utils';\n  import type { Rectangle, Shape } from '../../../model';\n  import type { Transform } from '../../Transform';\n  import { Editor } from '..';\n\n  /** Props */\n  export let shape: Rectangle;\n  export let computedStyle: string | undefined;\n  export let transform: Transform;\n  export let viewportScale: number = 1;\n  export let svgEl: SVGSVGElement;\n\n  $: geom = shape.geometry;\n\n  const editor = (rectangle: Shape, handle: string, delta: [number, number]) => {\n    const initialBounds = rectangle.geometry.bounds;\n\n    let [x0, y0] = [initialBounds.minX, initialBounds.minY];\n    let [x1, y1] = [initialBounds.maxX, initialBounds.maxY];\n\n    const [dx, dy] = delta;\n\n    if (handle === 'SHAPE') {\n      x0 += dx;\n      x1 += dx;\n      y0 += dy;\n      y1 += dy;\n    } else {\n      switch (handle) {\n        case 'TOP':\n        case 'TOP_LEFT':\n        case 'TOP_RIGHT': {\n          y0 += dy;\n          break;\n        }\n\n        case 'BOTTOM':\n        case 'BOTTOM_LEFT':\n        case 'BOTTOM_RIGHT': {\n          y1 += dy;\n          break;\n        }\n      }\n\n      switch (handle) {\n        case 'LEFT':\n        case 'TOP_LEFT':\n        case 'BOTTOM_LEFT': {\n          x0 += dx;\n          break;\n        }\n\n        case 'RIGHT':\n        case 'TOP_RIGHT':\n        case 'BOTTOM_RIGHT': {\n          x1 += dx;\n          break;\n        }\n      }\n    }\n\n    const x = Math.min(x0, x1);\n    const y = Math.min(y0, y1);\n    const w = Math.abs(x1 - x0);\n    const h = Math.abs(y1 - y0);\n\n    return {\n      ...rectangle,\n      geometry: {\n        x, y, w, h,\n        bounds: {\n          minX: x,\n          minY: y,\n          maxX: x + w,\n          maxY: y + h\n        }\n      }\n    };\n  }\n\n  $: mask = getMaskDimensions(geom.bounds, 2 / viewportScale);\n  \n  const maskId = `rect-mask-${Math.random().toString(36).substring(2, 12)}`;\n</script>\n\n<Editor\n  shape={shape}\n  transform={transform}\n  editor={editor}\n  svgEl={svgEl}\n  on:grab\n  on:change \n  on:release\n  let:grab={grab}>\n\n  <defs>\n    <mask id={maskId} class=\"a9s-rectangle-editor-mask\">\n      <rect class=\"rect-mask-bg\" x={mask.x} y={mask.y} width={mask.w} height={mask.h} />\n      <rect class=\"rect-mask-fg\" x={geom.x} y={geom.y} width={geom.w} height={geom.h} />\n    </mask>\n  </defs>\n\n  <rect \n    class=\"a9s-outer\"\n    mask={`url(#${maskId})`}\n    on:pointerdown={grab('SHAPE')}\n    x={geom.x} y={geom.y} width={geom.w} height={geom.h} />\n\n  <rect \n    class=\"a9s-inner a9s-shape-handle\"\n    style={computedStyle}\n    on:pointerdown={grab('SHAPE')}\n    x={geom.x} y={geom.y} width={geom.w} height={geom.h} />\n\n  <rect \n    class=\"a9s-edge-handle a9s-edge-handle-top\" \n    on:pointerdown={grab('TOP')}\n    x={geom.x} y={geom.y} height={1} width={geom.w} />\n\n  <rect \n    class=\"a9s-edge-handle a9s-edge-handle-right\"\n    on:pointerdown={grab('RIGHT')}\n    x={geom.x + geom.w} y={geom.y} height={geom.h} width={1}/>\n\n  <rect \n    class=\"a9s-edge-handle a9s-edge-handle-bottom\" \n    on:pointerdown={grab('BOTTOM')}\n    x={geom.x} y={geom.y + geom.h} height={1} width={geom.w} />\n\n  <rect \n    class=\"a9s-edge-handle a9s-edge-handle-left\" \n    on:pointerdown={grab('LEFT')}\n    x={geom.x} y={geom.y} height={geom.h} width={1} />\n\n  <Handle\n    class=\"a9s-corner-handle-topleft\"\n    on:pointerdown={grab('TOP_LEFT')}\n    x={geom.x} y={geom.y}\n    scale={viewportScale} /> \n\n  <Handle\n    class=\"a9s-corner-handle-topright\"\n    on:pointerdown={grab('TOP_RIGHT')}\n    x={geom.x + geom.w} y={geom.y} \n    scale={viewportScale} />\n  \n  <Handle \n    class=\"a9s-corner-handle-bottomright\"\n    on:pointerdown={grab('BOTTOM_RIGHT')}\n    x={geom.x + geom.w} y={geom.y + geom.h} \n    scale={viewportScale} />\n    \n  <Handle \n    class=\"a9s-corner-handle-bottomleft\"\n    on:pointerdown={grab('BOTTOM_LEFT')}\n    x={geom.x} y={geom.y + geom.h} \n    scale={viewportScale} />\n</Editor>\n\n<style>\n  mask.a9s-rectangle-editor-mask > rect.rect-mask-bg {\n    fill: #fff;\n  }\n\n  mask.a9s-rectangle-editor-mask > rect.rect-mask-fg {\n    fill: #000;\n  }\n</style>","var has = Object.prototype.hasOwnProperty;\n\nexport function dequal(foo, bar) {\n\tvar ctor, len;\n\tif (foo === bar) return true;\n\n\tif (foo && bar && (ctor=foo.constructor) === bar.constructor) {\n\t\tif (ctor === Date) return foo.getTime() === bar.getTime();\n\t\tif (ctor === RegExp) return foo.toString() === bar.toString();\n\n\t\tif (ctor === Array) {\n\t\t\tif ((len=foo.length) === bar.length) {\n\t\t\t\twhile (len-- && dequal(foo[len], bar[len]));\n\t\t\t}\n\t\t\treturn len === -1;\n\t\t}\n\n\t\tif (!ctor || typeof foo === 'object') {\n\t\t\tlen = 0;\n\t\t\tfor (ctor in foo) {\n\t\t\t\tif (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;\n\t\t\t\tif (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;\n\t\t\t}\n\t\t\treturn Object.keys(bar).length === len;\n\t\t}\n\t}\n\n\treturn foo !== foo && bar !== bar;\n}\n","import type { MultiPolygonGeometry } from '../../../model';\n\n/** Minimum distance (px) between corners required for midpoints to show **/\nconst MIN_VISIBILITY_DISTANCE = 12;\n\nexport interface MultipolygonMidpoint {\n\n  point: [number, number];\n\n  visible: boolean;\n\n  elementIdx: number;\n\n  ringIdx: number;\n\n  pointIdx: number;\n\n}\n\nexport const computeMidpoints = (geom: MultiPolygonGeometry, viewportScale: number) =>\n  geom.polygons.reduce<MultipolygonMidpoint[]>((all, element, elementIdx) => {\n    const forThisPolygon = element.rings.reduce<MultipolygonMidpoint[]>((forThisPolygon, ring, ringIdx) => {\n      const forThisRing: MultipolygonMidpoint[] = ring.points.map((thisPoint, pointIdx) => {\n        const nextPoint = pointIdx === ring.points.length - 1 ? ring.points[0] : ring.points[pointIdx + 1];\n\n        const x = (thisPoint[0] + nextPoint[0]) / 2;\n        const y = (thisPoint[1] + nextPoint[1]) / 2;\n\n        const dist = Math.sqrt( \n          Math.pow(nextPoint[0] - x, 2) + Math.pow(nextPoint[1] - y, 2));\n\n        // Don't show if the distance between the corners is too small\n        const visible = dist > MIN_VISIBILITY_DISTANCE / viewportScale;\n\n        return { point: [x, y], visible, elementIdx, ringIdx, pointIdx };\n      });\n\n      return [...forThisPolygon, ...forThisRing];\n    }, []);\n\n    return [...all, ...forThisPolygon];\n  }, []);","<script lang=\"ts\">\n  import { createEventDispatcher, onMount, tick } from 'svelte';\n  import { dequal } from 'dequal/lite';\n  import type { MultiPolygon, MultiPolygonElement, MultiPolygonGeometry, Shape } from '../../../model';\n  import { getMaskDimensions, isTouch } from '../../utils';\n  import type { Transform } from '../../Transform';\n  import Editor from '../Editor.svelte';\n  import Handle from '../Handle.svelte';\n  import MidpointHandle from '../MidpointHandle.svelte';\n  import { computeMidpoints } from './utils';\n  import { \n    boundsFromMultiPolygonElements, \n    boundsFromPoints, \n    getAllCorners, \n    multipolygonElementToPath\n  } from '../../../model';\n\n  const dispatch = createEventDispatcher<{ change: MultiPolygon }>();\n\n  /** Time difference (milliseconds) required for registering a click/tap **/\n  const CLICK_THRESHOLD = 250;\n\n  /** Minimum distance (px) to shape required for midpoints to show */\n  const MIN_HOVER_DISTANCE = 1000;\n\n  /** Needed for the <mask> element **/\n  const MIDPOINT_SIZE = 4.5;\n\n  /** Props */\n  export let shape: MultiPolygon;\n  export let computedStyle: string | undefined;\n  export let transform: Transform;\n  export let viewportScale: number = 1;\n  export let svgEl: SVGSVGElement;\n\n  /** Drawing tool layer **/\n  let visibleMidpoint: number | undefined;\n  let isHandleHovered = false;\n  let lastHandleClick: number | undefined;\n  let selectedCorners: { polygon: number, ring: number, point: number }[] = [];\n\n  $: geom = shape.geometry;\n\n  // No support yet for adding or removing points in mobile!\n  $: midpoints = isTouch ? [] : computeMidpoints(geom, viewportScale);\n\n  /** Handle hover state **/\n  const onEnterHandle = () => isHandleHovered = true;\n  const onLeaveHandle = () => isHandleHovered = false;\n\n  /** Determine visible midpoint, if any **/\n  const onPointerMove = (evt: PointerEvent) => {\n    if (selectedCorners.length > 0 || !midpoints.some(m => m.visible)) {\n      visibleMidpoint = undefined;\n      return;\n    }\n    \n    const [px, py] = transform.elementToImage(evt.offsetX, evt.offsetY);\n\n    const getDistSq = (pt: number[]) =>\n      Math.pow(pt[0] - px, 2) + Math.pow(pt[1] - py, 2);\n\n    const closestCorner = getAllCorners(geom).reduce((closest, corner) =>\n      getDistSq(corner) < getDistSq(closest) ? corner : closest);\n\n    const closestVisibleMidpoint = midpoints\n      .filter(m => m.visible)\n      .reduce((closest, midpoint) =>\n        getDistSq(midpoint.point) < getDistSq(closest.point) ? midpoint : closest);\n\n    // Show midpoint of the mouse is at least within THRESHOLD distance\n    // of the midpoint or the closest corner. (Basically a poor man's shape buffering).\n    const threshold = Math.pow(MIN_HOVER_DISTANCE / viewportScale, 2);\n\n    const shouldShow = \n      getDistSq(closestCorner) < threshold ||\n      getDistSq(closestVisibleMidpoint.point) < threshold;\n\n    if (shouldShow)\n      visibleMidpoint = midpoints.indexOf(closestVisibleMidpoint);\n    else\n      visibleMidpoint = undefined;\n  }\n\n  /** \n   * SVG element keeps loosing focus when interacting with \n   * shapesthis function refocuses.\n   */\n  const reclaimFocus = () => {\n    if (document.activeElement !== svgEl)\n      svgEl.focus();\n  }\n\n  /**\n   * De-selects all corners and reclaims focus.\n   */\n  const onShapePointerUp = () => {\n    selectedCorners = [];\n    reclaimFocus();\n  }\n\n  /**\n   * Updates state, waiting for potential click.\n   */\n  const onHandlePointerDown = (evt: PointerEvent) => {\n    isHandleHovered = true;\n\n    evt.preventDefault();\n    evt.stopPropagation();\n\n    lastHandleClick = performance.now();\n  }\n\n  /** Selection handling logic **/\n  const onHandlePointerUp = (polygon: number, ring: number, point: number) => (evt: PointerEvent) => {\n    if (!lastHandleClick || isTouch) return;\n\n    // Drag, not click\n    if (performance.now() - lastHandleClick > CLICK_THRESHOLD) return;\n\n    // Shorthand\n    const isMatch = (other: { polygon: number, ring: number, point: number }) => \n      other.polygon === polygon && other.ring === ring && other.point === point;\n\n    const isSelected = selectedCorners.some(isMatch);\n\n    if (evt.metaKey || evt.ctrlKey || evt.shiftKey) {\n      // Add to or remove from selection\n      if (isSelected)\n        selectedCorners = selectedCorners.filter(other => !isMatch(other));\n      else\n        selectedCorners = [...selectedCorners, { polygon, ring, point }];\n    } else {\n      if (isSelected && selectedCorners.length > 1)\n        // Keep selected, de-select others\n        selectedCorners = [{ polygon, ring, point }]\n      else if (isSelected)\n        // De-select\n        selectedCorners = [];\n      else\n        selectedCorners = [{ polygon, ring, point }];\n    }\n\n    reclaimFocus();\n  }\n\n  const editor = (shape: Shape, handle: string, delta: [number, number]) => {\n    reclaimFocus();\n    \n    const elements = ((shape.geometry) as MultiPolygonGeometry).polygons;\n\n    let updated: MultiPolygonElement[];\n\n    if (handle === 'SHAPE') {\n      updated = elements.map(element => {\n        const rings = element.rings.map((ring, r) => {\n          const points = ring.points.map((point, p) => {\n            return [point[0] + delta[0], point[1] + delta[1]];\n          });\n\n          return { points };\n        });\n\n        const bounds = boundsFromPoints(rings[0].points as [number, number][]);\n        return { rings, bounds } as MultiPolygonElement;\n      });\n    } else {\n      const [_, elementIdx, ringIdx, pointIdx] = handle.split('-').map(str => parseInt(str));\n\n      updated = elements.map((element, e) => {\n        if (e === elementIdx) {\n          const rings = element.rings.map((ring, r) => {\n            if (r === ringIdx) {\n              const points = ring.points.map((point, p) => {\n                if (p === pointIdx) {\n                  return [point[0] + delta[0], point[1] + delta[1]];\n                } else {\n                  return point;\n                }\n              });\n\n              return { points };\n            } else {\n              return ring;\n            }\n          });\n\n          const bounds = boundsFromPoints(rings[0].points as [number, number][]);\n          return { rings, bounds } as MultiPolygonElement;\n        } else {\n          return element;\n        }\n      });\n    }\n\n    return { \n      ...shape, \n      geometry: {\n        polygons: updated,\n        bounds: boundsFromMultiPolygonElements(updated)\n      } \n    } as MultiPolygon;\n  }\n\n  const onAddPoint = (midpointIdx: number) => async (evt: PointerEvent) => {\n    evt.stopPropagation();\n\n    const midpoint = midpoints[midpointIdx];\n    \n    const updated = geom.polygons.map((element, elIdx) => {\n      if (elIdx === midpoint.elementIdx) {\n        const rings = element.rings.map((ring, ringIdx) => {\n          if (ringIdx === midpoint.ringIdx) {\n            const points = [\n              ...ring.points.slice(0, midpoint.pointIdx + 1),\n              midpoint.point,\n              ...ring.points.slice(midpoint.pointIdx + 1)\n            ] as [number, number][];\n\n            return { points };\n          } else {\n            return ring;\n          }\n        });\n\n        const bounds = boundsFromPoints(rings[0].points as [number, number][]);\n        return { rings, bounds } as MultiPolygonElement;\n      } else {\n        return element;\n      }\n    });\n\n    dispatch('change', {\n      ...shape, \n      geometry: {\n        polygons: updated,\n        bounds: boundsFromMultiPolygonElements(updated)\n      } \n    } as MultiPolygon);\n\n    await tick();\n\n    // Find the newly inserted handle and dispatch grab event\n    const newHandle = [...document.querySelectorAll(`.a9s-handle`)][midpointIdx + 1];\n    if (newHandle?.firstChild) {\n      const newEvent = new PointerEvent('pointerdown', {\n        bubbles: true,\n        cancelable: true,\n        clientX: evt.clientX,\n        clientY: evt.clientY,\n        pointerId: evt.pointerId,\n        pointerType: evt.pointerType,\n        isPrimary: evt.isPrimary,\n        buttons: evt.buttons\n      });\n\n      newHandle.firstChild.dispatchEvent(newEvent);\n    }\n  }\n\n  const onDeleteSelected = () => {\n    const updatedPolygons = geom.polygons.map((polygon, polygonIdx) => {\n      const hasSelected = selectedCorners.some(s => s.polygon === polygonIdx);\n\n      if (hasSelected) {\n        const updatedRings = polygon.rings.map((ring, ringIdx) => {\n          const selectedCornersInRing = selectedCorners.filter(s => s.polygon === polygonIdx && s.ring === ringIdx);\n\n          // Rings needs 3 points min\n          if (selectedCornersInRing.length && ring.points.length - selectedCornersInRing.length >= 3) {\n            const points = ring.points.filter((_, i) => !selectedCornersInRing.some(s => s.point === i));\n            return { points };\n          } else {\n            // No points selected on this ring\n            return ring;\n          }\n        });\n\n        const bounds = boundsFromPoints(updatedRings[0].points as [number, number][]);\n        return { rings: updatedRings, bounds } as MultiPolygonElement;\n      } else {\n        // No points selected on this polygon\n        return polygon;\n      }\n    });\n\n    const hasChanged = !dequal(geom.polygons, updatedPolygons);\n    if (hasChanged) {\n      dispatch('change', {\n        ...shape, \n        geometry: {\n          polygons: updatedPolygons,\n          bounds: boundsFromMultiPolygonElements(updatedPolygons)\n        } \n      } as MultiPolygon);\n\n      selectedCorners = [];\n    }\n  }\n\n  onMount(() => {\n    if (isTouch) return;\n\n    const onKeydown = (evt: KeyboardEvent) => {\n      if (evt.key === 'Delete' || evt.key === 'Backspace') {\n        evt.preventDefault();\n        onDeleteSelected();\n      }\n    };\n\n    svgEl.addEventListener('pointermove', onPointerMove);\n    svgEl.addEventListener('keydown', onKeydown);\n\n    return () => {\n      svgEl.removeEventListener('pointermove', onPointerMove);\n      svgEl.removeEventListener('keydown', onKeydown);\n    }\n  });\n\n  $: mask = getMaskDimensions(geom.bounds, MIDPOINT_SIZE / viewportScale);\n\n  const maskId = `polygon-mask-${Math.random().toString(36).substring(2, 12)}`;\n</script>\n\n<Editor\n  shape={shape}\n  transform={transform}\n  editor={editor}\n  svgEl={svgEl}\n  on:change \n  on:grab\n  on:release\n  let:grab={grab}>\n  {#each geom.polygons as element, elementIdx}\n    <g>\n      <defs>\n        <mask id={`${maskId}-${elementIdx}-outer`} class=\"a9s-multipolygon-editor-mask\">\n          <rect x={mask.x} y={mask.y} width={mask.w} height={mask.h} />\n          <path d={multipolygonElementToPath(element)} /> \n          \n          {#if (visibleMidpoint !== undefined && !isHandleHovered)}\n            {@const { point } = midpoints[visibleMidpoint]}\n            <circle cx={point[0]} cy={point[1]} r={MIDPOINT_SIZE / viewportScale} />\n          {/if}\n        </mask>\n\n        {#if (visibleMidpoint !== undefined && !isHandleHovered)}\n          {@const { point } = midpoints[visibleMidpoint]}\n          <mask id={`${maskId}-${elementIdx}-inner`}  class=\"a9s-multipolygon-editor-mask\">\n            <rect x={mask.x} y={mask.y} width={mask.w} height={mask.h} /> \n            <circle cx={point[0]} cy={point[1]} r={MIDPOINT_SIZE / viewportScale} />\n          </mask>\n        {/if}\n      </defs>\n\n      <path \n        class=\"a9s-outer\"\n        mask={`url(#${maskId}-${elementIdx}-outer)`}\n        fill-rule=\"evenodd\"\n        on:pointerup={onShapePointerUp}\n        on:pointerdown={grab('SHAPE')}\n        d={multipolygonElementToPath(element)} />\n\n      <path \n        class=\"a9s-inner\"\n        mask={`url(#${maskId}-${elementIdx}-inner)`}\n        style={computedStyle}\n        fill-rule=\"evenodd\"\n        on:pointerup={onShapePointerUp}\n        on:pointerdown={grab('SHAPE')}\n        d={multipolygonElementToPath(element)} />\n\n      {#each element.rings as ring, ringIdx}\n        {#each ring.points as point, pointIdx}\n          <Handle \n            class=\"a9s-corner-handle\"\n            x={point[0]} \n            y={point[1]} \n            scale={viewportScale}\n            selected={selectedCorners.some(({ polygon, ring, point }) => \n              polygon === elementIdx && ring === ringIdx && point === pointIdx)}\n            on:pointerenter={onEnterHandle}\n            on:pointerleave={onLeaveHandle}\n            on:pointerdown={onHandlePointerDown}\n            on:pointerdown={grab(`HANDLE-${elementIdx}-${ringIdx}-${pointIdx}`)}\n            on:pointerup={onHandlePointerUp(elementIdx, ringIdx, pointIdx)}  />\n        {/each}\n      {/each}\n    </g>\n  {/each}\n\n  {#if (visibleMidpoint !== undefined && !isHandleHovered)}\n    {@const { point } = midpoints[visibleMidpoint]}\n    <MidpointHandle \n      x={point[0]}\n      y={point[1]}\n      scale={viewportScale} \n      on:pointerdown={onAddPoint(visibleMidpoint)} />\n  {/if}\n</Editor>\n\n<style>\n  mask.a9s-multipolygon-editor-mask > rect {\n    fill: #fff;\n  }\n\n  mask.a9s-multipolygon-editor-mask > circle,\n  mask.a9s-multipolygon-editor-mask > path {\n    fill: #000;\n  }\n</style>","import type { SvelteComponent } from 'svelte';\nimport { ShapeType, type Shape } from '../../model';\nimport { MultiPolygonEditor } from './multipolygon';\nimport { PolygonEditor } from './polygon';\nimport { RectangleEditor } from './rectangle';\n\nconst REGISTERED = new Map<ShapeType, typeof SvelteComponent>([\n  [ShapeType.RECTANGLE, RectangleEditor as typeof SvelteComponent],\n  [ShapeType.POLYGON, PolygonEditor as typeof SvelteComponent],\n  [ShapeType.MULTIPOLYGON, MultiPolygonEditor as typeof SvelteComponent]\n]);\n\nexport const getEditor = (shape: Shape) => REGISTERED.get(shape.type);\n\nexport const registerEditor = (shapeType: ShapeType, editor: typeof SvelteComponent) =>\n  REGISTERED.set(shapeType, editor);","<script lang=\"ts\">\n  import type { DrawingStyleExpression } from '@annotorious/core';\n  import { createEventDispatcher, onMount, type SvelteComponent } from 'svelte';\n  import type { ImageAnnotation, Shape } from '../../model';\n  import { computeStyle } from '../utils/styling';\n  import type { Transform } from '../Transform';\n\n  const dispatch = createEventDispatcher<{ grab: PointerEvent, release: PointerEvent, change: Shape }>();\n\n  /** Props */\n  export let annotation: ImageAnnotation;\n  export let editor: typeof SvelteComponent;\n  export let style: DrawingStyleExpression<ImageAnnotation> | undefined;\n  export let target: SVGGElement;\n  export let transform: Transform;\n  export let viewportScale: number;\n\n  let editorComponent: SvelteComponent;\n\n  $: computedStyle = computeStyle(annotation, style);\n\n  $: if (annotation) editorComponent?.$set({ shape: annotation.target.selector });\n  $: if (editorComponent) editorComponent.$set({ transform });\n  $: if (editorComponent) editorComponent.$set({ viewportScale });\n  $: if (editorComponent && computedStyle) editorComponent.$set({ computedStyle });\n\n  onMount(() => {    \n    editorComponent = new editor({\n      target,\n      props: { \n        shape: annotation.target.selector, \n        computedStyle, \n        transform, \n        viewportScale,\n        svgEl: target.closest('svg')\n      }\n    });\n\n    editorComponent.$on('change', event => {\n      editorComponent.$$set({ shape: event.detail });\n      dispatch('change', event.detail);\n    });\n\n    editorComponent.$on('grab', event => dispatch('grab', event.detail));\n    editorComponent.$on('release', event => dispatch('release', event.detail));\n\n    return () => {\n      editorComponent.$destroy();\n    }\n  });\n</script>","<script lang=\"ts\">\n  import { createEventDispatcher, onMount, type SvelteComponent } from 'svelte';\n  import type { Transform } from '../Transform';\n  import type { Shape } from 'src/model';\n  import type { DrawingMode } from 'src/AnnotoriousOpts';\n\n  const dispatch = createEventDispatcher<{ create: Shape }>();\n\n  /** Props **/\n  export let drawingMode: DrawingMode;\n  export let target: SVGGElement;\n  export let tool: typeof SvelteComponent;\n  export let transform: Transform;\n  export let viewportScale: number;\n\n  let toolComponent: SvelteComponent;\n\n  $: if (toolComponent) toolComponent.$set({ transform });\n  $: if (toolComponent) toolComponent.$set({ viewportScale });\n\n  onMount(() => {\n    const svg = target.closest('svg');\n\n    const cleanup: Function[] = [];\n\n    const addEventListener = (name: keyof SVGSVGElementEventMap, handler: EventListenerOrEventListenerObject, capture?: boolean) => {\n      svg?.addEventListener(name, handler, capture);\n      cleanup.push(() => svg?.removeEventListener(name, handler, capture));\n    }\n\n    toolComponent = new tool({\n      target,\n      props: { \n        addEventListener,\n        drawingMode,\n        transform, \n        viewportScale\n      }\n    });\n\n    toolComponent.$on('create', \n      event => dispatch('create', event.detail));\n\n    return () => {\n      cleanup.forEach(fn => fn());\n      toolComponent.$destroy();\n    }\n  });\n</script>","<script lang=\"ts\">\n  import { createEventDispatcher, onMount } from 'svelte';\n  import type { DrawingMode } from '../../../AnnotoriousOpts';\n  import { ShapeType, type Rectangle } from '../../../model';\n  import type { Transform } from '../..';\n\n  const dispatch = createEventDispatcher<{ create: Rectangle }>();\n  \n  /** Props **/\n  export let addEventListener: (type: string, fn: EventListener, capture?: boolean) => void;\n  export let drawingMode: DrawingMode;\n  export let transform: Transform;\n  export let viewportScale: number = 1;\n\n  let lastPointerDown: number;\n\n  let origin: [x: number, y: number] | undefined; \n\n  let anchor: [number, number] | undefined;\n\n  let x: number, y: number, w: number, h: number;\n\n  const onPointerDown = (event: Event) => {\n    const evt = event as PointerEvent;\n\n    lastPointerDown = performance.now();\n\n    if (drawingMode === 'drag') {\n      origin = transform.elementToImage(evt.offsetX, evt.offsetY);\n      anchor = origin;\n\n      x = origin[0];\n      y = origin[1];\n      w = 1;\n      h = 1;\n    }\n  }\n\n  const onPointerMove = (event: Event) => {\n    const evt = event as PointerEvent;\n\n    if (origin) {\n      anchor = transform.elementToImage(evt.offsetX, evt.offsetY);\n\n      x = Math.min(anchor[0], origin[0]);\n      y = Math.min(anchor[1], origin[1]);\n      w = Math.abs(anchor[0] - origin[0]);\n      h = Math.abs(anchor[1] - origin[1]);\n    }\n  }\n    \n  const onPointerUp = (event: Event) => {\n    const evt = event as PointerEvent;\n\n    const timeDifference = performance.now() - lastPointerDown;\n\n    if (drawingMode === 'click') {\n      // Not a single click - ignore\n      if (timeDifference > 300)\n        return;\n\n      // This statement caused a weird bug on OSD: when starting\n      // to draw with a quick drag (<300ms), OSD got stuck in mouseNav \n      // mode. The image still moved with the mouse cursor, even though \n      // button was no longer pressed. \n      // I'm commenting out this statement as a fix. But there must have\n      // been a reason I put it here in the first place. Keep an eye ou\n      // for regressions.\n      // \n      // And if you are ever tempted to un-comment the statement: beware!\n      \n      // evt.stopPropagation();\n\n      if (origin) {\n        stopDrawing();\n      } else {\n        // Start drawing\n        origin = transform.elementToImage(evt.offsetX, evt.offsetY);\n        anchor = origin;\n\n        x = origin[0];\n        y = origin[1];\n        w = 1;\n        h = 1;\n      }\n    } else if (origin) {\n      if (timeDifference > 300 || w * h > 100) {\n        evt.stopPropagation();\n        stopDrawing();\n      } else {\n        origin = undefined;\n        anchor = undefined;\n      }\n    }\n  }\n\n  const stopDrawing = () => {\n    // Require 4x4 pixels minimum\n    if (w * h > 15) {\n      const shape: Rectangle = {\n        type: ShapeType.RECTANGLE, \n        geometry: {\n          bounds: {\n            minX: x, \n            minY: y,\n            maxX: x + w,\n            maxY: y + h\n          },\n          x, y, w, h\n        }\n      }\n\n      dispatch('create', shape);\n    }\n    \n    origin = undefined;\n    anchor = undefined;\n  }\n\n  onMount(() => {\n    addEventListener('pointerdown', onPointerDown);\n    addEventListener('pointermove', onPointerMove);\n    addEventListener('pointerup', onPointerUp, true);\n  });\n  \n  const maskId = `rect-mask-${Math.random().toString(36).substring(2, 12)}`;\n  \n  $: buffer = 2 / viewportScale;\n</script>\n\n<g class=\"a9s-annotation a9s-rubberband\">\n  {#if origin}\n    <defs>\n      <mask id={maskId} class=\"a9s-rubberband-rectangle-mask\">\n        <rect \n          class=\"rect-mask-bg\" \n          x={x - buffer} \n          y={y - buffer} \n          width={w + 2 * buffer}\n          height={h + 2 * buffer}/>\n\n        <rect \n          class=\"rect-mask-fg\" \n          x={x} \n          y={y} \n          width={w} \n          height={h} />\n      </mask>\n    </defs>\n    \n    <rect\n      class=\"a9s-outer\"\n      mask={`url(#${maskId})`}\n      x={x} \n      y={y} \n      width={w} \n      height={h} />\n\n    <rect\n      class=\"a9s-inner\"\n      x={x} \n      y={y} \n      width={w} \n      height={h} />\n  {/if}\n</g>\n\n<style>\n  mask.a9s-rubberband-rectangle-mask > rect.rect-mask-bg {\n    fill: #fff;\n  }\n\n  mask.a9s-rubberband-rectangle-mask > rect.rect-mask-fg {\n    fill: #000;\n  }\n</style>","<script lang=\"ts\">\n  import { onMount, createEventDispatcher } from 'svelte';\n  import type { DrawingMode } from '../../../AnnotoriousOpts';\n  import { boundsFromPoints, computeArea, distance, ShapeType, type Polygon } from '../../../model';\n  import { getMaskDimensions } from '../../utils';\n  import type { Transform } from '../..';\n\n  const dispatch = createEventDispatcher<{ create: Polygon }>();\n\n  /** Props **/\n  export let addEventListener: (type: string, fn: EventListener, capture?: boolean) => void;\n  export let drawingMode: DrawingMode;\n  export let transform: Transform;\n  export let viewportScale = 1;\n\n  let lastPointerDown: { timeStamp: number, offsetX: number, offsetY: number };\n\n  let points: [number, number][] = [];\n  \n  let cursor: [number, number] | undefined;\n\n  // Keep track of the user keeping the finger\n  // in place. Long pauses will be interpreted like a \n  // double click and close the shape.\n  let touchPauseTimer: ReturnType<typeof setTimeout> | undefined;\n\n  let isClosable: boolean = false;\n\n  const CLOSE_DISTANCE = 20;\n\n  const TOUCH_PAUSE_LIMIT = 1500;\n\n  $: handleRadius = 4 / viewportScale;\n\n  const onPointerDown = (event: Event) => {\n    const evt = event as PointerEvent;\n\n    // Note that the event itself is ephemeral!\n    const { timeStamp, offsetX, offsetY } = evt;\n    lastPointerDown = { timeStamp, offsetX, offsetY };\n\n    if (drawingMode === 'drag') {\n      if (points.length === 0) {\n        const point = transform.elementToImage(evt.offsetX, evt.offsetY);\n        points.push(point);\n\n        cursor = point;\n      }\n    }\n  }\n\n  const onPointerMove = (event: Event) => {\n    const evt = event as PointerEvent;\n\n    if (touchPauseTimer) clearTimeout(touchPauseTimer);\n\n    if (points.length > 0) {\n      cursor = transform.elementToImage(evt.offsetX, evt.offsetY);\n\n      if (points.length >  2) {\n        const d = distance(cursor, points[0]) * viewportScale;\n        isClosable = d < CLOSE_DISTANCE;\n      }\n\n      if (evt.pointerType === 'touch') {\n        touchPauseTimer = setTimeout(() => {\n          onDblClick();\n        }, TOUCH_PAUSE_LIMIT);\n      }\n    }\n  }\n\n  const onPointerUp = (event: Event) => {\n    const evt = event as PointerEvent;\n\n    if (touchPauseTimer) clearTimeout(touchPauseTimer);\n\n    if (drawingMode === 'click') {\n      const timeDifference = evt.timeStamp - lastPointerDown.timeStamp;\n\n      const d = distance(\n        [lastPointerDown.offsetX, lastPointerDown.offsetY], \n        [evt.offsetX, evt.offsetY]);\n\n      if (timeDifference > 300 || d > 15) // Not a single click - ignore\n        return;\n\n      if (isClosable) {\n        stopDrawing();\n      } else if (points.length === 0) {\n        // Start drawing\n        const point = transform.elementToImage(evt.offsetX, evt.offsetY);\n        points.push(point);\n\n        cursor = point;\n      } else {\n        if (cursor)\n          points.push(cursor);\n      }\n    } else {\n      // Edge case: if anno.setDrawingEnabled(true) is called while\n      // the pointer is down, this handler may fire with an undefined\n      // cursor (in drag mode). In this case: ignore.\n      if (!cursor) return;\n      \n      // Require minimum drag of 4px\n      if (points.length === 1) {\n        const dist = distance(points[0], cursor!);\n\n        if (dist <= 4) {\n          // Cancel\n          points = [];\n          cursor = undefined;\n\n          return;\n        }\n      }\n\n      // Stop click event from propagating if we're drawing\n      evt.stopImmediatePropagation();\n\n      if (isClosable) {\n        stopDrawing();\n      } else {\n        points.push(cursor);\n      }\n    }\n  }\n\n  const onDblClick = () => {    \n    if (!cursor) return;\n\n    // Require min 3 points and minimum polygon area.\n    // Note that the double click will have added a duplicate point!\n    const p = points.slice(0, -1);\n    if (p.length < 3) return;\n\n    const shape: Polygon = {\n      type: ShapeType.POLYGON, \n      geometry: {\n        bounds: boundsFromPoints(points),\n        points: p\n      }\n    }\n\n    const area = computeArea(shape);\n    if (area > 4) {\n      points = [];\n      cursor = undefined;\n\n      dispatch('create', shape);\n    }\n  }\n\n  const stopDrawing = () => {\n    const shape: Polygon = {\n      type: ShapeType.POLYGON, \n      geometry: {\n        bounds: boundsFromPoints(points),\n        points: [...points]\n      }\n    }\n\n    points = [];\n    cursor = undefined;\n\n    dispatch('create', shape);\n  }\n\n  onMount(() => {\n    addEventListener('pointerdown', onPointerDown, true);\n    addEventListener('pointermove', onPointerMove);\n    addEventListener('pointerup', onPointerUp, true);\n    addEventListener('dblclick', onDblClick, true);\n  });\n\n  $: coords = cursor ? (isClosable ? points : [...points, cursor]) : [];\n\n  $: mask = coords.length > 0 ? getMaskDimensions(boundsFromPoints(coords), 2 / viewportScale) : undefined;\n\n  const maskId = `polygon-mask-${Math.random().toString(36).substring(2, 12)}`;\n</script>\n\n<g class=\"a9s-annotation a9s-rubberband\">\n  {#if mask}\n    {@const str = coords.map(xy => xy.join(',')).join(' ')}\n\n    <defs>\n      <mask id={maskId} class=\"a9s-rubberband-polygon-mask\">\n        <rect x={mask.x} y={mask.y} width={mask.w} height={mask.h} />\n        <polygon points={str} />\n      </mask>\n    </defs>\n\n    <polygon \n      class=\"a9s-outer\"\n      mask={`url(#${maskId})`}\n      points={str} />\n\n    <polygon \n      class=\"a9s-inner\"\n      points={str} />\n        \n    {#if isClosable}\n      <circle \n        class=\"a9s-handle\"\n        cx={points[0][0]} \n        cy={points[0][1]} \n        r={handleRadius} />\n    {/if}\n  {/if}\n</g>\n\n<style>\n  mask.a9s-rubberband-polygon-mask > rect {\n    fill: #fff;\n  }\n\n  mask.a9s-rubberband-polygon-mask > polygon {\n    fill: #000;\n  }\n\n  circle.a9s-handle {\n    fill: #fff;\n    pointer-events: none;\n    stroke: rgba(0, 0, 0, 0.35);\n    stroke-width: 1px;\n    vector-effect: non-scaling-stroke;\n  }\n</style>","import type { SvelteComponent } from 'svelte';\nimport { RubberbandRectangle } from './rectangle';\nimport { RubberbandPolygon } from './polygon';\nimport type { DrawingMode } from '../../AnnotoriousOpts';\n\nexport type DrawingTool = 'rectangle' | 'polygon' | string;\n\nexport type DrawingToolOpts = {\n\n  drawingMode?: DrawingMode;\n\n  [key: string]: any;\n\n}\n\n// @ts-ignore\nconst REGISTERED = new Map<DrawingTool, { tool: typeof SvelteComponent, opts: DrawingToolOpts }>([\n  ['rectangle', { tool: RubberbandRectangle }],\n  ['polygon', { tool: RubberbandPolygon }]\n]);\n\nexport const listDrawingTools = () => [...REGISTERED.keys()];\n\nexport const getTool = (name: string) => REGISTERED.get(name);\n  \nexport const registerTool = (name: string, tool: typeof SvelteComponent, opts: DrawingToolOpts = {}) =>\n  REGISTERED.set(name, { tool, opts });\n","<script lang=\"ts\">\n  import type { DrawingStyleExpression } from '@annotorious/core';\n  import type { Geometry, EllipseGeometry, ImageAnnotation } from '../../model';\n  import { computeStyle } from '../utils/styling';\n  \n  /** Props */\n  export let annotation: ImageAnnotation;\n  export let geom: Geometry;\n  export let style: DrawingStyleExpression<ImageAnnotation> | undefined;\n\n  $: computedStyle = computeStyle(annotation, style);\n\n  const { cx, cy, rx, ry } = geom as EllipseGeometry;\n</script>\n\n<g class=\"a9s-annotation\" data-id={annotation.id}>\n  <ellipse\n    class=\"a9s-outer\"\n    style={computedStyle ? 'display:none;' : undefined}\n    cx={cx} \n    cy={cy} \n    rx={rx} \n    ry={ry} />\n\n  <ellipse\n    class=\"a9s-inner\"\n    style={computedStyle}\n    cx={cx} \n    cy={cy} \n    rx={rx} \n    ry={ry} />\n</g>\n","<script lang=\"ts\">\n  import type { DrawingStyleExpression } from '@annotorious/core';\n  import type { Geometry, LineGeometry, ImageAnnotation } from '../../model';\n  import { computeStyle } from '../utils/styling';\n\n  /** Props */\n  export let annotation: ImageAnnotation;\n  export let geom: Geometry;\n  export let style: DrawingStyleExpression<ImageAnnotation> | undefined;\n\n  $: computedStyle = computeStyle(annotation, style);\n\n  const { points } = geom as LineGeometry;\n  const [[x1, y1], [x2, y2]] = points;\n</script>\n\n<g class=\"a9s-annotation\" data-id={annotation.id}>\n  <line\n    class=\"a9s-outer\"\n    style={computedStyle ? 'display:none;' : undefined}\n    x1={x1}\n    y1={y1}\n    x2={x2}\n    y2={y2} />\n\n  <line\n    class=\"a9s-inner\"\n    style={computedStyle}\n    x1={x1}\n    y1={y1}\n    x2={x2}\n    y2={y2} />\n</g>\n","<script lang=\"ts\">\n  import type { DrawingStyleExpression } from '@annotorious/core';\n  import { multipolygonElementToPath } from '../../model';\n  import type { Geometry, ImageAnnotation, MultiPolygonGeometry } from '../../model';\n  import { computeStyle } from '../utils/styling';\n  \n  /** Props **/\n  export let annotation: ImageAnnotation;\n  export let geom: Geometry;\n  export let style: DrawingStyleExpression<ImageAnnotation> | undefined;\n\n  $: computedStyle = computeStyle(annotation, style);\n\n  const { polygons } = geom as MultiPolygonGeometry;\n</script>\n\n<g class=\"a9s-annotation\" data-id={annotation.id}>\n  {#each polygons as polygonElement}\n    <path \n      class=\"a9s-outer\"\n      style={computedStyle ? 'display:none;' : undefined}\n      fill-rule=\"evenodd\"\n      d={multipolygonElementToPath(polygonElement)} />\n\n    <path \n      class=\"a9s-inner\"\n      style={computedStyle}\n      fill-rule=\"evenodd\"\n      d={multipolygonElementToPath(polygonElement)} />\n  {/each}\n</g>","<script lang=\"ts\">\n  import type { DrawingStyleExpression } from '@annotorious/core';\n  import type { Geometry, ImageAnnotation, PolygonGeometry } from '../../model';\n  import { computeStyle } from '../utils/styling';\n  \n  /** Props **/\n  export let annotation: ImageAnnotation;\n  export let geom: Geometry;\n  export let style: DrawingStyleExpression<ImageAnnotation> | undefined;\n\n  $: computedStyle = computeStyle(annotation, style);\n\n  const { points } = geom as PolygonGeometry;\n</script>\n\n<g class=\"a9s-annotation\" data-id={annotation.id}>\n  <polygon \n    class=\"a9s-outer\"\n    style={computedStyle ? 'display:none;' : undefined}\n    points={points.map(xy => xy.join(',')).join(' ')} />\n\n  <polygon \n    class=\"a9s-inner\"\n    style={computedStyle}\n    points={points.map(xy => xy.join(',')).join(' ')} />\n</g>","<script lang=\"ts\">\n  import type { DrawingStyleExpression } from '@annotorious/core';\n  import { computeSVGPath} from '../../model';\n  import type { Geometry, ImageAnnotation, PolylineGeometry } from '../../model';\n  import { computeStyle } from '../utils/styling';\n  \n  /** Props **/\n  export let annotation: ImageAnnotation;\n  export let geom: Geometry;\n  export let style: DrawingStyleExpression<ImageAnnotation> | undefined;\n\n  $: computedStyle = computeStyle(annotation, style);\n\n  $: d = computeSVGPath(geom as PolylineGeometry);\n\n  $: cssClass = (geom as PolylineGeometry).closed ? 'closed' : 'open'\n</script>\n\n<g class=\"a9s-annotation\" data-id={annotation.id}>\n  <path \n    class={`a9s-outer ${cssClass}`}\n    style={computedStyle ? 'display:none;' : undefined}\n    d={d} />\n\n  <path \n    class={`a9s-inner ${cssClass}`}\n    style={computedStyle}\n    d={d} />\n</g>\n\n<style>\n  path.open {\n    fill: transparent !important;\n  }\n</style>","<script lang=\"ts\">\n  import type { DrawingStyleExpression } from '@annotorious/core';\n  import type { Geometry, ImageAnnotation, RectangleGeometry } from '../../model';\n  import { computeStyle } from '../utils/styling';\n  \n  /** Props **/\n  export let annotation: ImageAnnotation;\n  export let geom: Geometry;\n  export let style: DrawingStyleExpression<ImageAnnotation> | undefined;\n\n  $: computedStyle = computeStyle(annotation, style);\n\n  $: ({ x, y, w, h } = geom as RectangleGeometry);\n</script>\n\n<g class=\"a9s-annotation\" data-id={annotation.id}>\n  <rect\n    class=\"a9s-outer\"\n    style={computedStyle ? 'display:none;' : undefined}\n    x={x} \n    y={y} \n    width={w} \n    height={h} />\n\n  <rect\n    class=\"a9s-inner\"\n    style={computedStyle}\n    x={x} \n    y={y} \n    width={w} \n    height={h} />\n</g>\n","export interface Transform { \n\n  elementToImage: (offsetX: number, offsetY: number) => [ number, number ] \n\n}\n\nexport const IdentityTransform: Transform = {\n\n  elementToImage:  (offsetX: number, offsetY: number) => ([ offsetX, offsetY ])\n\n}\n\nexport const createSVGTransform = (svg: SVGSVGElement): Transform => ({\n\n  elementToImage: (offsetX: number, offsetY: number) => {\n    const bbox = svg.getBoundingClientRect();\n\n    const pt = svg.createSVGPoint();\n    pt.x = offsetX + bbox.x;\n    pt.y = offsetY + bbox.y;\n  \n    const { x, y } = pt.matrixTransform(svg.getScreenCTM()!.inverse());\n    return [x, y];\n  }\n\n});","import { createEventDispatcher } from 'svelte';\nimport type { Annotation } from '@annotorious/core';\nimport type { SvelteImageAnnotationStore } from '../state';\nimport { isTouch } from './utils';\n\nexport interface SVGAnnotationLayerPointerEvent<T extends Annotation> {\n    \n  originalEvent: PointerEvent;\n  \n  annotation?: T;\n\n}\n\n// Maximum amount of ms between pointer down and up to make it a click\nconst MAX_CLICK_DURATION = 250;\n\nexport const addEventListeners = <T extends Annotation>(svg: SVGSVGElement, store: SvelteImageAnnotationStore<T>) => {\n  const dispatch = createEventDispatcher<{ click: SVGAnnotationLayerPointerEvent<T> }>();\n\n  let lastPointerDown: number;\n\n  const onPointerDown = () =>\n    lastPointerDown = performance.now();\n\n  const onPointerUp = (evt: PointerEvent) => {\n    const duration = performance.now() - lastPointerDown;\n\n    if (duration < MAX_CLICK_DURATION) {\n      const { x, y } = getSVGPoint(evt, svg);\n\n      const buffer = isTouch ? 10 : 2;\n      const annotation = store.getAt(x, y, undefined, buffer) as T | undefined;\n\n      if (annotation)\n        dispatch('click', { originalEvent: evt, annotation });\n      else\n        dispatch('click', { originalEvent: evt });\n    }\n  }\n\n  return { onPointerDown, onPointerUp };\n}\n\nexport const getSVGPoint = (evt: PointerEvent, svg: SVGSVGElement) => {\n  const pt = svg.createSVGPoint();\n  const bbox = svg.getBoundingClientRect();\n\n  const x = evt.clientX - bbox.x;\n  const y = evt.clientY - bbox.y;\n\n  const { left, top } = svg.getBoundingClientRect();\n  pt.x = x + left;\n  pt.y = y + top;\n\n  return pt.matrixTransform(svg.getScreenCTM()!.inverse());\n}","<script lang=\"ts\" generics=\"I extends Annotation, E extends unknown\">\n  import { type SvelteComponent, onMount } from 'svelte';\n  import { v4 as uuidv4 } from 'uuid';\n  import type { Annotation, DrawingStyleExpression, StoreChangeEvent, User } from '@annotorious/core';\n  import { isImageAnnotation, ShapeType } from '../model';\n  import type { ImageAnnotation, Shape} from '../model';\n  import { getEditor, EditorMount } from './editors';\n  import { Ellipse, Line, MultiPolygon, Polygon, Polyline, Rectangle} from './shapes';\n  import { getTool, listDrawingTools, ToolMount } from './tools';\n  import { enableResponsive } from './utils';\n  import { createSVGTransform } from './Transform';\n  import { addEventListeners, getSVGPoint } from './SVGAnnotationLayerPointerEvent';\n  import type { SvelteImageAnnotatorState } from 'src/state';\n  import type { DrawingMode } from 'src/AnnotoriousOpts';\n\n  /** Props **/\n  export let drawingEnabled: boolean;\n  export let image: HTMLImageElement | HTMLCanvasElement;\n  export let preferredDrawingMode: DrawingMode;\n  export let state: SvelteImageAnnotatorState<I, E>;\n  export let style: DrawingStyleExpression<ImageAnnotation> | undefined = undefined;\n  export let toolName: string = listDrawingTools()[0];\n  export let user: User;\n  export let visible = true;\n\n  // Trick to force tool re-mounting on cancelDrawing\n  let toolMountKey = 0;\n\n  /** API methods */\n  export const cancelDrawing = () => toolMountKey += 1;\n  export const getDrawingTool = () => toolName;\n  export const isDrawingEnabled = () => drawingEnabled;\n\n  $: ({ tool, opts } = getTool(toolName) || { tool: undefined, opts: undefined });\n\n  $: drawingMode = opts?.drawingMode || preferredDrawingMode;\n\n  /** Drawing tool layer **/\n  let drawingEl: SVGGElement;\n\n  /** Responsive scaling **/\n  let svgEl: SVGSVGElement;\n    \n  let scale: ReturnType<typeof enableResponsive>;\n\n  onMount(() => scale = enableResponsive(image, svgEl));\n\n  $: transform = createSVGTransform(svgEl);\n\n  /** Selection tracking */\n  const { hover, selection, store } = state;\n\n  $: ({ onPointerDown, onPointerUp } = addEventListeners(svgEl, store));\n\n  let storeObserver: (event: StoreChangeEvent<I>) => void | undefined;\n\n  let editableAnnotations: ImageAnnotation[] | undefined;\n\n  $: trackSelection($selection.selected);\n\n  const trackSelection = (selected: { id: string, editable?: boolean }[]) => {\n    if (storeObserver)\n      store.unobserve(storeObserver);\n\n    // Track only editable annotations\n    const editableIds = \n      selected.filter(({ editable }) => editable).map(({ id }) => id);\n\n    if (editableIds.length > 0) {\n      // Resolve selected IDs from the store\n      editableAnnotations = editableIds\n        .map(id => store.getAnnotation(id)!)\n        .filter(a => a && isImageAnnotation(a));\n\n      // Track updates on the editable annotations\n      storeObserver = (event: StoreChangeEvent<I>) => {\n        const { updated } = event.changes;\n        editableAnnotations = updated?.map(change => change.newValue) as unknown as ImageAnnotation[];\n      }   \n      \n      store.observe(storeObserver, { annotations: editableIds });\n    } else {\n      editableAnnotations = undefined;\n    }\n  }\n\n  const onSelectionCreated = <S extends Shape>(evt: CustomEvent<S>) => {\n    const id = uuidv4();\n\n    const annotation: ImageAnnotation = {\n      id,\n      bodies: [],\n      target: {\n        annotation: id,\n        selector: evt.detail,\n        creator: user,\n        created: new Date()\n      }\n    };\n\n    store.addAnnotation(annotation as unknown as Partial<I>);\n\n    selection.setSelected(annotation.id);\n  }\n\n  const onChangeSelected = (annotation: ImageAnnotation) => (event: CustomEvent<Shape>) => {  \n    const { target } = annotation;\n\n    // We don't consider a shape edit an 'update' if it happens within 10mins\n    const GRACE_PERIOD = 10 * 60 * 1000;\n\n    const isUpdate = \n      target.creator?.id !== user.id ||\n      !target.created ||\n      new Date().getTime() - target.created.getTime() > GRACE_PERIOD;\n\n    store.updateTarget({\n      ...target,\n      selector: event.detail,\n      created: isUpdate ? target.created : new Date(),\n      updated: isUpdate ? new Date() : undefined,\n      updatedBy: isUpdate ? user : undefined\n    });\n  }\n\n  const onPointerMove = (evt: PointerEvent) => {\n    const { x, y } = getSVGPoint(evt, svgEl);\n\n    const hit = store.getAt(x, y, undefined, 2);\n    if (hit) {\n      if ($hover !== hit.id) {\n        hover.set(hit.id);\n      }\n    } else {\n      hover.set(undefined);\n    }\n  }\n\n  // [annotation -> editor] - note that we may not have editors available for\n  // all annotations, because they might rely on plugins in some cases!\n  $: editors = editableAnnotations ? editableAnnotations.map(annotation => ({ \n    annotation, editor: getEditor(annotation.target.selector)! \n  })).filter(t => t.editor) : undefined; \n\n  $: isEditable = (a: ImageAnnotation) => editors && editors.some(t => t.annotation.id === a.id);\n</script>\n\n<!-- svelte-ignore a11y-no-noninteractive-tabindex -->\n<svg\n  bind:this={svgEl}\n  role=\"application\"\n  tabindex={0}\n  class=\"a9s-annotationlayer\"\n  class:drawing={tool}\n  class:editing={editableAnnotations}\n  class:hidden={!visible}\n  class:hover={$hover}\n  on:pointerup={onPointerUp}\n  on:pointerdown={onPointerDown}\n  on:pointermove={onPointerMove}>\n  <g>\n    {#each $store.filter(a => isImageAnnotation(a)) as annotation}\n      {#if isImageAnnotation(annotation) && !isEditable(annotation)}\n        {@const selector = annotation.target.selector}\n        {#key annotation}\n          {#if (selector?.type === ShapeType.ELLIPSE)}\n            <Ellipse \n              annotation={annotation} \n              geom={selector?.geometry} \n              style={style} />\n          {:else if (selector?.type === ShapeType.RECTANGLE)}\n            <Rectangle \n              annotation={annotation} \n              geom={selector.geometry} \n              style={style} />\n          {:else if (selector?.type === ShapeType.POLYGON)}\n            <Polygon \n              annotation={annotation} \n              geom={selector.geometry} \n              style={style} />\n          {:else if (selector?.type === ShapeType.MULTIPOLYGON)}\n            <MultiPolygon\n              annotation={annotation}\n              geom={selector.geometry}\n              style={style} />\n          {:else if (selector?.type === ShapeType.POLYLINE)}\n            <Polyline \n              annotation={annotation} \n              geom={selector.geometry}\n              style={style} />\n          {:else if (selector?.type === ShapeType.LINE)}\n            <Line\n              annotation={annotation}\n              geom={selector.geometry}\n              style={style} />\n          {/if}\n        {/key}\n      {/if}\n    {/each}\n  </g>\n\n  <g \n    bind:this={drawingEl}\n    class=\"drawing\" >\n    {#if drawingEl}\n      {#if editors}\n        {#each editors as editable}\n          {#key editable.annotation.id}        \n            <EditorMount\n              target={drawingEl}\n              editor={editable.editor}\n              annotation={editable.annotation}\n              style={style}\n              transform={transform}\n              viewportScale={$scale}\n              on:change={onChangeSelected(editable.annotation)} />\n          {/key}\n        {/each}\n      {:else if (tool && drawingEnabled)} \n        {#key `${toolName}-${toolMountKey}`}\n          <ToolMount \n            target={drawingEl}\n            tool={tool}\n            drawingMode={drawingMode}\n            transform={transform}\n            viewportScale={$scale}\n            on:create={onSelectionCreated} />\n        {/key}\n      {/if}\n    {/if}\n  </g>\n</svg>\n","\n/**\n * Rearranges items so that all items in the [left, k] are the smallest.\n * The k-th element will have the (k - left + 1)-th smallest value in [left, right].\n *\n * @template T\n * @param {T[]} arr the array to partially sort (in place)\n * @param {number} k middle index for partial sorting (as defined above)\n * @param {number} [left=0] left index of the range to sort\n * @param {number} [right=arr.length-1] right index\n * @param {(a: T, b: T) => number} [compare = (a, b) => a - b] compare function\n */\nexport default function quickselect(arr, k, left = 0, right = arr.length - 1, compare = defaultCompare) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            const n = right - left + 1;\n            const m = k - left + 1;\n            const z = Math.log(n);\n            const s = 0.5 * Math.exp(2 * z / 3);\n            const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            quickselect(arr, k, newLeft, newRight, compare);\n        }\n\n        const t = arr[k];\n        let i = left;\n        /** @type {number} */\n        let j = right;\n\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) i++;\n            while (compare(arr[j], t) > 0) j--;\n        }\n\n        if (compare(arr[left], t) === 0) swap(arr, left, j);\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\n/**\n * @template T\n * @param {T[]} arr\n * @param {number} i\n * @param {number} j\n */\nfunction swap(arr, i, j) {\n    const tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\n/**\n * @template T\n * @param {T} a\n * @param {T} b\n * @returns {number}\n */\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n","import quickselect from 'quickselect';\n\nexport default class RBush {\n    constructor(maxEntries = 9) {\n        // max entries in a node is 9 by default; min node fill is 40% for best performance\n        this._maxEntries = Math.max(4, maxEntries);\n        this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n        this.clear();\n    }\n\n    all() {\n        return this._all(this.data, []);\n    }\n\n    search(bbox) {\n        let node = this.data;\n        const result = [];\n\n        if (!intersects(bbox, node)) return result;\n\n        const toBBox = this.toBBox;\n        const nodesToSearch = [];\n\n        while (node) {\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    }\n\n    collides(bbox) {\n        let node = this.data;\n\n        if (!intersects(bbox, node)) return false;\n\n        const nodesToSearch = [];\n        while (node) {\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const childBBox = node.leaf ? this.toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    }\n\n    load(data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (let i = 0; i < data.length; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from scratch using OMT algorithm\n        let node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                const tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    }\n\n    insert(item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    }\n\n    clear() {\n        this.data = createNode([]);\n        return this;\n    }\n\n    remove(item, equalsFn) {\n        if (!item) return this;\n\n        let node = this.data;\n        const bbox = this.toBBox(item);\n        const path = [];\n        const indexes = [];\n        let i, parent, goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) { // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) { // check current node\n                const index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n\n            } else if (parent) { // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n\n            } else node = null; // nothing found\n        }\n\n        return this;\n    }\n\n    toBBox(item) { return item; }\n\n    compareMinX(a, b) { return a.minX - b.minX; }\n    compareMinY(a, b) { return a.minY - b.minY; }\n\n    toJSON() { return this.data; }\n\n    fromJSON(data) {\n        this.data = data;\n        return this;\n    }\n\n    _all(node, result) {\n        const nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push(...node.children);\n            else nodesToSearch.push(...node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    }\n\n    _build(items, left, right, height) {\n\n        const N = right - left + 1;\n        let M = this._maxEntries;\n        let node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        const N2 = Math.ceil(N / M);\n        const N1 = N2 * Math.ceil(Math.sqrt(M));\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (let i = left; i <= right; i += N1) {\n\n            const right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (let j = i; j <= right2; j += N2) {\n\n                const right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    }\n\n    _chooseSubtree(bbox, node, level, path) {\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            let minArea = Infinity;\n            let minEnlargement = Infinity;\n            let targetNode;\n\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const area = bboxArea(child);\n                const enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    }\n\n    _insert(item, level, isNode) {\n        const bbox = isNode ? item : this.toBBox(item);\n        const insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        const node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    }\n\n    // split overflowed node into two\n    _split(insertPath, level) {\n        const node = insertPath[level];\n        const M = node.children.length;\n        const m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        const splitIndex = this._chooseSplitIndex(node, m, M);\n\n        const newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    }\n\n    _splitRoot(node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    }\n\n    _chooseSplitIndex(node, m, M) {\n        let index;\n        let minOverlap = Infinity;\n        let minArea = Infinity;\n\n        for (let i = m; i <= M - m; i++) {\n            const bbox1 = distBBox(node, 0, i, this.toBBox);\n            const bbox2 = distBBox(node, i, M, this.toBBox);\n\n            const overlap = intersectionArea(bbox1, bbox2);\n            const area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index || M - m;\n    }\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis(node, m, M) {\n        const compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;\n        const compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;\n        const xMargin = this._allDistMargin(node, m, M, compareMinX);\n        const yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    }\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin(node, m, M, compare) {\n        node.children.sort(compare);\n\n        const toBBox = this.toBBox;\n        const leftBBox = distBBox(node, 0, m, toBBox);\n        const rightBBox = distBBox(node, M - m, M, toBBox);\n        let margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);\n\n        for (let i = m; i < M - m; i++) {\n            const child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (let i = M - m - 1; i >= m; i--) {\n            const child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    }\n\n    _adjustParentBBoxes(bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (let i = level; i >= 0; i--) {\n            extend(path[i], bbox);\n        }\n    }\n\n    _condense(path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (let i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n\n                } else this.clear();\n\n            } else calcBBox(path[i], this.toBBox);\n        }\n    }\n}\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (let i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (let i = k; i < p; i++) {\n        const child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    const minX = Math.max(a.minX, b.minX);\n    const minY = Math.max(a.minY, b.minY);\n    const maxX = Math.min(a.maxX, b.maxX);\n    const maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    const stack = [left, right];\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        const mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n","import RBush from 'rbush';\nimport { ShapeType,computeArea, intersects, isImageAnnotationTarget } from '../model';\nimport type { ImageAnnotationTarget } from '../model';\nimport type { Annotation, AnnotationTarget, Filter } from '@annotorious/core';\n\ninterface IndexedTarget {\n\n  minX: number;\n\n  minY: number;\n\n  maxX: number;\n\n  maxY: number;\n\n  target: ImageAnnotationTarget;\n\n}\n\nexport const createSpatialTree = () => {\n\n  const tree = new RBush<IndexedTarget>();\n\n  const index = new Map<string, IndexedTarget>();\n\n  const all = () => [...index.values()];\n\n  const clear = () => {\n    tree.clear();\n    index.clear();\n  }\n\n  const insert = (target: AnnotationTarget) => {\n    if (!isImageAnnotationTarget(target)) return;\n\n    const { minX, minY, maxX, maxY } = target.selector.geometry.bounds;\n\n    const t = { minX, minY, maxX, maxY, target };\n\n    tree.insert(t);\n    index.set(target.annotation, t);\n  };\n\n  const remove = (target: AnnotationTarget) => {\n    if (!isImageAnnotationTarget(target)) return;\n\n    const item = index.get(target.annotation);\n    if (item)\n      tree.remove(item);\n    index.delete(target.annotation);\n  };\n\n  const update = (previous: AnnotationTarget, updated: AnnotationTarget) => {\n    remove(previous);\n    insert(updated);\n  };\n\n  const set = (targets: AnnotationTarget[], replace: boolean = true) => {\n    if (replace) \n      clear();\n\n    const indexedTargets = targets.reduce<IndexedTarget[]>((all, target) => {\n      if (isImageAnnotationTarget(target)) {\n        // In case the host app injects any custom annotations, the \n        // spatial index should simply ignore them. \n        const { minX, minY, maxX, maxY } = target.selector.geometry.bounds;\n        return [...all, { minX, minY, maxX, maxY, target } as IndexedTarget];\n      } else {\n        return all;\n      }\n    }, []);\n\n    indexedTargets.forEach(t => index.set(t.target.annotation, t));\n    tree.load(indexedTargets);\n  };\n\n\n  const getAt = (x: number, y: number, buffer: number = 0): ImageAnnotationTarget[] => {\n    const idxHits = tree.search({\n      minX: x - buffer,\n      minY: y - buffer,\n      maxX: x + buffer,\n      maxY: y + buffer\n    }).map(item => item.target);\n\n    // Exact hit test on shape (not needed for rectangles!)\n    const exactHits = idxHits.filter(target => {\n      return (target.selector.type === ShapeType.RECTANGLE) ||\n        intersects(target.selector, x, y, buffer);\n    });\n\n    // Get smallest shape\n    if (exactHits.length > 0) {\n      exactHits.sort((a, b) => computeArea(a.selector) - computeArea(b.selector));\n      return exactHits;\n    } else {\n      return [];\n    }\n  };\n\n  const getIntersecting = (x: number, y: number, width: number, height: number) =>\n    tree.search({\n      minX: x,\n      minY: y,\n      maxX: x + width,\n      maxY: y + height\n    }).map(item => item.target);\n  \n  const size = () => tree.all().length;\n\n  return {\n    all,\n    clear,\n    getAt,\n    getIntersecting,\n    insert,\n    remove,\n    set,\n    size,\n    update\n  }\n\n}\n","import type { ImageAnnotation, ImageAnnotationTarget } from '../model';\nimport type { AnnotoriousOpts } from '../AnnotoriousOpts';\nimport { createSpatialTree } from './spatialTree';\nimport { \n  createViewportState,\n  toSvelteStore,\n  type Annotation,\n  type AnnotatorState, \n  type Filter, \n  type HoverState,\n  type SelectionState\n} from '@annotorious/core';\nimport { \n  createHoverState, \n  createSelectionState, \n  createStore\n} from '@annotorious/core';\nimport type { \n  ImageAnnotationStore,\n  SvelteImageAnnotationStore, \n  SvelteImageAnnotatorState\n} from './ImageAnnotationStore';\n\nexport type ImageAnnotatorState<I extends Annotation = ImageAnnotation, E extends unknown = ImageAnnotation> = AnnotatorState<I, E> & {\n\n  store: ImageAnnotationStore<I>;\n\n  selection: SelectionState<I, E>;\n\n  hover: HoverState<I>;\n\n}\n\nexport const createImageAnnotatorState = <I extends Annotation, E extends unknown> (\n  opts: AnnotoriousOpts<I, E>\n): ImageAnnotatorState<I, E> => {\n\n  const store = createStore<I>();\n\n  const tree = createSpatialTree();\n\n  const selection = createSelectionState<I, E>(store, opts.userSelectAction, opts.adapter);\n\n  const hover = createHoverState(store);\n\n  const viewport = createViewportState();\n\n  store.observe(({ changes }) => {\n    tree.set((changes.created || []).map(a => a.target as ImageAnnotationTarget), false);\n    \n    (changes.deleted || []).forEach(a => tree.remove(a.target as ImageAnnotationTarget));\n    \n    (changes.updated || []).forEach(({ oldValue, newValue }) => \n      tree.update(oldValue.target, newValue.target));\n  });\n\n  const getAt = (x: number, y: number, filter?: Filter<I>, buffer?: number): I | undefined => {\n    const targets = tree.getAt(x, y, buffer);\n\n    if (filter) {\n      // Resolve annotations first, so we can filter\n      const annotations = targets.map(t => store.getAnnotation(t.annotation)!)\n        .filter(Boolean)\n        .filter(filter);\n        \n      return annotations[0];\n    } else {\n      const top = targets[0];\n      return top ? store.getAnnotation(top.annotation) : undefined;\n    }\n  }\n\n  const getIntersecting = (x: number, y: number, width: number, height: number) =>\n    tree.getIntersecting(x, y, width, height)\n      .map(target => store.getAnnotation(target.annotation) as I)\n      .filter(Boolean); // Race conditions may have deleted annotations concurrently\n\n  return {\n    store: {\n      ...store,\n      getAt,\n      getIntersecting\n    },\n    selection,\n    hover,\n    viewport\n  } as ImageAnnotatorState<I, E>;\n\n}\n\nexport const createSvelteImageAnnotatorState = <I extends Annotation, E extends unknown>(  \n  opts: AnnotoriousOpts<I, E>\n): SvelteImageAnnotatorState<I, E> => {\n\n  const state = createImageAnnotatorState<I, E>(opts);\n  \n  return {\n    ...state,\n    store: toSvelteStore(state.store) as SvelteImageAnnotationStore<I>\n  }\n\n}\n","import type { Theme } from '../../AnnotoriousOpts';\n\nexport const sampleBrightness = (imageOrCanvas: HTMLElement) => {\n\n  let canvas: HTMLCanvasElement;\n\n  let context: CanvasRenderingContext2D;\n\n  if (imageOrCanvas.nodeName === 'CANVAS') {\n    canvas = imageOrCanvas as HTMLCanvasElement;\n    context = canvas.getContext('2d', { willReadFrequently: true })!;\n  } else {\n    const img = imageOrCanvas as HTMLImageElement;\n    // Copy image to in-memory canvas for processing\n    canvas = document.createElement('canvas');\n    canvas.width = img.width;\n    canvas.height = img.height;\n\n    context = canvas.getContext('2d', { willReadFrequently: true })!;\n    context.drawImage(img, 0, 0, img.width, img.height);\n  }\n\n  let totalBrightness = 0;\n\n  // Sample a grid of points spaced 10% width/height apart (= 9 x 9 samples)\n  for (let i = 1; i < 10; i++) {\n    for (let j = 1; j < 10; j++) {\n      const x = Math.round(j * canvas.width / 10);\n      const y = Math.round(i * canvas.height / 10);\n\n      const pixelData = context.getImageData(x, y, 1, 1).data;\n      const brightness = (0.299 * pixelData[0] + 0.587 * pixelData[1] + 0.114 * pixelData[2]) / 255;\n      totalBrightness += brightness;\n    }\n  }\n\n  return totalBrightness / 81;\n}\n\nexport const detectTheme = (imageOrCanvas: HTMLElement) => {\n  const brightness = sampleBrightness(imageOrCanvas);\n  const theme = brightness > 0.6 ? 'dark' : 'light'\n\n  console.log(`[Annotorious] Image brightness: ${brightness.toFixed(1)}. Setting ${theme} theme.`);\n\n  return theme;\n}\n\nexport const setTheme = (imageOrCanvas: HTMLElement, container: HTMLElement, theme: Theme) =>\n  container.setAttribute('data-theme', theme === 'auto' ? detectTheme(imageOrCanvas) : theme);","import type { Annotation, DrawingStyleExpression, FormatAdapter, History, UserSelectActionExpression } from '@annotorious/core';\nimport type { ImageAnnotation } from './model';\n\nexport interface AnnotoriousOpts<I extends Annotation = ImageAnnotation, E extends unknown = ImageAnnotation> {\n\n  adapter?: FormatAdapter<I, E>;\n\n  autoSave?: boolean;\n\n  drawingEnabled?: boolean;\n\n  // 'click': starts on single click, user cannot select unless drawingEnabled = false\n  // 'drag': starts drawing on drag, single click always selects\n  drawingMode?: DrawingMode;\n\n  initialHistory?: History<I>;\n\n  // Modal selection mode WILL NOT CHANGE OR DE-SELECT THE CURRENT SELECTION if another \n  // annotation or empty space is clicked. Warning: this means that the user is no longer\n  // able to de-select until a programmatic de-select is triggered from the host app!\n  // Use this mode only in combination with custom popups!\n  modalSelect?: boolean;\n\n  userSelectAction?: UserSelectActionExpression<E>;\n\n  style?: DrawingStyleExpression<ImageAnnotation>;\n\n  theme?: Theme;\n\n}\n\nexport type DrawingMode = 'click' | 'drag';\n\nexport type Theme = 'dark' | 'light' | 'auto';\n\nexport const fillDefaults = <I extends Annotation = ImageAnnotation, E extends unknown = ImageAnnotation> (\n  opts: AnnotoriousOpts<I, E>,\n  defaults: AnnotoriousOpts<I, E>\n): AnnotoriousOpts<I, E> => ({\n  ...opts,\n  drawingEnabled: opts.drawingEnabled === undefined ? defaults.drawingEnabled : opts.drawingEnabled,\n  drawingMode: opts.drawingMode || defaults.drawingMode,\n  userSelectAction: opts.userSelectAction || defaults.userSelectAction,\n  theme: opts.theme || defaults.theme\n});\n\n\n\n\n","import type { Annotation, UndoStack } from '@annotorious/core';\n\nexport const isMac = (() => {\n  if (typeof navigator === 'undefined') return false;\n\n  return navigator.userAgent.indexOf('Mac OS X') !== -1;\n})();\n\nexport const initKeyboardCommands = <T extends Annotation>(\n  undoStack: UndoStack<T>,\n  container?: Element \n) => {\n\n  const el = container || document;\n\n  const onWinKeyDown = (evt: Event) => {\n    const event = evt as KeyboardEvent;\n    \n    if (event.key === 'z' && event.ctrlKey) {\n      undoStack.undo();\n    } else if (event.key === 'y' && event.ctrlKey) {\n      undoStack.redo()\n    }\n  };\n\n  const onMacKeyDown = (evt: Event) => {\n    const event = evt as KeyboardEvent;\n\n    if (event.key === 'z' && event.metaKey) {\n      if (event.shiftKey) {\n        undoStack.redo()\n      } else {\n        undoStack.undo();\n      }\n    }\n  }\n\n  const destroy = () => {\n    if (isMac) {\n      el.removeEventListener('keydown', onMacKeyDown);\n    } else {\n      el.removeEventListener('keydown', onWinKeyDown);\n    }\n  }\n\n  if (isMac)\n    el.addEventListener('keydown', onMacKeyDown);\n  else\n    el.addEventListener('keydown', onWinKeyDown);\n\n  return { \n    destroy\n  }\n}\n","import type { SvelteComponent } from 'svelte';\nimport { UserSelectAction } from '@annotorious/core';\nimport type { Annotation, Annotator, DrawingStyleExpression, Filter, User } from '@annotorious/core';\nimport { createAnonymousGuest, createBaseAnnotator, createLifecycleObserver, createUndoStack } from '@annotorious/core';\nimport { registerEditor } from './annotation/editors';\nimport { getTool, registerTool, listDrawingTools, type DrawingTool } from './annotation/tools';\nimport { SVGAnnotationLayer } from './annotation';\nimport type { DrawingToolOpts, SVGAnnotationLayerPointerEvent } from './annotation';\nimport type { ImageAnnotation, ShapeType } from './model';\nimport { createSvelteImageAnnotatorState } from './state';\nimport { setTheme as _setTheme } from './themes';\nimport { fillDefaults, type Theme } from './AnnotoriousOpts';\nimport type { AnnotoriousOpts } from './AnnotoriousOpts';\nimport { initKeyboardCommands } from './keyboardCommands';\n\nimport './Annotorious.css';\nimport './themes/dark/index.css';\nimport './themes/light/index.css';\n\nexport interface ImageAnnotator<I extends Annotation = ImageAnnotation, E extends unknown = ImageAnnotation> extends Annotator<I, E> { \n\n  element: HTMLDivElement;\n\n  cancelDrawing(): void;\n\n  getDrawingTool(): string | undefined;\n\n  isDrawingEnabled(): boolean;\n\n  listDrawingTools(): string[];\n\n  registerDrawingTool(name: string, tool: typeof SvelteComponent, opts?: DrawingToolOpts): void;\n\n  registerShapeEditor(shapeType: ShapeType, editor: typeof SvelteComponent): void;\n\n  setDrawingTool(name: DrawingTool): void; \n\n  setDrawingEnabled(enabled: boolean): void;\n\n  setTheme(theme: Theme): void;\n\n}\n\nexport const createImageAnnotator = <I extends Annotation = ImageAnnotation, E extends unknown = ImageAnnotation>(\n  image: string | HTMLImageElement | HTMLCanvasElement, \n  options: AnnotoriousOpts<I, E> = {}\n): ImageAnnotator<I, E> => {\n\n  if (!image)\n    throw 'Missing argument: image';\n\n  const img = (\n    typeof image === 'string' ? document.getElementById(image) : image\n  ) as HTMLImageElement | HTMLCanvasElement;\n\n  const opts = fillDefaults<I, E>(options, {\n    drawingEnabled: true,\n    drawingMode: 'drag',\n    userSelectAction: UserSelectAction.EDIT,\n    theme: 'light'\n  });\n\n  const state = createSvelteImageAnnotatorState<I, E>(opts);\n\n  const { selection, store } = state;\n\n  const undoStack = createUndoStack(store, opts.initialHistory);\n\n  const lifecycle = createLifecycleObserver<I, E>(\n    state, undoStack, opts.adapter, opts.autoSave\n  );\n\n  // We'll wrap the image in a container DIV.\n  const container = document.createElement('DIV') as HTMLDivElement;\n  container.style.position = 'relative';\n  container.style.display = 'inline-block';\n\n  // Wrapper div has unwanted margin at the bottom otherwise!\n  img.style.display = 'block';\n\n  img.parentNode!.insertBefore(container, img);\n  container.appendChild(img);\n\n  const keyboardCommands = initKeyboardCommands(undoStack);\n\n  let currentUser: User = createAnonymousGuest();\n\n  _setTheme(img, container, opts.theme!);\n\n  const annotationLayer = new SVGAnnotationLayer({\n    target: container,\n    props: { \n      drawingEnabled: Boolean(opts.drawingEnabled), \n      image: img, \n      preferredDrawingMode: opts.drawingMode!,\n      state: state, \n      style: opts.style, \n      user: currentUser\n    }\n  });\n\n  annotationLayer.$on('click', (evt: CustomEvent<SVGAnnotationLayerPointerEvent<I>>) => {\n    const { originalEvent, annotation } = evt.detail;\n    if (annotation)\n      selection.userSelect(annotation.id, originalEvent);\n    else if (!selection.isEmpty())\n      selection.clear();\n  });\n\n  /*************************/\n  /*      External API     */\n  /******++++++*************/\n\n  // Most of the external API functions are covered in the base annotator\n  const base = createBaseAnnotator<I, E>(state, undoStack, opts.adapter);\n\n  const cancelDrawing = () =>\n    annotationLayer.cancelDrawing();\n\n  const destroy = () => {\n    // Destroy Svelte annotation layer\n    annotationLayer.$destroy();\n\n    // Unwrap the image\n    container.parentNode!.insertBefore(img, container);\n    container.parentNode!.removeChild(container);\n\n    // Other cleanup actions\n    keyboardCommands.destroy();\n    undoStack.destroy();\n  }\n\n  const getDrawingTool = () =>\n    annotationLayer.getDrawingTool();\n\n  const getUser = () => currentUser;\n\n  const isDrawingEnabled = () => \n    annotationLayer.isDrawingEnabled();\n\n  const registerDrawingTool = (name: string, tool: typeof SvelteComponent, opts?: DrawingToolOpts) =>\n    registerTool(name, tool, opts);\n\n  const registerShapeEditor = (shapeType: ShapeType, editor: typeof SvelteComponent) =>\n    registerEditor(shapeType, editor);\n\n  const setDrawingTool = (name: DrawingTool) => {\n    // Validate that the tool exists\n    const toolSpec = getTool(name);\n    if (!toolSpec)\n      throw `No drawing tool named ${name}`;\n\n    // @ts-ignore\n    annotationLayer.$set({ toolName: name })\n  }\n\n  const setDrawingEnabled = (enabled: boolean) =>\n    annotationLayer.$set({ drawingEnabled: enabled });\n  \n  const setFilter = (_: Filter) => {\n    console.warn('Filter not implemented yet');\n  }\n\n  const setStyle = (style: DrawingStyleExpression<I> | undefined) =>\n    annotationLayer.$set({ style: style as DrawingStyleExpression<ImageAnnotation> });\n\n  const setTheme = (theme: Theme) => _setTheme(img, container, theme);\n  \n  const setUser = (user: User) => {\n    currentUser = user;\n    annotationLayer.$set({ user });\n  }\n\n  const setVisible = (visible: boolean) =>\n    // @ts-ignore\n    annotationLayer.$set({ visible });\n\n  return {\n    ...base,\n    cancelDrawing,\n    destroy,\n    getDrawingTool,\n    getUser,\n    isDrawingEnabled,\n    listDrawingTools,\n    on: lifecycle.on,\n    off: lifecycle.off,\n    registerDrawingTool,\n    registerShapeEditor,\n    setDrawingEnabled,\n    setDrawingTool,\n    setFilter,\n    setStyle,\n    setTheme,\n    setUser,\n    setVisible,\n    element: container,\n    state\n  }\n\n}\n"],"names":["noop","assign","tar","src","k","run","fn","blank_object","run_all","fns","is_function","thing","safe_not_equal","a","b","is_empty","obj","subscribe","store","callbacks","callback","unsub","component_subscribe","component","create_slot","definition","ctx","$$scope","slot_ctx","get_slot_context","get_slot_changes","dirty","lets","merged","len","i","update_slot_base","slot","slot_definition","slot_changes","get_slot_context_fn","slot_context","get_all_dirty_from_scope","length","exclude_internal_props","props","result","null_to_empty","value","append","target","node","insert","anchor","detach","destroy_each","iterations","detaching","svg_element","name","text","data","space","empty","listen","event","handler","options","attr","attribute","children","element","toggle_class","toggle","custom_event","type","detail","bubbles","cancelable","current_component","set_current_component","get_current_component","onMount","createEventDispatcher","bubble","dirty_components","binding_callbacks","render_callbacks","flush_callbacks","resolved_promise","update_scheduled","schedule_update","flush","tick","add_render_callback","seen_callbacks","flushidx","saved_component","update","e","$$","flush_render_callbacks","filtered","targets","c","outroing","outros","group_outros","check_outros","transition_in","block","local","transition_out","ensure_array_like","array_like_or_iterator","create_component","mount_component","fragment","after_update","new_on_destroy","destroy_component","make_dirty","init","instance","create_fragment","not_equal","append_styles","parent_component","ready","ret","rest","nodes","SvelteComponent","__publicField","index","PUBLIC_VERSION","ShapeType","getSqDist","p1","p2","dx","dy","getSqSegDist","p","x","y","t","simplifyRadialDist","points","sqTolerance","prevPoint","newPoints","point","simplifyDPStep","first","last","simplified","maxSqDist","sqDist","simplifyDouglasPeucker","simplify","tolerance","highestQuality","module","Utils","registerShapeUtil","util","computeArea","shape","intersects","buffer","boundsFromPoints","minX","minY","maxX","maxY","computePolygonArea","area","j","isPointInPolygon","inside","xi","yi","xj","yj","pointsToPath","close","d","idx","simplifyPoints","mapped","pt","distance","EllipseUtil","cx","cy","rx","ry","rot","cos","sin","tdx","tdy","LineUtil","_","l","x1","y1","x2","y2","MultiPolygonUtil","multiPolygon","polygons","total","exterior","holes","exteriorArea","holesArea","hole","insideAnyHole","boundsFromMultiPolygonElements","elements","outerPoints","multipolygonElementToPath","ring","getAllCorners","geom","all","onThisElement","simplifyMultiPolygon","multi","polygon","rings","bounds","PolygonUtil","simplifyPolygon","PolylineUtil","polyline","approximateAsPolygon","isPointNearPath","corners","closed","currentPoint","nextPoint","curvePoints","approximateBezierCurve","p0","p3","segments","distanceToLineSegment","lineStart","lineEnd","px","py","computeSVGPath","pathCommands","firstPoint","previousPoint","cp1","cp2","endPoint","lastPoint","firstPointRef","RectangleUtil","rect","isImageAnnotation","isImageAnnotationTarget","_a","_b","parseFragmentSelector","fragmentOrSelector","invertY","regex","matches","prefix","unit","w","h","serializeFragmentSelector","geometry","SVG_NAMESPACE","sanitize","doc","cleanEl","el","scripts","insertSVGNamespace","originalDoc","namespaced","parseSVGXML","isPrefixDeclared","isDefaultNamespaceSVG","svgPathToMultiPolygonElement","commands","parsePathCommands","currentRing","cmd","areHandlesSymmetrical","inHandle","outHandle","dx1","dy1","dx2","dy2","cross","svgPathToPolyline","newPoint","cleanPath","commandRegex","match","commandLetter","argsString","args","n","parseSVGPolygon","__","str","parseSVGEllipse","parseSVGLine","parseSVGPathToPolyline","path","parseSVGPathToPolygon","parseSVGSelector","valueOrSelector","serializeMultiPolygon","elem","serializeSVGSelector","xy","byteToHex","unsafeStringify","arr","offset","getRandomValues","rnds8","rng","randomUUID","native","_v4","buf","rnds","v4","M","N","V","Z","z","P","s","v","E","g","m","De","F","$","Be","A","L","T","f","u","C","D","K","R","ee","Y","te","ne","oe","W","se","o","q","xe","ie","de","re","ce","G","O","le","ue","fe","ke","r","U","B","I","S","Q","X","H","Ie","J","pe","Ne","ze","_e","ge","Ve","Ye","je","he","me","Ae","be","ve","Pe","Ee","we","He","Me","Ce","ye","W3CImageFormat","source","opts","serialized","parseW3CImageAnnotation","annotation","serializeW3CImageAnnotation","annotationId","uuidv4","creator","created","modified","body","bodies","parseW3CBodies","w3cTarget","w3cSelector","selector","parseW3CUser","updated","updatedBy","error","serializeW3CBodies","subscriber_queue","writable","start","stop","subscribers","set","new_value","run_queue","subscriber","invalidate","setSize","image","svg","naturalWidth","naturalHeight","width","height","img","enableResponsive","resizeObserver","svgBounds","scale","computeStyle","style","computed","fill","fillOpacity","stroke","strokeWidth","strokeOpacity","css","getMaskDimensions","isTouch","dispatch","$$props","editor","transform","svgEl","grabbedHandle","origin","initialShape","onGrab","handle","evt","left","top","offsetX","offsetY","onPointerMove","delta","$$invalidate","onRelease","create_if_block_1","g_class_value","circle0","circle1","circle0_r_value","circle2","circle","create_if_block","selected","touched","onPointerDown","onPointerUp","handleRadius","constants_0","child_ctx","circle_cx_value","circle_cy_value","circle_r_value","MIDPOINT_SIZE","rect_x_value","rect_y_value","rect_width_value","rect_height_value","mask_1","handle_changes","midpointhandle_changes","create_if_block_2","get_if_ctx_2","get_if_ctx_1","each_value","get_if_ctx","polygon0","polygon0_points_value","func","polygon1","polygon1_points_value","func_1","polygon2","polygon2_points_value","func_2","defs","current","each_blocks","grab","CLICK_THRESHOLD","MIN_HOVER_DISTANCE","MIN_CORNER_DISTANCE","computedStyle","viewportScale","visibleMidpoint","isHandleHovered","lastHandleClick","selectedCorners","onEnterHandle","onLeaveHandle","midpoints","getDistSq","closestCorner","closest","corner","closestVisibleMidpoint","midpoint","threshold","reclaimFocus","onShapePointerUp","onHandlePointerDown","onHandlePointerUp","isSelected","onAddPoint","midpointIdx","newHandle","newEvent","onDeleteSelected","onKeydown","maskId","thisCorner","nextCorner","visible","mask","rect0","rect0_x_value","rect0_y_value","rect0_width_value","rect0_height_value","rect1","rect1_x_value","rect1_y_value","rect1_width_value","rect1_height_value","rect2","rect2_x_value","rect2_y_value","rect2_width_value","rect2_height_value","rect3","rect3_x_value","rect3_y_value","rect3_width_value","rect3_height_value","rect4","rect4_x_value","rect4_y_value","rect4_width_value","rect5","rect5_x_value","rect5_y_value","rect5_height_value","rect6","rect6_x_value","rect6_y_value","rect6_width_value","rect7","rect7_x_value","rect7_y_value","rect7_height_value","handle0_changes","handle1_changes","handle2_changes","handle3_changes","rectangle","initialBounds","x0","y0","has","dequal","foo","bar","ctor","MIN_VISIBILITY_DISTANCE","computeMidpoints","elementIdx","forThisPolygon","ringIdx","forThisRing","thisPoint","pointIdx","each_value_2","each_value_1","path0","path0_d_value","path1","path1_d_value","path2","path2_d_value","isMatch","other","elIdx","updatedPolygons","polygonIdx","updatedRings","selectedCornersInRing","REGISTERED","RectangleEditor","PolygonEditor","MultiPolygonEditor","getEditor","registerEditor","shapeType","editorComponent","drawingMode","tool","toolComponent","cleanup","addEventListener","capture","lastPointerDown","timeDifference","stopDrawing","CLOSE_DISTANCE","TOUCH_PAUSE_LIMIT","cursor","touchPauseTimer","isClosable","timeStamp","onDblClick","coords","RubberbandRectangle","RubberbandPolygon","listDrawingTools","getTool","registerTool","g_data_id_value","ellipse0","ellipse1","line0","line1","cssClass","IdentityTransform","createSVGTransform","bbox","MAX_CLICK_DURATION","addEventListeners","getSVGPoint","line_changes","polyline_changes","multipolygon_changes","polygon_changes","rectangle_changes","ellipse_changes","_c","_d","_f","show_if","previous_key","editormount_changes","g0","g1","drawingEnabled","preferredDrawingMode","state","toolName","user","toolMountKey","cancelDrawing","getDrawingTool","isDrawingEnabled","drawingEl","hover","selection","storeObserver","editableAnnotations","trackSelection","editableIds","editable","id","change","onSelectionCreated","onChangeSelected","GRACE_PERIOD","isUpdate","hit","$hover","$$value","$selection","editors","isEditable","quickselect","right","compare","defaultCompare","sd","newLeft","newRight","swap","tmp","RBush","maxEntries","toBBox","nodesToSearch","child","childBBox","contains","tmpNode","item","createNode","equalsFn","indexes","parent","goingUp","findItem","items","calcBBox","N2","N1","multiSelect","right2","right3","level","minArea","minEnlargement","targetNode","bboxArea","enlargement","enlargedArea","isNode","insertPath","extend","splitIndex","newNode","minOverlap","bbox1","distBBox","bbox2","overlap","intersectionArea","compareMinX","compareNodeMinX","compareMinY","compareNodeMinY","xMargin","yMargin","leftBBox","rightBBox","margin","bboxMargin","siblings","destNode","stack","mid","createSpatialTree","tree","clear","remove","exactHits","replace","indexedTargets","previous","createImageAnnotatorState","createStore","createSelectionState","createHoverState","viewport","createViewportState","changes","oldValue","newValue","filter","createSvelteImageAnnotatorState","toSvelteStore","sampleBrightness","imageOrCanvas","canvas","context","totalBrightness","pixelData","brightness","detectTheme","theme","setTheme","container","fillDefaults","defaults","isMac","initKeyboardCommands","undoStack","onWinKeyDown","onMacKeyDown","destroy","createImageAnnotator","UserSelectAction","createUndoStack","lifecycle","createLifecycleObserver","keyboardCommands","currentUser","createAnonymousGuest","_setTheme","annotationLayer","SVGAnnotationLayer","originalEvent","base","createBaseAnnotator","getUser","registerDrawingTool","registerShapeEditor","setDrawingTool","setDrawingEnabled","enabled","setFilter","setStyle","setUser","setVisible"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,10,23,24,25,26,29,39,57,58]}